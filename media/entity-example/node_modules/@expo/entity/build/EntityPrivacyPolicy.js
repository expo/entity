"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityAuthorizationAction = exports.EntityPrivacyPolicyEvaluationMode = void 0;
const EntityNotAuthorizedError_1 = __importDefault(require("./errors/EntityNotAuthorizedError"));
const IEntityMetricsAdapter_1 = require("./metrics/IEntityMetricsAdapter");
const PrivacyPolicyRule_1 = require("./rules/PrivacyPolicyRule");
/**
 * Evaluation mode for a EntityPrivacyPolicy. Useful when transitioning to
 * using Entity for privacy.
 */
var EntityPrivacyPolicyEvaluationMode;
(function (EntityPrivacyPolicyEvaluationMode) {
    /**
     * Enforce this privacy policy. Throw upon denial.
     */
    EntityPrivacyPolicyEvaluationMode[EntityPrivacyPolicyEvaluationMode["ENFORCE"] = 0] = "ENFORCE";
    /**
     * Do not enforce this privacy policy. Always allow but log when it would have denied.
     */
    EntityPrivacyPolicyEvaluationMode[EntityPrivacyPolicyEvaluationMode["DRY_RUN"] = 1] = "DRY_RUN";
    /**
     * Enforce this privacy policy. Throw and log upon denial.
     */
    EntityPrivacyPolicyEvaluationMode[EntityPrivacyPolicyEvaluationMode["ENFORCE_AND_LOG"] = 2] = "ENFORCE_AND_LOG";
})(EntityPrivacyPolicyEvaluationMode || (exports.EntityPrivacyPolicyEvaluationMode = EntityPrivacyPolicyEvaluationMode = {}));
var EntityAuthorizationAction;
(function (EntityAuthorizationAction) {
    EntityAuthorizationAction[EntityAuthorizationAction["CREATE"] = 0] = "CREATE";
    EntityAuthorizationAction[EntityAuthorizationAction["READ"] = 1] = "READ";
    EntityAuthorizationAction[EntityAuthorizationAction["UPDATE"] = 2] = "UPDATE";
    EntityAuthorizationAction[EntityAuthorizationAction["DELETE"] = 3] = "DELETE";
})(EntityAuthorizationAction || (exports.EntityAuthorizationAction = EntityAuthorizationAction = {}));
/**
 * Privacy policy for an entity.
 *
 * @remarks
 *
 * A privacy policy declares lists of PrivacyPolicyRule for create, read, update, and delete actions
 * for an entity and provides logic for authorizing an entity against rules.
 *
 * Evaluation of a list of rules is performed according the following example. This allows constructing of
 * complex yet testable permissioning logic for an entity.
 *
 * @example
 *
 * ```
 * foreach rule in rules:
 *   return authorized if rule allows
 *   return not authorized if rule denies
 *   continue to next rule if rule skips
 * return not authorized if all rules skip
 * ```
 */
class EntityPrivacyPolicy {
    createRules = [];
    readRules = [];
    updateRules = [];
    deleteRules = [];
    /**
     * Get the privacy policy evaluation mode and deny handler for this policy.
     * Defaults to normal enforcing policy.
     *
     * @remarks
     *
     * Override to enable dry run evaluation of the policy.
     */
    getPrivacyPolicyEvaluator(_viewerContext) {
        return {
            mode: EntityPrivacyPolicyEvaluationMode.ENFORCE,
        };
    }
    /**
     * Authorize an entity against creation policy.
     * @param viewerContext - viewer context of user creating the entity
     * @param queryContext - query context in which to perform the create authorization
     * @param entity - entity to authorize
     * @returns entity if authorized
     * @throws EntityNotAuthorizedError when not authorized
     */
    async authorizeCreateAsync(viewerContext, queryContext, evaluationContext, entity, metricsAdapter) {
        return await this.authorizeForRulesetAsync(this.createRules, viewerContext, queryContext, evaluationContext, entity, EntityAuthorizationAction.CREATE, metricsAdapter);
    }
    /**
     * Authorize an entity against read policy.
     * @param viewerContext - viewer context of user reading the entity
     * @param queryContext - query context in which to perform the read authorization
     * @param entity - entity to authorize
     * @returns entity if authorized
     * @throws EntityNotAuthorizedError when not authorized
     */
    async authorizeReadAsync(viewerContext, queryContext, evaluationContext, entity, metricsAdapter) {
        return await this.authorizeForRulesetAsync(this.readRules, viewerContext, queryContext, evaluationContext, entity, EntityAuthorizationAction.READ, metricsAdapter);
    }
    /**
     * Authorize an entity against update policy.
     * @param viewerContext - viewer context of user updating the entity
     * @param queryContext - query context in which to perform the update authorization
     * @param entity - entity to authorize
     * @returns entity if authorized
     * @throws EntityNotAuthorizedError when not authorized
     */
    async authorizeUpdateAsync(viewerContext, queryContext, evaluationContext, entity, metricsAdapter) {
        return await this.authorizeForRulesetAsync(this.updateRules, viewerContext, queryContext, evaluationContext, entity, EntityAuthorizationAction.UPDATE, metricsAdapter);
    }
    /**
     * Authorize an entity against deletion policy.
     * @param viewerContext - viewer context of user deleting the entity
     * @param queryContext - query context in which to perform the delete authorization
     * @param entity - entity to authorize
     * @returns entity if authorized
     * @throws EntityNotAuthorizedError when not authorized
     */
    async authorizeDeleteAsync(viewerContext, queryContext, evaluationContext, entity, metricsAdapter) {
        return await this.authorizeForRulesetAsync(this.deleteRules, viewerContext, queryContext, evaluationContext, entity, EntityAuthorizationAction.DELETE, metricsAdapter);
    }
    async authorizeForRulesetAsync(ruleset, viewerContext, queryContext, evaluationContext, entity, action, metricsAdapter) {
        const privacyPolicyEvaluator = this.getPrivacyPolicyEvaluator(viewerContext);
        switch (privacyPolicyEvaluator.mode) {
            case EntityPrivacyPolicyEvaluationMode.ENFORCE:
                try {
                    const result = await this.authorizeForRulesetInnerAsync(ruleset, viewerContext, queryContext, evaluationContext, entity, action);
                    metricsAdapter.logAuthorizationEvent({
                        entityClassName: entity.constructor.name,
                        action,
                        evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.ALLOW,
                        privacyPolicyEvaluationMode: privacyPolicyEvaluator.mode,
                    });
                    return result;
                }
                catch (e) {
                    if (!(e instanceof EntityNotAuthorizedError_1.default)) {
                        throw e;
                    }
                    metricsAdapter.logAuthorizationEvent({
                        entityClassName: entity.constructor.name,
                        action,
                        evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                        privacyPolicyEvaluationMode: privacyPolicyEvaluator.mode,
                    });
                    throw e;
                }
            case EntityPrivacyPolicyEvaluationMode.ENFORCE_AND_LOG:
                try {
                    const result = await this.authorizeForRulesetInnerAsync(ruleset, viewerContext, queryContext, evaluationContext, entity, action);
                    metricsAdapter.logAuthorizationEvent({
                        entityClassName: entity.constructor.name,
                        action,
                        evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.ALLOW,
                        privacyPolicyEvaluationMode: privacyPolicyEvaluator.mode,
                    });
                    return result;
                }
                catch (e) {
                    if (!(e instanceof EntityNotAuthorizedError_1.default)) {
                        throw e;
                    }
                    privacyPolicyEvaluator.denyHandler(e);
                    metricsAdapter.logAuthorizationEvent({
                        entityClassName: entity.constructor.name,
                        action,
                        evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                        privacyPolicyEvaluationMode: privacyPolicyEvaluator.mode,
                    });
                    throw e;
                }
            case EntityPrivacyPolicyEvaluationMode.DRY_RUN:
                try {
                    const result = await this.authorizeForRulesetInnerAsync(ruleset, viewerContext, queryContext, evaluationContext, entity, action);
                    metricsAdapter.logAuthorizationEvent({
                        entityClassName: entity.constructor.name,
                        action,
                        evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.ALLOW,
                        privacyPolicyEvaluationMode: privacyPolicyEvaluator.mode,
                    });
                    return result;
                }
                catch (e) {
                    if (!(e instanceof EntityNotAuthorizedError_1.default)) {
                        throw e;
                    }
                    privacyPolicyEvaluator.denyHandler(e);
                    metricsAdapter.logAuthorizationEvent({
                        entityClassName: entity.constructor.name,
                        action,
                        evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                        privacyPolicyEvaluationMode: privacyPolicyEvaluator.mode,
                    });
                    return entity;
                }
        }
    }
    async authorizeForRulesetInnerAsync(ruleset, viewerContext, queryContext, evaluationContext, entity, action) {
        for (let i = 0; i < ruleset.length; i++) {
            const rule = ruleset[i];
            const ruleEvaluationResult = await rule.evaluateAsync(viewerContext, queryContext, evaluationContext, entity);
            switch (ruleEvaluationResult) {
                case PrivacyPolicyRule_1.RuleEvaluationResult.DENY:
                    throw new EntityNotAuthorizedError_1.default(entity, viewerContext, action, i);
                case PrivacyPolicyRule_1.RuleEvaluationResult.SKIP:
                    continue;
                case PrivacyPolicyRule_1.RuleEvaluationResult.ALLOW:
                    return entity;
                default:
                    throw new Error(`Invalid RuleEvaluationResult returned from rule: ${entity} (viewer = ${viewerContext}, action = ${EntityAuthorizationAction[action]}, ruleIndex = ${i})`);
            }
        }
        throw new EntityNotAuthorizedError_1.default(entity, viewerContext, action, -1);
    }
}
exports.default = EntityPrivacyPolicy;
//# sourceMappingURL=EntityPrivacyPolicy.js.map