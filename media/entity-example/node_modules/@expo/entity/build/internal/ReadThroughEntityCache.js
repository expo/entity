"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheStatus = void 0;
const invariant_1 = __importDefault(require("invariant"));
const maps_1 = require("../utils/collections/maps");
var CacheStatus;
(function (CacheStatus) {
    CacheStatus[CacheStatus["HIT"] = 0] = "HIT";
    CacheStatus[CacheStatus["MISS"] = 1] = "MISS";
    CacheStatus[CacheStatus["NEGATIVE"] = 2] = "NEGATIVE";
})(CacheStatus || (exports.CacheStatus = CacheStatus = {}));
/**
 * A read-through entity cache is responsible for coordinating EntityDatabaseAdapter and
 * EntityCacheAdapter within the EntityDataManager.
 */
class ReadThroughEntityCache {
    entityConfiguration;
    entityCacheAdapter;
    constructor(entityConfiguration, entityCacheAdapter) {
        this.entityConfiguration = entityConfiguration;
        this.entityCacheAdapter = entityCacheAdapter;
    }
    isFieldCacheable(fieldName) {
        return this.entityConfiguration.cacheableKeys.has(fieldName);
    }
    /**
     * Read-through cache function. Steps:
     *
     * 1. Check for cached (fieldName, fieldValue) objects
     * 2. Query the fetcher for fieldValues not in the cache
     * 3. Cache the results from the fetcher
     * 4. Negatively cache anything missing from the fetcher
     * 5. Return the full set of data for the query.
     *
     * If cache is not applicable for fieldName, return results from fetcher.
     *
     * @param fieldName - object field being queried
     * @param fieldValues - fieldName field values being queried
     * @param fetcher - closure used to provide underlying data source objects for fieldName and fetcherFieldValues
     * @returns map from fieldValue to objects that match the query for that fieldValue
     */
    async readManyThroughAsync(fieldName, fieldValues, fetcher) {
        // return normal fetch when cache by fieldName not supported
        if (!this.isFieldCacheable(fieldName)) {
            return await fetcher(fieldValues);
        }
        const cacheLoadResults = await this.entityCacheAdapter.loadManyAsync(fieldName, fieldValues);
        (0, invariant_1.default)(cacheLoadResults.size === fieldValues.length, `${this.constructor.name} loadMany should return a result for each fieldValue`);
        const fieldValuesToFetchFromDB = Array.from((0, maps_1.filterMap)(cacheLoadResults, (cacheLoadResult) => cacheLoadResult.status === CacheStatus.MISS).keys());
        // put transformed cache hits in result map
        const results = new Map();
        cacheLoadResults.forEach((cacheLoadResult, fieldValue) => {
            if (cacheLoadResult.status === CacheStatus.HIT) {
                results.set(fieldValue, [cacheLoadResult.item]);
            }
        });
        // fetch any misses from DB, add DB objects to results, cache DB results, inform cache of any missing DB results
        if (fieldValuesToFetchFromDB.length > 0) {
            const dbFetchResults = await fetcher(fieldValuesToFetchFromDB);
            const fieldValueDBMisses = fieldValuesToFetchFromDB.filter((fv) => {
                const objectsFromFulfillerForFv = dbFetchResults.get(fv);
                return !objectsFromFulfillerForFv || objectsFromFulfillerForFv.length === 0;
            });
            const objectsToCache = new Map();
            for (const [fieldValue, objects] of dbFetchResults.entries()) {
                if (objects.length > 1) {
                    // multiple objects received for what was supposed to be a unique query, don't add to return map nor cache
                    // TODO(wschurman): emit or throw here since console may not be available
                    // eslint-disable-next-line no-console
                    console.warn(`unique key ${String(fieldName)} in ${this.entityConfiguration.tableName} returned multiple rows for ${fieldValue}`);
                    continue;
                }
                const uniqueObject = objects[0];
                if (uniqueObject) {
                    objectsToCache.set(fieldValue, uniqueObject);
                    results.set(fieldValue, [uniqueObject]);
                }
            }
            await Promise.all([
                this.entityCacheAdapter.cacheManyAsync(fieldName, objectsToCache),
                this.entityCacheAdapter.cacheDBMissesAsync(fieldName, fieldValueDBMisses),
            ]);
        }
        return results;
    }
    /**
     * Invalidate the cache for objects cached by (fieldName, fieldValue).
     *
     * @param fieldName - object field being queried
     * @param fieldValues - fieldName field values to be invalidated
     */
    async invalidateManyAsync(fieldName, fieldValues) {
        // no-op when cache by fieldName not supported
        if (!this.isFieldCacheable(fieldName)) {
            return;
        }
        await this.entityCacheAdapter.invalidateManyAsync(fieldName, fieldValues);
    }
}
exports.default = ReadThroughEntityCache;
//# sourceMappingURL=ReadThroughEntityCache.js.map