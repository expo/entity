import ReadThroughEntityCache from './ReadThroughEntityCache';
import EntityDatabaseAdapter, { FieldEqualityCondition, QuerySelectionModifiers, QuerySelectionModifiersWithOrderByRaw } from '../EntityDatabaseAdapter';
import { EntityQueryContext } from '../EntityQueryContext';
import EntityQueryContextProvider from '../EntityQueryContextProvider';
import IEntityMetricsAdapter from '../metrics/IEntityMetricsAdapter';
/**
 * A data manager is responsible for orchestrating multiple sources of entity
 * data including local caches, EntityCacheAdapter, and EntityDatabaseAdapter.
 *
 * It is also responsible for invalidating all sources of data when mutated using EntityMutator.
 */
export default class EntityDataManager<TFields extends Record<string, any>> {
    private readonly databaseAdapter;
    private readonly entityCache;
    private readonly queryContextProvider;
    private readonly metricsAdapter;
    private readonly entityClassName;
    private readonly fieldDataLoaders;
    constructor(databaseAdapter: EntityDatabaseAdapter<TFields>, entityCache: ReadThroughEntityCache<TFields>, queryContextProvider: EntityQueryContextProvider, metricsAdapter: IEntityMetricsAdapter, entityClassName: string);
    private getFieldDataLoaderForFieldName;
    private loadManyForDataLoaderByFieldEqualingAsync;
    /**
     * Load many objects where fieldName is one of fieldValues.
     *
     * @param queryContext - query context in which to perform the load
     * @param fieldName - object field being queried
     * @param fieldValues - fieldName field values being queried
     * @returns map from fieldValue to objects that match the query for that fieldValue
     */
    loadManyByFieldEqualingAsync<N extends keyof TFields>(queryContext: EntityQueryContext, fieldName: N, fieldValues: readonly NonNullable<TFields[N]>[]): Promise<ReadonlyMap<NonNullable<TFields[N]>, readonly Readonly<TFields>[]>>;
    private loadManyByFieldEqualingInternalAsync;
    /**
     * Loads many objects matching the conjunction of where clauses constructed from
     * specified field equality operands.
     *
     * @param queryContext - query context in which to perform the load
     * @param fieldEqualityOperands - list of field equality where clause operand specifications
     * @param querySelectionModifiers - limit, offset, and orderBy for the query
     * @returns array of objects matching the query
     */
    loadManyByFieldEqualityConjunctionAsync<N extends keyof TFields>(queryContext: EntityQueryContext, fieldEqualityOperands: FieldEqualityCondition<TFields, N>[], querySelectionModifiers: QuerySelectionModifiers<TFields>): Promise<readonly Readonly<TFields>[]>;
    /**
     * Loads many objects matching the raw WHERE clause.
     *
     * @param queryContext - query context in which to perform the load
     * @param rawWhereClause - parameterized SQL WHERE clause with positional binding placeholders or named binding placeholders
     * @param bindings - array of positional bindings or object of named bindings
     * @param querySelectionModifiers - limit, offset, orderBy, and orderByRaw for the query
     * @returns array of objects matching the query
     */
    loadManyByRawWhereClauseAsync(queryContext: EntityQueryContext, rawWhereClause: string, bindings: any[] | object, querySelectionModifiers: QuerySelectionModifiersWithOrderByRaw<TFields>): Promise<readonly Readonly<TFields>[]>;
    private invalidateManyByFieldEqualingAsync;
    /**
     * Invalidate all caches, in-memory or otherwise, for an object.
     *
     * @param objectFields - object to invalidate from all applicable caches
     */
    invalidateObjectFieldsAsync(objectFields: Readonly<TFields>): Promise<void>;
}
