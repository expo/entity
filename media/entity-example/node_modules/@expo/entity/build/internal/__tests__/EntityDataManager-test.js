"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_mockito_1 = require("ts-mockito");
const IEntityMetricsAdapter_1 = require("../../metrics/IEntityMetricsAdapter");
const NoOpEntityMetricsAdapter_1 = __importDefault(require("../../metrics/NoOpEntityMetricsAdapter"));
const TestEntity_1 = __importStar(require("../../testfixtures/TestEntity"));
const StubCacheAdapter_1 = require("../../utils/testing/StubCacheAdapter");
const StubDatabaseAdapter_1 = __importDefault(require("../../utils/testing/StubDatabaseAdapter"));
const StubQueryContextProvider_1 = __importDefault(require("../../utils/testing/StubQueryContextProvider"));
const EntityDataManager_1 = __importDefault(require("../EntityDataManager"));
const ReadThroughEntityCache_1 = __importDefault(require("../ReadThroughEntityCache"));
const getObjects = () => new Map([
    [
        TestEntity_1.testEntityConfiguration.tableName,
        [
            {
                customIdField: '1',
                testIndexedField: 'unique1',
                stringField: 'hello',
                intField: 1,
                dateField: new Date(),
                nullableField: null,
            },
            {
                customIdField: '2',
                testIndexedField: 'unique2',
                stringField: 'hello',
                intField: 1,
                dateField: new Date(),
                nullableField: null,
            },
            {
                customIdField: '3',
                testIndexedField: 'unique3',
                stringField: 'world',
                intField: 1,
                dateField: new Date(),
                nullableField: null,
            },
        ],
    ],
]);
describe(EntityDataManager_1.default, () => {
    it('loads from db with a no-cache adapter', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        const entityDatas = await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'customIdField', ['2']);
        expect(entityDatas.get('2')).toHaveLength(1);
        expect(dbSpy).toHaveBeenCalled();
        expect(cacheSpy).toHaveBeenCalled();
        dbSpy.mockClear();
        cacheSpy.mockClear();
        const entityDatas2 = await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', ['unique2', 'unique3']);
        expect(entityDatas2.get('unique2')).toHaveLength(1);
        expect(entityDatas2.get('unique3')).toHaveLength(1);
        expect(dbSpy).toHaveBeenCalled();
        expect(cacheSpy).toHaveBeenCalled();
        dbSpy.mockClear();
        cacheSpy.mockClear();
    });
    it('loads from a caching adaptor', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        const entityDatas = await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'customIdField', ['1']);
        expect(entityDatas.get('1')).toHaveLength(1);
        expect(dbSpy).toHaveBeenCalled();
        expect(cacheSpy).toHaveBeenCalled();
        dbSpy.mockClear();
        cacheSpy.mockClear();
        const entityDatas2 = await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', ['unique2', 'unique3']);
        expect(entityDatas2.get('unique2')).toHaveLength(1);
        expect(entityDatas2.get('unique3')).toHaveLength(1);
        expect(dbSpy).toHaveBeenCalled();
        expect(cacheSpy).toHaveBeenCalled();
        dbSpy.mockClear();
        cacheSpy.mockClear();
    });
    it('loads from a caching adapter with a cache hit', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        // use second data manager to ensure that cache is hit instead of data loader
        const entityDataManager2 = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', [
            'unique2',
        ]);
        await entityDataManager2.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', [
            'unique2',
        ]);
        expect(dbSpy).toHaveBeenCalledTimes(1);
        expect(cacheSpy).toHaveBeenCalledTimes(2);
        dbSpy.mockReset();
        cacheSpy.mockReset();
    });
    it('loads from data loader for same query', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', [
            'unique2',
        ]);
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', [
            'unique2',
        ]);
        expect(dbSpy).toHaveBeenCalledTimes(1);
        expect(cacheSpy).toHaveBeenCalledTimes(1);
        dbSpy.mockReset();
        cacheSpy.mockReset();
    });
    it('loads and in-memory caches (dataloader) non-unique, non-cacheable loads', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        const entityData = await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'stringField', ['hello', 'world']);
        const entityData2 = await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'stringField', ['hello', 'world']);
        expect(dbSpy).toHaveBeenCalledTimes(1);
        expect(cacheSpy).toHaveBeenCalledTimes(1);
        expect(entityData).toMatchObject(entityData2);
        expect(entityData.get('hello')).toHaveLength(2);
        expect(entityData.get('world')).toHaveLength(1);
        dbSpy.mockReset();
        cacheSpy.mockReset();
    });
    it('invalidates objects', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const objectInQuestion = objects.get(TestEntity_1.testEntityConfiguration.tableName)[1];
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', [
            objectInQuestion['testIndexedField'],
        ]);
        await entityDataManager.invalidateObjectFieldsAsync(objectInQuestion);
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', [
            objectInQuestion['testIndexedField'],
        ]);
        expect(dbSpy).toHaveBeenCalledTimes(2);
        expect(cacheSpy).toHaveBeenCalledTimes(2);
        dbSpy.mockReset();
        cacheSpy.mockReset();
    });
    it('invalidates all fields for an object', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const objectInQuestion = objects.get(TestEntity_1.testEntityConfiguration.tableName)[1];
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'testIndexedField', [
            objectInQuestion['testIndexedField'],
        ]);
        await entityDataManager.invalidateObjectFieldsAsync(objectInQuestion);
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'customIdField', [
            objectInQuestion['customIdField'],
        ]);
        expect(dbSpy).toHaveBeenCalledTimes(2);
        expect(cacheSpy).toHaveBeenCalledTimes(2);
        dbSpy.mockReset();
        cacheSpy.mockReset();
    });
    it('loads only from DB when in transaction', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyWhereAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        const entityDatas = await StubQueryContextProvider_1.default.runInTransactionAsync(async (queryContext) => {
            return await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'customIdField', [
                '1',
            ]);
        }, {});
        expect(entityDatas.get('1')).toHaveLength(1);
        expect(dbSpy).toHaveBeenCalled();
        expect(cacheSpy).not.toHaveBeenCalled();
        dbSpy.mockReset();
        cacheSpy.mockReset();
    });
    it('loads by field equality conjunction and does not cache', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const dbSpy = jest.spyOn(databaseAdapter, 'fetchManyByFieldEqualityConjunctionAsync');
        const cacheSpy = jest.spyOn(entityCache, 'readManyThroughAsync');
        const entityDatas = await entityDataManager.loadManyByFieldEqualityConjunctionAsync(queryContext, [
            {
                fieldName: 'stringField',
                fieldValue: 'hello',
            },
            {
                fieldName: 'intField',
                fieldValue: 1,
            },
        ], {});
        expect(entityDatas).toHaveLength(2);
        expect(dbSpy).toHaveBeenCalled();
        expect(cacheSpy).not.toHaveBeenCalled();
        dbSpy.mockReset();
        cacheSpy.mockReset();
    });
    it('handles DB errors as expected', async () => {
        const databaseAdapterMock = (0, ts_mockito_1.mock)();
        (0, ts_mockito_1.when)(databaseAdapterMock.fetchManyWhereAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenReject(new Error('DB query failed'));
        const databaseAdapter = (0, ts_mockito_1.instance)(databaseAdapterMock);
        const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        await expect(entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'customIdField', ['2'])).rejects.toThrow();
    });
    it('records metrics appropriately', async () => {
        const metricsAdapterMock = (0, ts_mockito_1.mock)();
        const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.InMemoryFullCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, metricsAdapter, TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        await entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'customIdField', ['1']);
        (0, ts_mockito_1.verify)(metricsAdapterMock.logDataManagerLoadEvent((0, ts_mockito_1.objectContaining)({
            type: IEntityMetricsAdapter_1.EntityMetricsLoadType.LOAD_MANY,
            entityClassName: TestEntity_1.default.name,
            count: 1,
        }))).once();
        await entityDataManager.loadManyByFieldEqualityConjunctionAsync(queryContext, [
            {
                fieldName: 'customIdField',
                fieldValue: '1',
            },
        ], {});
        (0, ts_mockito_1.verify)(metricsAdapterMock.logDataManagerLoadEvent((0, ts_mockito_1.objectContaining)({
            type: IEntityMetricsAdapter_1.EntityMetricsLoadType.LOAD_MANY_EQUALITY_CONJUNCTION,
            entityClassName: TestEntity_1.default.name,
            count: 1,
        }))).once();
        (0, ts_mockito_1.verify)(metricsAdapterMock.incrementDataManagerLoadCount((0, ts_mockito_1.deepEqual)({
            type: IEntityMetricsAdapter_1.IncrementLoadCountEventType.DATALOADER,
            fieldValueCount: 1,
            entityClassName: TestEntity_1.default.name,
        }))).once();
        (0, ts_mockito_1.verify)(metricsAdapterMock.incrementDataManagerLoadCount((0, ts_mockito_1.deepEqual)({
            type: IEntityMetricsAdapter_1.IncrementLoadCountEventType.CACHE,
            fieldValueCount: 1,
            entityClassName: TestEntity_1.default.name,
        }))).once();
        (0, ts_mockito_1.verify)(metricsAdapterMock.incrementDataManagerLoadCount((0, ts_mockito_1.deepEqual)({
            type: IEntityMetricsAdapter_1.IncrementLoadCountEventType.DATABASE,
            fieldValueCount: 1,
            entityClassName: TestEntity_1.default.name,
        }))).once();
        (0, ts_mockito_1.resetCalls)(metricsAdapterMock);
        const databaseAdapterSpy = (0, ts_mockito_1.spy)(databaseAdapter);
        (0, ts_mockito_1.when)(databaseAdapterSpy.fetchManyByRawWhereClauseAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anyString)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([]);
        await entityDataManager.loadManyByRawWhereClauseAsync(queryContext, '', [], {});
        (0, ts_mockito_1.verify)(metricsAdapterMock.logDataManagerLoadEvent((0, ts_mockito_1.objectContaining)({
            type: IEntityMetricsAdapter_1.EntityMetricsLoadType.LOAD_MANY_RAW,
            entityClassName: TestEntity_1.default.name,
            count: 0,
        }))).once();
        (0, ts_mockito_1.verify)(metricsAdapterMock.incrementDataManagerLoadCount((0, ts_mockito_1.anything)())).never();
    });
    it('throws when a load-by value is null or undefined', async () => {
        const objects = getObjects();
        const dataStore = StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, objects);
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, dataStore);
        const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const entityDataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, new NoOpEntityMetricsAdapter_1.default(), TestEntity_1.default.name);
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        await expect(entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'nullableField', [null])).rejects.toThrowError('Invalid load: TestEntity (nullableField = null)');
        await expect(entityDataManager.loadManyByFieldEqualingAsync(queryContext, 'nullableField', [
            undefined,
        ])).rejects.toThrowError('Invalid load: TestEntity (nullableField = undefined)');
    });
});
//# sourceMappingURL=EntityDataManager-test.js.map