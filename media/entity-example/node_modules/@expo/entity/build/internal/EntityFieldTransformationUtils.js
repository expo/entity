"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformFieldsToCacheObject = exports.transformCacheObjectToFields = exports.transformFieldsToDatabaseObject = exports.transformDatabaseObjectToFields = exports.getDatabaseFieldForEntityField = void 0;
const invariant_1 = __importDefault(require("invariant"));
const nullthrows_1 = __importDefault(require("nullthrows"));
const getDatabaseFieldForEntityField = (entityConfiguration, entityField) => {
    const databaseField = entityConfiguration.entityToDBFieldsKeyMapping.get(entityField);
    (0, invariant_1.default)(databaseField, `database field mapping missing for ${String(entityField)}`);
    return databaseField;
};
exports.getDatabaseFieldForEntityField = getDatabaseFieldForEntityField;
const transformDatabaseObjectToFields = (entityConfiguration, fieldTransformerMap, databaseObject) => {
    const fields = {};
    for (const k in databaseObject) {
        const val = databaseObject[k];
        const fieldsKey = entityConfiguration.dbToEntityFieldsKeyMapping.get(k);
        if (fieldsKey) {
            fields[fieldsKey] = maybeTransformDatabaseValueToFieldValue(entityConfiguration, fieldTransformerMap, fieldsKey, val);
        }
    }
    return fields;
};
exports.transformDatabaseObjectToFields = transformDatabaseObjectToFields;
const transformFieldsToDatabaseObject = (entityConfiguration, fieldTransformerMap, fields) => {
    const databaseObject = {};
    for (const k in fields) {
        const val = fields[k];
        const databaseKey = entityConfiguration.entityToDBFieldsKeyMapping.get(k);
        (0, invariant_1.default)(databaseKey, `must be database key for field: ${k}`);
        databaseObject[databaseKey] = maybeTransformFieldValueToDatabaseValue(entityConfiguration, fieldTransformerMap, k, val);
    }
    return databaseObject;
};
exports.transformFieldsToDatabaseObject = transformFieldsToDatabaseObject;
const transformCacheObjectToFields = (entityConfiguration, fieldTransformerMap, cacheObject) => {
    const fields = {};
    for (const fieldsKey in cacheObject) {
        const val = cacheObject[fieldsKey];
        fields[fieldsKey] = maybeTransformCacheValueToFieldValue(entityConfiguration, fieldTransformerMap, fieldsKey, val);
    }
    return fields;
};
exports.transformCacheObjectToFields = transformCacheObjectToFields;
const transformFieldsToCacheObject = (entityConfiguration, fieldTransformerMap, fields) => {
    const cacheObject = {};
    for (const fieldsKey in fields) {
        const val = fields[fieldsKey];
        cacheObject[fieldsKey] = maybeTransformFieldValueToCacheValue(entityConfiguration, fieldTransformerMap, fieldsKey, val);
    }
    return cacheObject;
};
exports.transformFieldsToCacheObject = transformFieldsToCacheObject;
const maybeTransformDatabaseValueToFieldValue = (entityConfiguration, fieldTransformerMap, fieldName, value) => {
    // this will always be non-null due to the way the dbToEntityFieldsKeyMapping is computed and this
    // function is called conditionally
    const fieldDefinition = (0, nullthrows_1.default)(entityConfiguration.schema.get(fieldName));
    const transformer = fieldTransformerMap.get(fieldDefinition.constructor.name);
    const readTransformer = transformer?.read;
    return readTransformer ? readTransformer(value) : value;
};
const maybeTransformFieldValueToDatabaseValue = (entityConfiguration, fieldTransformerMap, fieldName, value) => {
    const fieldDefinition = (0, nullthrows_1.default)(entityConfiguration.schema.get(fieldName));
    const transformer = fieldTransformerMap.get(fieldDefinition.constructor.name);
    const writeTransformer = transformer?.write;
    return writeTransformer ? writeTransformer(value) : value;
};
const maybeTransformCacheValueToFieldValue = (entityConfiguration, fieldTransformerMap, fieldName, value) => {
    const fieldDefinition = entityConfiguration.schema.get(fieldName);
    if (!fieldDefinition) {
        return value;
    }
    const transformer = fieldTransformerMap.get(fieldDefinition.constructor.name);
    const readTransformer = transformer?.read;
    return readTransformer ? readTransformer(value) : value;
};
const maybeTransformFieldValueToCacheValue = (entityConfiguration, fieldTransformerMap, fieldName, value) => {
    const fieldDefinition = entityConfiguration.schema.get(fieldName);
    if (!fieldDefinition) {
        return value;
    }
    const transformer = fieldTransformerMap.get(fieldDefinition.constructor.name);
    const writeTransformer = transformer?.write;
    return writeTransformer ? writeTransformer(value) : value;
};
//# sourceMappingURL=EntityFieldTransformationUtils.js.map