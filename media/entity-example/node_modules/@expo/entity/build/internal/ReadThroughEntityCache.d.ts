import EntityConfiguration from '../EntityConfiguration';
import IEntityCacheAdapter from '../IEntityCacheAdapter';
export declare enum CacheStatus {
    HIT = 0,
    MISS = 1,
    NEGATIVE = 2
}
export type CacheLoadResult<TFields> = {
    status: CacheStatus.HIT;
    item: Readonly<TFields>;
} | {
    status: CacheStatus.MISS;
} | {
    status: CacheStatus.NEGATIVE;
};
/**
 * A read-through entity cache is responsible for coordinating EntityDatabaseAdapter and
 * EntityCacheAdapter within the EntityDataManager.
 */
export default class ReadThroughEntityCache<TFields extends Record<string, any>> {
    private readonly entityConfiguration;
    private readonly entityCacheAdapter;
    constructor(entityConfiguration: EntityConfiguration<TFields>, entityCacheAdapter: IEntityCacheAdapter<TFields>);
    private isFieldCacheable;
    /**
     * Read-through cache function. Steps:
     *
     * 1. Check for cached (fieldName, fieldValue) objects
     * 2. Query the fetcher for fieldValues not in the cache
     * 3. Cache the results from the fetcher
     * 4. Negatively cache anything missing from the fetcher
     * 5. Return the full set of data for the query.
     *
     * If cache is not applicable for fieldName, return results from fetcher.
     *
     * @param fieldName - object field being queried
     * @param fieldValues - fieldName field values being queried
     * @param fetcher - closure used to provide underlying data source objects for fieldName and fetcherFieldValues
     * @returns map from fieldValue to objects that match the query for that fieldValue
     */
    readManyThroughAsync<N extends keyof TFields>(fieldName: N, fieldValues: readonly NonNullable<TFields[N]>[], fetcher: (fetcherFieldValues: readonly NonNullable<TFields[N]>[]) => Promise<ReadonlyMap<NonNullable<TFields[N]>, readonly Readonly<TFields>[]>>): Promise<ReadonlyMap<NonNullable<TFields[N]>, readonly Readonly<TFields>[]>>;
    /**
     * Invalidate the cache for objects cached by (fieldName, fieldValue).
     *
     * @param fieldName - object field being queried
     * @param fieldValues - fieldName field values to be invalidated
     */
    invalidateManyAsync<N extends keyof TFields>(fieldName: N, fieldValues: readonly NonNullable<TFields[N]>[]): Promise<void>;
}
