import { Result } from '@expo/results';
import Entity, { IEntityClass } from './Entity';
import EntityCompanionProvider from './EntityCompanionProvider';
import EntityConfiguration from './EntityConfiguration';
import EntityDatabaseAdapter from './EntityDatabaseAdapter';
import EntityLoaderFactory from './EntityLoaderFactory';
import { EntityValidatorMutationInfo, EntityTriggerMutationInfo } from './EntityMutationInfo';
import EntityMutationTriggerConfiguration, { EntityMutationTrigger, EntityNonTransactionalMutationTrigger } from './EntityMutationTriggerConfiguration';
import EntityMutationValidator from './EntityMutationValidator';
import EntityPrivacyPolicy from './EntityPrivacyPolicy';
import { EntityQueryContext, EntityTransactionalQueryContext } from './EntityQueryContext';
import ViewerContext from './ViewerContext';
import IEntityMetricsAdapter from './metrics/IEntityMetricsAdapter';
declare abstract class BaseMutator<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields> {
    protected readonly companionProvider: EntityCompanionProvider;
    protected readonly viewerContext: TViewerContext;
    protected readonly queryContext: EntityQueryContext;
    protected readonly entityConfiguration: EntityConfiguration<TFields>;
    protected readonly entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>;
    protected readonly privacyPolicy: TPrivacyPolicy;
    protected readonly mutationValidators: EntityMutationValidator<TFields, TID, TViewerContext, TEntity, TSelectedFields>[];
    protected readonly mutationTriggers: EntityMutationTriggerConfiguration<TFields, TID, TViewerContext, TEntity, TSelectedFields>;
    protected readonly entityLoaderFactory: EntityLoaderFactory<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>;
    protected readonly databaseAdapter: EntityDatabaseAdapter<TFields>;
    protected readonly metricsAdapter: IEntityMetricsAdapter;
    constructor(companionProvider: EntityCompanionProvider, viewerContext: TViewerContext, queryContext: EntityQueryContext, entityConfiguration: EntityConfiguration<TFields>, entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, privacyPolicy: TPrivacyPolicy, mutationValidators: EntityMutationValidator<TFields, TID, TViewerContext, TEntity, TSelectedFields>[], mutationTriggers: EntityMutationTriggerConfiguration<TFields, TID, TViewerContext, TEntity, TSelectedFields>, entityLoaderFactory: EntityLoaderFactory<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, databaseAdapter: EntityDatabaseAdapter<TFields>, metricsAdapter: IEntityMetricsAdapter);
    protected validateFields(fields: Partial<TFields>): void;
    protected executeMutationValidatorsAsync(validators: EntityMutationValidator<TFields, TID, TViewerContext, TEntity, TSelectedFields>[], queryContext: EntityTransactionalQueryContext, entity: TEntity, mutationInfo: EntityValidatorMutationInfo<TFields, TID, TViewerContext, TEntity, TSelectedFields>): Promise<void>;
    protected executeMutationTriggersAsync(triggers: EntityMutationTrigger<TFields, TID, TViewerContext, TEntity, TSelectedFields>[] | undefined, queryContext: EntityTransactionalQueryContext, entity: TEntity, mutationInfo: EntityTriggerMutationInfo<TFields, TID, TViewerContext, TEntity, TSelectedFields>): Promise<void>;
    protected executeNonTransactionalMutationTriggersAsync(triggers: EntityNonTransactionalMutationTrigger<TFields, TID, TViewerContext, TEntity, TSelectedFields>[] | undefined, entity: TEntity, mutationInfo: EntityTriggerMutationInfo<TFields, TID, TViewerContext, TEntity, TSelectedFields>): Promise<void>;
}
/**
 * Mutator for creating a new entity.
 */
export declare class CreateMutator<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields> extends BaseMutator<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields> {
    private readonly fieldsForEntity;
    /**
     * Set the value for entity field.
     * @param fieldName - entity field being updated
     * @param value - value for entity field
     */
    setField<K extends keyof Pick<TFields, TSelectedFields>>(fieldName: K, value: TFields[K]): this;
    /**
     * Commit the new entity after authorizing against creation privacy rules. Invalidates all caches for
     * queries that would return new entity.
     * @returns authorized, cached, newly-created entity result, where result error can be UnauthorizedError
     */
    createAsync(): Promise<Result<TEntity>>;
    /**
     * Convenience method that returns the new entity or throws upon create failure.
     */
    enforceCreateAsync(): Promise<TEntity>;
    private createInTransactionAsync;
    private createInternalAsync;
}
/**
 * Mutator for updating an existing entity.
 */
export declare class UpdateMutator<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields> extends BaseMutator<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields> {
    private readonly originalEntity;
    private readonly fieldsForEntity;
    private readonly updatedFields;
    constructor(companionProvider: EntityCompanionProvider, viewerContext: TViewerContext, queryContext: EntityQueryContext, entityConfiguration: EntityConfiguration<TFields>, entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, privacyPolicy: TPrivacyPolicy, mutationValidators: EntityMutationValidator<TFields, TID, TViewerContext, TEntity, TSelectedFields>[], mutationTriggers: EntityMutationTriggerConfiguration<TFields, TID, TViewerContext, TEntity, TSelectedFields>, entityLoaderFactory: EntityLoaderFactory<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, databaseAdapter: EntityDatabaseAdapter<TFields>, metricsAdapter: IEntityMetricsAdapter, originalEntity: TEntity);
    /**
     * Set the value for entity field.
     * @param fieldName - entity field being updated
     * @param value - value for entity field
     */
    setField<K extends keyof Pick<TFields, TSelectedFields>>(fieldName: K, value: TFields[K]): this;
    /**
     * Commit the changes to the entity after authorizing against update privacy rules.
     * Invalidates all caches for pre-update entity.
     * @returns authorized updated entity result, where result error can be UnauthorizedError
     */
    updateAsync(): Promise<Result<TEntity>>;
    /**
     * Convenience method that returns the updated entity or throws upon update failure.
     */
    enforceUpdateAsync(): Promise<TEntity>;
    private updateInTransactionAsync;
    private updateInternalAsync;
    private ensureStableIDField;
}
/**
 * Mutator for deleting an existing entity.
 */
export declare class DeleteMutator<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields> extends BaseMutator<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields> {
    private readonly entity;
    constructor(companionProvider: EntityCompanionProvider, viewerContext: TViewerContext, queryContext: EntityQueryContext, entityConfiguration: EntityConfiguration<TFields>, entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, privacyPolicy: TPrivacyPolicy, mutationValidators: EntityMutationValidator<TFields, TID, TViewerContext, TEntity, TSelectedFields>[], mutationTriggers: EntityMutationTriggerConfiguration<TFields, TID, TViewerContext, TEntity, TSelectedFields>, entityLoaderFactory: EntityLoaderFactory<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, databaseAdapter: EntityDatabaseAdapter<TFields>, metricsAdapter: IEntityMetricsAdapter, entity: TEntity);
    /**
     * Delete the entity after authorizing against delete privacy rules. The entity is invalidated in all caches.
     * @returns void result, where result error can be UnauthorizedError
     */
    deleteAsync(): Promise<Result<void>>;
    /**
     * Convenience method that throws upon delete failure.
     */
    enforceDeleteAsync(): Promise<void>;
    private deleteInTransactionAsync;
    private deleteInternalAsync;
    /**
     * Finds all entities referencing the specified entity and either deletes them, nullifies
     * their references to the specified entity, or invalidates the cache depending on the
     * OnDeleteBehavior of the field referencing the specified entity.
     *
     * @remarks
     * This works by doing reverse fan-out queries:
     * 1. Load all entity configurations of entity types that reference this type of entity
     * 2. For each entity configuration, find all fields that contain edges to this type of entity
     * 3. For each edge field, load all entities with an edge from target entity to this entity via that field
     * 4. Perform desired OnDeleteBehavior for entities
     *
     * @param entity - entity to find all references to
     */
    private processEntityDeletionForInboundEdgesAsync;
}
export {};
