"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderByOrdering = void 0;
exports.isSingleValueFieldEqualityCondition = isSingleValueFieldEqualityCondition;
const EntityFieldTransformationUtils_1 = require("./internal/EntityFieldTransformationUtils");
function isSingleValueFieldEqualityCondition(condition) {
    return condition.fieldValue !== undefined;
}
var OrderByOrdering;
(function (OrderByOrdering) {
    OrderByOrdering["ASCENDING"] = "asc";
    OrderByOrdering["DESCENDING"] = "desc";
})(OrderByOrdering || (exports.OrderByOrdering = OrderByOrdering = {}));
/**
 * A database adapter is an interface by which entity objects can be
 * fetched, inserted, updated, and deleted from a database. This base class
 * handles all entity field transformation. Subclasses are responsible for
 * implementing database-specific logic for a type of database.
 */
class EntityDatabaseAdapter {
    entityConfiguration;
    fieldTransformerMap;
    constructor(entityConfiguration) {
        this.entityConfiguration = entityConfiguration;
        this.fieldTransformerMap = this.getFieldTransformerMap();
    }
    /**
     * Fetch many objects where fieldName is one of fieldValues.
     *
     * @param queryContext - query context with which to perform the fetch
     * @param fieldName - object field being queried
     * @param fieldValues - fieldName field values being queried
     * @returns map from fieldValue to objects that match the query for that fieldValue
     */
    async fetchManyWhereAsync(queryContext, fieldName, fieldValues) {
        const fieldColumn = (0, EntityFieldTransformationUtils_1.getDatabaseFieldForEntityField)(this.entityConfiguration, fieldName);
        const results = await this.fetchManyWhereInternalAsync(queryContext.getQueryInterface(), this.entityConfiguration.tableName, fieldColumn, fieldValues);
        const objects = results.map((result) => (0, EntityFieldTransformationUtils_1.transformDatabaseObjectToFields)(this.entityConfiguration, this.fieldTransformerMap, result));
        const objectMap = new Map();
        for (const fieldValue of fieldValues) {
            objectMap.set(fieldValue, []);
        }
        objects.forEach((object) => {
            const objectFieldValue = object[fieldName];
            objectMap.get(objectFieldValue).push(object);
        });
        return objectMap;
    }
    /**
     * Fetch many objects matching the conjunction of where clauses constructed from
     * specified field equality operands.
     *
     * @param queryContext - query context with which to perform the fetch
     * @param fieldEqualityOperands - list of field equality where clause operand specifications
     * @param querySelectionModifiers - limit, offset, orderBy, and orderByRaw for the query
     * @returns array of objects matching the query
     */
    async fetchManyByFieldEqualityConjunctionAsync(queryContext, fieldEqualityOperands, querySelectionModifiers) {
        const tableFieldSingleValueOperands = [];
        const tableFieldMultipleValueOperands = [];
        for (const operand of fieldEqualityOperands) {
            if (isSingleValueFieldEqualityCondition(operand)) {
                tableFieldSingleValueOperands.push({
                    tableField: (0, EntityFieldTransformationUtils_1.getDatabaseFieldForEntityField)(this.entityConfiguration, operand.fieldName),
                    tableValue: operand.fieldValue,
                });
            }
            else {
                tableFieldMultipleValueOperands.push({
                    tableField: (0, EntityFieldTransformationUtils_1.getDatabaseFieldForEntityField)(this.entityConfiguration, operand.fieldName),
                    tableValues: operand.fieldValues,
                });
            }
        }
        const results = await this.fetchManyByFieldEqualityConjunctionInternalAsync(queryContext.getQueryInterface(), this.entityConfiguration.tableName, tableFieldSingleValueOperands, tableFieldMultipleValueOperands, this.convertToTableQueryModifiers(querySelectionModifiers));
        return results.map((result) => (0, EntityFieldTransformationUtils_1.transformDatabaseObjectToFields)(this.entityConfiguration, this.fieldTransformerMap, result));
    }
    /**
     * Fetch many objects matching the raw WHERE clause.
     *
     * @param queryContext - query context with which to perform the fetch
     * @param rawWhereClause - parameterized SQL WHERE clause with positional binding placeholders or named binding placeholders
     * @param bindings - array of positional bindings or object of named bindings
     * @param querySelectionModifiers - limit, offset, and orderBy for the query
     * @returns array of objects matching the query
     */
    async fetchManyByRawWhereClauseAsync(queryContext, rawWhereClause, bindings, querySelectionModifiers) {
        const results = await this.fetchManyByRawWhereClauseInternalAsync(queryContext.getQueryInterface(), this.entityConfiguration.tableName, rawWhereClause, bindings, this.convertToTableQueryModifiersWithOrderByRaw(querySelectionModifiers));
        return results.map((result) => (0, EntityFieldTransformationUtils_1.transformDatabaseObjectToFields)(this.entityConfiguration, this.fieldTransformerMap, result));
    }
    /**
     * Insert an object.
     *
     * @param queryContext - query context with which to perform the insert
     * @param object - the object to insert
     * @returns the inserted object
     */
    async insertAsync(queryContext, object) {
        const dbObject = (0, EntityFieldTransformationUtils_1.transformFieldsToDatabaseObject)(this.entityConfiguration, this.fieldTransformerMap, object);
        const results = await this.insertInternalAsync(queryContext.getQueryInterface(), this.entityConfiguration.tableName, dbObject);
        if (results.length > 1) {
            throw new Error(`Excessive results from database adapter insert: ${this.entityConfiguration.tableName}`);
        }
        else if (results.length === 0) {
            throw new Error(`Empty results from database adapter insert: ${this.entityConfiguration.tableName}`);
        }
        return (0, EntityFieldTransformationUtils_1.transformDatabaseObjectToFields)(this.entityConfiguration, this.fieldTransformerMap, results[0]);
    }
    /**
     * Update an object.
     *
     * @param queryContext - query context with which to perform the update
     * @param idField - the field in the object that is the ID
     * @param id - the value of the ID field in the object
     * @param object - the object to update
     * @returns the updated object
     */
    async updateAsync(queryContext, idField, id, object) {
        const idColumn = (0, EntityFieldTransformationUtils_1.getDatabaseFieldForEntityField)(this.entityConfiguration, idField);
        const dbObject = (0, EntityFieldTransformationUtils_1.transformFieldsToDatabaseObject)(this.entityConfiguration, this.fieldTransformerMap, object);
        const results = await this.updateInternalAsync(queryContext.getQueryInterface(), this.entityConfiguration.tableName, idColumn, id, dbObject);
        if (results.length > 1) {
            throw new Error(`Excessive results from database adapter update: ${this.entityConfiguration.tableName}(id = ${id})`);
        }
        else if (results.length === 0) {
            throw new Error(`Empty results from database adapter update: ${this.entityConfiguration.tableName}(id = ${id})`);
        }
        return (0, EntityFieldTransformationUtils_1.transformDatabaseObjectToFields)(this.entityConfiguration, this.fieldTransformerMap, results[0]);
    }
    /**
     * Delete an object by ID.
     *
     * @param queryContext - query context with which to perform the deletion
     * @param idField - the field in the object that is the ID
     * @param id - the value of the ID field in the object
     */
    async deleteAsync(queryContext, idField, id) {
        const idColumn = (0, EntityFieldTransformationUtils_1.getDatabaseFieldForEntityField)(this.entityConfiguration, idField);
        const numDeleted = await this.deleteInternalAsync(queryContext.getQueryInterface(), this.entityConfiguration.tableName, idColumn, id);
        if (numDeleted > 1) {
            throw new Error(`Excessive deletions from database adapter delete: ${this.entityConfiguration.tableName}(id = ${id})`);
        }
    }
    convertToTableQueryModifiersWithOrderByRaw(querySelectionModifiers) {
        return {
            ...this.convertToTableQueryModifiers(querySelectionModifiers),
            orderByRaw: querySelectionModifiers.orderByRaw,
        };
    }
    convertToTableQueryModifiers(querySelectionModifiers) {
        const orderBy = querySelectionModifiers.orderBy;
        return {
            orderBy: orderBy !== undefined
                ? orderBy.map((orderBySpecification) => ({
                    columnName: (0, EntityFieldTransformationUtils_1.getDatabaseFieldForEntityField)(this.entityConfiguration, orderBySpecification.fieldName),
                    order: orderBySpecification.order,
                }))
                : undefined,
            offset: querySelectionModifiers.offset,
            limit: querySelectionModifiers.limit,
        };
    }
}
exports.default = EntityDatabaseAdapter;
//# sourceMappingURL=EntityDatabaseAdapter.js.map