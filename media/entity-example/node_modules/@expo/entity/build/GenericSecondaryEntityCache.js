"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const invariant_1 = __importDefault(require("invariant"));
const ReadThroughEntityCache_1 = require("./internal/ReadThroughEntityCache");
const maps_1 = require("./utils/collections/maps");
/**
 * A custom secondary read-through entity cache is a way to add a custom second layer of caching for a particular
 * single entity load. One common way this may be used is to add a second layer of caching in a hot path that makes
 * a call to EntityLoader.loadManyByFieldEqualityConjunctionAsync is guaranteed to return at most one entity.
 */
class GenericSecondaryEntityCache {
    cacher;
    constructCacheKey;
    constructor(cacher, constructCacheKey) {
        this.cacher = cacher;
        this.constructCacheKey = constructCacheKey;
    }
    async loadManyThroughAsync(loadParamsArray, fetcher) {
        const cacheKeys = loadParamsArray.map(this.constructCacheKey);
        const cacheKeyToLoadParamsMap = (0, maps_1.zipToMap)(cacheKeys, loadParamsArray);
        const cacheLoadResults = await this.cacher.loadManyAsync(cacheKeys);
        (0, invariant_1.default)(cacheLoadResults.size === loadParamsArray.length, `${this.constructor.name} loadMany should return a result for each key`);
        const cacheKeysToFetch = Array.from((0, maps_1.filterMap)(cacheLoadResults, (cacheLoadResult) => cacheLoadResult.status === ReadThroughEntityCache_1.CacheStatus.MISS).keys());
        // put cache hits in result map
        const results = new Map();
        cacheLoadResults.forEach((cacheLoadResult, cacheKey) => {
            if (cacheLoadResult.status === ReadThroughEntityCache_1.CacheStatus.HIT) {
                const loadParams = cacheKeyToLoadParamsMap.get(cacheKey);
                (0, invariant_1.default)(loadParams !== undefined, 'load params should be in cache key map');
                results.set(loadParams, cacheLoadResult.item);
            }
        });
        // fetch any misses from DB, add DB objects to results, cache DB results, inform cache of any missing DB results
        if (cacheKeysToFetch.length > 0) {
            const loadParamsToFetch = cacheKeysToFetch.map((cacheKey) => {
                const loadParams = cacheKeyToLoadParamsMap.get(cacheKey);
                (0, invariant_1.default)(loadParams !== undefined, 'load params should be in cache key map');
                return loadParams;
            });
            const fetchResults = await fetcher(loadParamsToFetch);
            const fetchMisses = loadParamsToFetch.filter((loadParams) => {
                // all values of fetchResults should be field objects or undefined
                return !fetchResults.get(loadParams);
            });
            for (const fetchMiss of fetchMisses) {
                results.set(fetchMiss, null);
            }
            const objectsToCache = new Map();
            for (const [loadParams, object] of fetchResults.entries()) {
                if (object) {
                    objectsToCache.set(this.constructCacheKey(loadParams), object);
                    results.set(loadParams, object);
                }
            }
            await Promise.all([
                this.cacher.cacheManyAsync(objectsToCache),
                this.cacher.cacheDBMissesAsync(fetchMisses.map(this.constructCacheKey)),
            ]);
        }
        return results;
    }
    /**
     * Invalidate the cache for objects cached by constructCacheKey(loadParams).
     *
     * @param loadParamsArray - load params to invalidate
     */
    invalidateManyAsync(loadParamsArray) {
        const cacheKeys = loadParamsArray.map(this.constructCacheKey);
        return this.cacher.invalidateManyAsync(cacheKeys);
    }
}
exports.default = GenericSecondaryEntityCache;
//# sourceMappingURL=GenericSecondaryEntityCache.js.map