"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const maps_1 = require("./utils/collections/maps");
/**
 * The data storage configuration for a type of Entity. Contains information relating to IDs,
 * cachable fields, field mappings, and types of cache and database adapter.
 */
class EntityConfiguration {
    idField;
    tableName;
    cacheableKeys;
    cacheKeyVersion;
    inboundEdges;
    schema;
    entityToDBFieldsKeyMapping;
    dbToEntityFieldsKeyMapping;
    databaseAdapterFlavor;
    cacheAdapterFlavor;
    constructor({ idField, tableName, schema, inboundEdges = [], cacheKeyVersion = 0, databaseAdapterFlavor, cacheAdapterFlavor, }) {
        this.idField = idField;
        this.tableName = tableName;
        this.cacheKeyVersion = cacheKeyVersion;
        this.databaseAdapterFlavor = databaseAdapterFlavor;
        this.cacheAdapterFlavor = cacheAdapterFlavor;
        this.inboundEdges = inboundEdges;
        // external schema is a Record to typecheck that all fields have FieldDefinitions,
        // but internally the most useful representation is a map for lookups
        EntityConfiguration.validateSchema(schema);
        this.schema = new Map(Object.entries(schema));
        this.cacheableKeys = EntityConfiguration.computeCacheableKeys(this.schema);
        this.entityToDBFieldsKeyMapping = EntityConfiguration.computeEntityToDBFieldsKeyMapping(this.schema);
        this.dbToEntityFieldsKeyMapping = (0, maps_1.invertMap)(this.entityToDBFieldsKeyMapping);
    }
    static validateSchema(schema) {
        const disallowedFieldsKeys = Object.getOwnPropertyNames(Object.prototype);
        for (const disallowedFieldsKey of disallowedFieldsKeys) {
            if (Object.hasOwn(schema, disallowedFieldsKey)) {
                throw new Error(`Entity field name not allowed to prevent conflicts with standard Object prototype fields: ${disallowedFieldsKey}`);
            }
        }
    }
    static computeCacheableKeys(schema) {
        return (0, maps_1.reduceMap)(schema, (acc, v, k) => {
            if (v.cache) {
                acc.add(k);
            }
            return acc;
        }, new Set());
    }
    static computeEntityToDBFieldsKeyMapping(schema) {
        return (0, maps_1.mapMap)(schema, (v) => v.columnName);
    }
}
exports.default = EntityConfiguration;
//# sourceMappingURL=EntityConfiguration.js.map