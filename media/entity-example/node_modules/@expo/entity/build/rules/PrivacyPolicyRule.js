"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleEvaluationResult = void 0;
var RuleEvaluationResult;
(function (RuleEvaluationResult) {
    /**
     * Deny viewer access to the entity.
     */
    RuleEvaluationResult[RuleEvaluationResult["DENY"] = -1] = "DENY";
    /**
     * Defer entity viewer access to subsequent rule in the privacy policy.
     */
    RuleEvaluationResult[RuleEvaluationResult["SKIP"] = 0] = "SKIP";
    /**
     * Allow viewer access to the entity.
     */
    RuleEvaluationResult[RuleEvaluationResult["ALLOW"] = 1] = "ALLOW";
})(RuleEvaluationResult || (exports.RuleEvaluationResult = RuleEvaluationResult = {}));
/**
 * A single unit of which declarative privacy policies are composed, allowing for simple
 * expression and testing of authorization logic.
 *
 * @remarks
 *
 * Each rule is responsible for returning a ruling of ALLOW, DENY, or SKIP for a condition
 * that it is checking for. While rules can return any of these, it is most common for
 * rules to return ALLOW or SKIP, explicitly authorizing or deferring authorization to the next
 * rule in the privacy policy. If all rules in the policy SKIP, the policy is denied.
 *
 * Returning DENY from a rule is useful in a few notable cases:
 * - Preventing a CRUD action on an entity (AlwaysDenyPrivacyPolicyRule)
 * - Blocking. For example, a user blocks another user from seeing their posts, and the rule
 *   would be named something like `DenyIfViewerHasBeenBlockedPrivacyPolicyRule`.
 */
class PrivacyPolicyRule {
}
exports.default = PrivacyPolicyRule;
//# sourceMappingURL=PrivacyPolicyRule.js.map