import { Result } from '@expo/results';
import { IEntityClass } from './Entity';
import EntityConfiguration from './EntityConfiguration';
import { FieldEqualityCondition, QuerySelectionModifiers, QuerySelectionModifiersWithOrderByRaw } from './EntityDatabaseAdapter';
import EntityLoaderUtils from './EntityLoaderUtils';
import EntityPrivacyPolicy from './EntityPrivacyPolicy';
import { EntityQueryContext } from './EntityQueryContext';
import ReadonlyEntity from './ReadonlyEntity';
import ViewerContext from './ViewerContext';
import EntityDataManager from './internal/EntityDataManager';
import IEntityMetricsAdapter from './metrics/IEntityMetricsAdapter';
/**
 * Authorization-result-based entity loader. All normal loads are batched,
 * cached, and authorized against the entity's EntityPrivacyPolicy. All loads through this
 * loader are are results (or null for some loader methods), where an unsuccessful result
 * means an authorization error or entity construction error occurred. Other errors are thrown.
 */
export default class AuthorizationResultBasedEntityLoader<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends ReadonlyEntity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields> {
    private readonly queryContext;
    private readonly entityConfiguration;
    private readonly entityClass;
    private readonly dataManager;
    protected readonly metricsAdapter: IEntityMetricsAdapter;
    private readonly utils;
    constructor(queryContext: EntityQueryContext, entityConfiguration: EntityConfiguration<TFields>, entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, dataManager: EntityDataManager<TFields>, metricsAdapter: IEntityMetricsAdapter, utils: EntityLoaderUtils<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>);
    /**
     * Load many entities where fieldName is one of fieldValues.
     * @param fieldName - entity field being queried
     * @param fieldValues - fieldName field values being queried
     * @returns map from fieldValue to entity results that match the query for that fieldValue,
     *          where result errors can be UnauthorizedError
     */
    loadManyByFieldEqualingManyAsync<N extends keyof Pick<TFields, TSelectedFields>>(fieldName: N, fieldValues: readonly NonNullable<TFields[N]>[]): Promise<ReadonlyMap<NonNullable<TFields[N]>, readonly Result<TEntity>[]>>;
    /**
     * Load many entities where fieldName equals fieldValue.
     * @param fieldName - entity field being queried
     * @param fieldValue - fieldName field value being queried
     * @returns array of entity results that match the query for fieldValue, where result error can be UnauthorizedError
     */
    loadManyByFieldEqualingAsync<N extends keyof Pick<TFields, TSelectedFields>>(fieldName: N, fieldValue: NonNullable<TFields[N]>): Promise<readonly Result<TEntity>[]>;
    /**
     * Load an entity where fieldName equals fieldValue, or null if no entity exists.
     * @param uniqueFieldName - entity field being queried
     * @param fieldValue - uniqueFieldName field value being queried
     * @returns entity result where uniqueFieldName equals fieldValue, or null if no entity matches the condition.
     * @throws when multiple entities match the condition
     */
    loadByFieldEqualingAsync<N extends keyof Pick<TFields, TSelectedFields>>(uniqueFieldName: N, fieldValue: NonNullable<TFields[N]>): Promise<Result<TEntity> | null>;
    /**
     * Loads an entity by a specified ID.
     * @param id - ID of the entity
     * @returns entity result for matching ID, where result error can be UnauthorizedError or EntityNotFoundError.
     */
    loadByIDAsync(id: TID): Promise<Result<TEntity>>;
    /**
     * Load an entity by a specified ID, or return null if non-existent.
     * @param id - ID of the entity
     * @returns entity result for matching ID, or null if no entity exists for ID.
     */
    loadByIDNullableAsync(id: TID): Promise<Result<TEntity> | null>;
    /**
     * Loads many entities for a list of IDs.
     * @param ids - IDs of the entities to load
     * @returns map from ID to corresponding entity result, where result error can be UnauthorizedError or EntityNotFoundError.
     */
    loadManyByIDsAsync(ids: readonly TID[]): Promise<ReadonlyMap<TID, Result<TEntity>>>;
    /**
     * Loads many entities for a list of IDs, returning null for any IDs that are non-existent.
     * @param ids - IDs of the entities to load
     * @returns map from ID to nullable corresponding entity result, where result error can be UnauthorizedError or EntityNotFoundError.
     */
    loadManyByIDsNullableAsync(ids: readonly TID[]): Promise<ReadonlyMap<TID, Result<TEntity> | null>>;
    /**
     * Loads the first entity matching the selection constructed from the conjunction of specified
     * operands, or null if no matching entity exists. Entities loaded using this method are not
     * batched or cached.
     *
     * This is a convenience method for {@link loadManyByFieldEqualityConjunctionAsync}. However, the
     * `orderBy` option must be specified to define what "first" means. If ordering doesn't matter,
     * explicitly pass in an empty array.
     *
     * @param fieldEqualityOperands - list of field equality selection operand specifications
     * @param querySelectionModifiers - orderBy and optional offset for the query
     * @returns the first entity results that matches the query, where result error can be
     *  UnauthorizedError
     */
    loadFirstByFieldEqualityConjunctionAsync<N extends keyof Pick<TFields, TSelectedFields>>(fieldEqualityOperands: FieldEqualityCondition<TFields, N>[], querySelectionModifiers: Omit<QuerySelectionModifiers<TFields>, 'limit'> & Required<Pick<QuerySelectionModifiers<TFields>, 'orderBy'>>): Promise<Result<TEntity> | null>;
    /**
     * Loads many entities matching the selection constructed from the conjunction of specified operands.
     * Entities loaded using this method are not batched or cached.
     *
     * @example
     * fieldEqualityOperands:
     * `[{fieldName: 'hello', fieldValue: 1}, {fieldName: 'world', fieldValues: [2, 3]}]`
     * Entities returned with a SQL EntityDatabaseAdapter:
     * `WHERE hello = 1 AND world = ANY({2, 3})`
     *
     * @param fieldEqualityOperands - list of field equality selection operand specifications
     * @param querySelectionModifiers - limit, offset, and orderBy for the query
     * @returns array of entity results that match the query, where result error can be UnauthorizedError
     */
    loadManyByFieldEqualityConjunctionAsync<N extends keyof Pick<TFields, TSelectedFields>>(fieldEqualityOperands: FieldEqualityCondition<TFields, N>[], querySelectionModifiers?: QuerySelectionModifiers<TFields>): Promise<readonly Result<TEntity>[]>;
    /**
     * Loads many entities matching the raw WHERE clause. Corresponds to the knex `whereRaw` argument format.
     *
     * @remarks
     * Important notes:
     * - Fields in clause are database column names instead of transformed entity field names.
     * - Entities loaded using this method are not batched or cached.
     * - Not all database adapters implement the ability to execute this method of fetching entities.
     *
     * @example
     * rawWhereClause: `id = ?`
     * bindings: `[1]`
     * Entites returned `WHERE id = 1`
     *
     * http://knexjs.org/#Builder-whereRaw
     * http://knexjs.org/#Raw-Bindings
     *
     * @param rawWhereClause - parameterized SQL WHERE clause with positional binding placeholders or named binding placeholders
     * @param bindings - array of positional bindings or object of named bindings
     * @param querySelectionModifiers - limit, offset, orderBy, and orderByRaw for the query
     * @returns array of entity results that match the query, where result error can be UnauthorizedError
     * @throws Error when rawWhereClause or bindings are invalid
     */
    loadManyByRawWhereClauseAsync(rawWhereClause: string, bindings: any[] | object, querySelectionModifiers?: QuerySelectionModifiersWithOrderByRaw<TFields>): Promise<readonly Result<TEntity>[]>;
    private validateFieldValues;
}
