"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
/**
 * An association loader is a set of convenience methods for loading entities
 * associated with an entity. In relational databases, these entities are often referenced
 * by foreign keys.
 */
class EntityAssociationLoader {
    entity;
    constructor(entity) {
        this.entity = entity;
    }
    /**
     * Load an associated entity identified by a field value of this entity. In a relational database,
     * the field in this entity is a foreign key to the ID of the associated entity.
     * @param fieldIdentifyingAssociatedEntity - field of this entity containing the ID of the associated entity
     * @param associatedEntityClass - class of the associated entity
     * @param queryContext - query context in which to perform the load
     */
    async loadAssociatedEntityAsync(fieldIdentifyingAssociatedEntity, associatedEntityClass, queryContext = this.entity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(associatedEntityClass)
        .getQueryContextProvider()
        .getQueryContext()) {
        const associatedEntityID = this.entity.getField(fieldIdentifyingAssociatedEntity);
        if (!associatedEntityID) {
            return (0, results_1.result)(null);
        }
        const loader = this.entity
            .getViewerContext()
            .getViewerScopedEntityCompanionForClass(associatedEntityClass)
            .getLoaderFactory()
            .forLoad(queryContext, { previousValue: null, cascadingDeleteCause: null });
        return (await loader
            .withAuthorizationResults()
            .loadByIDAsync(associatedEntityID));
    }
    /**
     * Load many entities associated with this entity, often referred to as entites belonging
     * to this entity. In a relational database, the field in the foreign entity is a
     * foreign key to the ID of this entity. Also commonly referred to as a has many relationship,
     * where this entity has many associated entities.
     * @param associatedEntityClass - class of the associated entities
     * @param associatedEntityFieldContainingThisID - field of associated entity which contains the ID of this entity
     * @param queryContext - query context in which to perform the load
     */
    async loadManyAssociatedEntitiesAsync(associatedEntityClass, associatedEntityFieldContainingThisID, queryContext = this.entity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(associatedEntityClass)
        .getQueryContextProvider()
        .getQueryContext()) {
        const thisID = this.entity.getID();
        const loader = this.entity
            .getViewerContext()
            .getViewerScopedEntityCompanionForClass(associatedEntityClass)
            .getLoaderFactory()
            .forLoad(queryContext, { previousValue: null, cascadingDeleteCause: null });
        return await loader
            .withAuthorizationResults()
            .loadManyByFieldEqualingAsync(associatedEntityFieldContainingThisID, thisID);
    }
    /**
     * Load an associated entity identified by a field value of this entity. In a relational database,
     * the field in this entity is a foreign key to a unique field of the associated entity.
     * @param fieldIdentifyingAssociatedEntity - field of this entity containing the value with which to look up associated entity
     * @param associatedEntityClass - class of the associated entity
     * @param associatedEntityLookupByField - field of associated entity with which to look up the associated entity
     * @param queryContext - query context in which to perform the load
     */
    async loadAssociatedEntityByFieldEqualingAsync(fieldIdentifyingAssociatedEntity, associatedEntityClass, associatedEntityLookupByField, queryContext = this.entity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(associatedEntityClass)
        .getQueryContextProvider()
        .getQueryContext()) {
        const associatedFieldValue = this.entity.getField(fieldIdentifyingAssociatedEntity);
        if (!associatedFieldValue) {
            return null;
        }
        const loader = this.entity
            .getViewerContext()
            .getViewerScopedEntityCompanionForClass(associatedEntityClass)
            .getLoaderFactory()
            .forLoad(queryContext, { previousValue: null, cascadingDeleteCause: null });
        return await loader
            .withAuthorizationResults()
            .loadByFieldEqualingAsync(associatedEntityLookupByField, associatedFieldValue);
    }
    /**
     * Load many associated entities identified by a field value of this entity. In a relational database,
     * the field in this entity refers to a field of the associated entity.
     * @param fieldIdentifyingAssociatedEntity - field of this entity containing the value with which to look up associated entities
     * @param associatedEntityClass - class of the associated entities
     * @param associatedEntityLookupByField - field of associated entities with which to look up the associated entities
     * @param queryContext - query context in which to perform the load
     */
    async loadManyAssociatedEntitiesByFieldEqualingAsync(fieldIdentifyingAssociatedEntity, associatedEntityClass, associatedEntityLookupByField, queryContext = this.entity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(associatedEntityClass)
        .getQueryContextProvider()
        .getQueryContext()) {
        const associatedFieldValue = this.entity.getField(fieldIdentifyingAssociatedEntity);
        if (!associatedFieldValue) {
            return [];
        }
        const loader = this.entity
            .getViewerContext()
            .getViewerScopedEntityCompanionForClass(associatedEntityClass)
            .getLoaderFactory()
            .forLoad(queryContext, { previousValue: null, cascadingDeleteCause: null });
        return await loader
            .withAuthorizationResults()
            .loadManyByFieldEqualingAsync(associatedEntityLookupByField, associatedFieldValue);
    }
    async loadAssociatedEntityThroughAsync(loadDirectives, queryContext) {
        let currentEntity = this.entity;
        for (const loadDirective of loadDirectives) {
            const { associatedEntityClass, fieldIdentifyingAssociatedEntity, associatedEntityLookupByField, } = loadDirective;
            let associatedEntityResult;
            if (associatedEntityLookupByField) {
                associatedEntityResult = await currentEntity
                    .associationLoader()
                    .loadAssociatedEntityByFieldEqualingAsync(fieldIdentifyingAssociatedEntity, associatedEntityClass, associatedEntityLookupByField, queryContext);
            }
            else {
                const associatedEntityResultLocal = await currentEntity
                    .associationLoader()
                    .loadAssociatedEntityAsync(fieldIdentifyingAssociatedEntity, associatedEntityClass, queryContext);
                if (associatedEntityResultLocal.ok && associatedEntityResultLocal.value === null) {
                    associatedEntityResult = null;
                }
                else {
                    associatedEntityResult = associatedEntityResultLocal;
                }
            }
            if (!associatedEntityResult) {
                return null;
            }
            if (!associatedEntityResult.ok) {
                return (0, results_1.result)(associatedEntityResult.reason);
            }
            currentEntity = associatedEntityResult.value;
        }
        return (0, results_1.result)(currentEntity);
    }
}
exports.default = EntityAssociationLoader;
//# sourceMappingURL=EntityAssociationLoader.js.map