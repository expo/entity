"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
const invariant_1 = __importDefault(require("invariant"));
const nullthrows_1 = __importDefault(require("nullthrows"));
const EntityDatabaseAdapter_1 = require("./EntityDatabaseAdapter");
const EntityInvalidFieldValueError_1 = __importDefault(require("./errors/EntityInvalidFieldValueError"));
const EntityNotFoundError_1 = __importDefault(require("./errors/EntityNotFoundError"));
const maps_1 = require("./utils/collections/maps");
/**
 * Authorization-result-based entity loader. All normal loads are batched,
 * cached, and authorized against the entity's EntityPrivacyPolicy. All loads through this
 * loader are are results (or null for some loader methods), where an unsuccessful result
 * means an authorization error or entity construction error occurred. Other errors are thrown.
 */
class AuthorizationResultBasedEntityLoader {
    queryContext;
    entityConfiguration;
    entityClass;
    dataManager;
    metricsAdapter;
    utils;
    constructor(queryContext, entityConfiguration, entityClass, dataManager, metricsAdapter, utils) {
        this.queryContext = queryContext;
        this.entityConfiguration = entityConfiguration;
        this.entityClass = entityClass;
        this.dataManager = dataManager;
        this.metricsAdapter = metricsAdapter;
        this.utils = utils;
    }
    /**
     * Load many entities where fieldName is one of fieldValues.
     * @param fieldName - entity field being queried
     * @param fieldValues - fieldName field values being queried
     * @returns map from fieldValue to entity results that match the query for that fieldValue,
     *          where result errors can be UnauthorizedError
     */
    async loadManyByFieldEqualingManyAsync(fieldName, fieldValues) {
        this.validateFieldValues(fieldName, fieldValues);
        const fieldValuesToFieldObjects = await this.dataManager.loadManyByFieldEqualingAsync(this.queryContext, fieldName, fieldValues);
        return await this.utils.constructAndAuthorizeEntitiesAsync(fieldValuesToFieldObjects);
    }
    /**
     * Load many entities where fieldName equals fieldValue.
     * @param fieldName - entity field being queried
     * @param fieldValue - fieldName field value being queried
     * @returns array of entity results that match the query for fieldValue, where result error can be UnauthorizedError
     */
    async loadManyByFieldEqualingAsync(fieldName, fieldValue) {
        const entityResults = await this.loadManyByFieldEqualingManyAsync(fieldName, [fieldValue]);
        const entityResultsForFieldValue = entityResults.get(fieldValue);
        (0, invariant_1.default)(entityResultsForFieldValue !== undefined, `${fieldValue} should be guaranteed to be present in returned map of entities`);
        return entityResultsForFieldValue;
    }
    /**
     * Load an entity where fieldName equals fieldValue, or null if no entity exists.
     * @param uniqueFieldName - entity field being queried
     * @param fieldValue - uniqueFieldName field value being queried
     * @returns entity result where uniqueFieldName equals fieldValue, or null if no entity matches the condition.
     * @throws when multiple entities match the condition
     */
    async loadByFieldEqualingAsync(uniqueFieldName, fieldValue) {
        const entityResults = await this.loadManyByFieldEqualingAsync(uniqueFieldName, fieldValue);
        (0, invariant_1.default)(entityResults.length <= 1, `loadByFieldEqualing: Multiple entities of type ${this.entityClass.name} found for ${String(uniqueFieldName)}=${fieldValue}`);
        return entityResults[0] ?? null;
    }
    /**
     * Loads an entity by a specified ID.
     * @param id - ID of the entity
     * @returns entity result for matching ID, where result error can be UnauthorizedError or EntityNotFoundError.
     */
    async loadByIDAsync(id) {
        const entityResults = await this.loadManyByIDsAsync([id]);
        // loadManyByIDsAsync is always populated for each id supplied
        return (0, nullthrows_1.default)(entityResults.get(id));
    }
    /**
     * Load an entity by a specified ID, or return null if non-existent.
     * @param id - ID of the entity
     * @returns entity result for matching ID, or null if no entity exists for ID.
     */
    async loadByIDNullableAsync(id) {
        return await this.loadByFieldEqualingAsync(this.entityConfiguration.idField, id);
    }
    /**
     * Loads many entities for a list of IDs.
     * @param ids - IDs of the entities to load
     * @returns map from ID to corresponding entity result, where result error can be UnauthorizedError or EntityNotFoundError.
     */
    async loadManyByIDsAsync(ids) {
        const entityResults = (await this.loadManyByFieldEqualingManyAsync(this.entityConfiguration.idField, ids));
        return (0, maps_1.mapMap)(entityResults, (entityResultsForId, id) => {
            const entityResult = entityResultsForId[0];
            return (entityResult ??
                (0, results_1.result)(new EntityNotFoundError_1.default(this.entityClass, this.entityConfiguration.idField, id)));
        });
    }
    /**
     * Loads many entities for a list of IDs, returning null for any IDs that are non-existent.
     * @param ids - IDs of the entities to load
     * @returns map from ID to nullable corresponding entity result, where result error can be UnauthorizedError or EntityNotFoundError.
     */
    async loadManyByIDsNullableAsync(ids) {
        const entityResults = (await this.loadManyByFieldEqualingManyAsync(this.entityConfiguration.idField, ids));
        return (0, maps_1.mapMap)(entityResults, (entityResultsForId) => {
            return entityResultsForId[0] ?? null;
        });
    }
    /**
     * Loads the first entity matching the selection constructed from the conjunction of specified
     * operands, or null if no matching entity exists. Entities loaded using this method are not
     * batched or cached.
     *
     * This is a convenience method for {@link loadManyByFieldEqualityConjunctionAsync}. However, the
     * `orderBy` option must be specified to define what "first" means. If ordering doesn't matter,
     * explicitly pass in an empty array.
     *
     * @param fieldEqualityOperands - list of field equality selection operand specifications
     * @param querySelectionModifiers - orderBy and optional offset for the query
     * @returns the first entity results that matches the query, where result error can be
     *  UnauthorizedError
     */
    async loadFirstByFieldEqualityConjunctionAsync(fieldEqualityOperands, querySelectionModifiers) {
        const results = await this.loadManyByFieldEqualityConjunctionAsync(fieldEqualityOperands, {
            ...querySelectionModifiers,
            limit: 1,
        });
        return results[0] ?? null;
    }
    /**
     * Loads many entities matching the selection constructed from the conjunction of specified operands.
     * Entities loaded using this method are not batched or cached.
     *
     * @example
     * fieldEqualityOperands:
     * `[{fieldName: 'hello', fieldValue: 1}, {fieldName: 'world', fieldValues: [2, 3]}]`
     * Entities returned with a SQL EntityDatabaseAdapter:
     * `WHERE hello = 1 AND world = ANY({2, 3})`
     *
     * @param fieldEqualityOperands - list of field equality selection operand specifications
     * @param querySelectionModifiers - limit, offset, and orderBy for the query
     * @returns array of entity results that match the query, where result error can be UnauthorizedError
     */
    async loadManyByFieldEqualityConjunctionAsync(fieldEqualityOperands, querySelectionModifiers = {}) {
        for (const fieldEqualityOperand of fieldEqualityOperands) {
            const fieldValues = (0, EntityDatabaseAdapter_1.isSingleValueFieldEqualityCondition)(fieldEqualityOperand)
                ? [fieldEqualityOperand.fieldValue]
                : fieldEqualityOperand.fieldValues;
            this.validateFieldValues(fieldEqualityOperand.fieldName, fieldValues);
        }
        const fieldObjects = await this.dataManager.loadManyByFieldEqualityConjunctionAsync(this.queryContext, fieldEqualityOperands, querySelectionModifiers);
        return await this.utils.constructAndAuthorizeEntitiesArrayAsync(fieldObjects);
    }
    /**
     * Loads many entities matching the raw WHERE clause. Corresponds to the knex `whereRaw` argument format.
     *
     * @remarks
     * Important notes:
     * - Fields in clause are database column names instead of transformed entity field names.
     * - Entities loaded using this method are not batched or cached.
     * - Not all database adapters implement the ability to execute this method of fetching entities.
     *
     * @example
     * rawWhereClause: `id = ?`
     * bindings: `[1]`
     * Entites returned `WHERE id = 1`
     *
     * http://knexjs.org/#Builder-whereRaw
     * http://knexjs.org/#Raw-Bindings
     *
     * @param rawWhereClause - parameterized SQL WHERE clause with positional binding placeholders or named binding placeholders
     * @param bindings - array of positional bindings or object of named bindings
     * @param querySelectionModifiers - limit, offset, orderBy, and orderByRaw for the query
     * @returns array of entity results that match the query, where result error can be UnauthorizedError
     * @throws Error when rawWhereClause or bindings are invalid
     */
    async loadManyByRawWhereClauseAsync(rawWhereClause, bindings, querySelectionModifiers = {}) {
        const fieldObjects = await this.dataManager.loadManyByRawWhereClauseAsync(this.queryContext, rawWhereClause, bindings, querySelectionModifiers);
        return await this.utils.constructAndAuthorizeEntitiesArrayAsync(fieldObjects);
    }
    validateFieldValues(fieldName, fieldValues) {
        const fieldDefinition = this.entityConfiguration.schema.get(fieldName);
        (0, invariant_1.default)(fieldDefinition, `must have field definition for field = ${String(fieldName)}`);
        for (const fieldValue of fieldValues) {
            const isInputValid = fieldDefinition.validateInputValue(fieldValue);
            if (!isInputValid) {
                throw new EntityInvalidFieldValueError_1.default(this.entityClass, fieldName, fieldValue);
            }
        }
    }
}
exports.default = AuthorizationResultBasedEntityLoader;
//# sourceMappingURL=AuthorizationResultBasedEntityLoader.js.map