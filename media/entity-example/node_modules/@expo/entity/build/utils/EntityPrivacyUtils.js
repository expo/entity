"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.canViewerUpdateAsync = canViewerUpdateAsync;
exports.getCanViewerUpdateResultAsync = getCanViewerUpdateResultAsync;
exports.canViewerDeleteAsync = canViewerDeleteAsync;
exports.getCanViewerDeleteResultAsync = getCanViewerDeleteResultAsync;
const results_1 = require("@expo/results");
const EntityFieldDefinition_1 = require("../EntityFieldDefinition");
const entityUtils_1 = require("../entityUtils");
const EntityNotAuthorizedError_1 = __importDefault(require("../errors/EntityNotAuthorizedError"));
/**
 * Check whether an entity loaded by a viewer can be updated by that same viewer.
 *
 * @remarks
 *
 * This may be useful in situations relying upon the thrown privacy policy thrown authorization error
 * is insufficient for the task at hand. When dealing with purely a sequence of mutations it is easy
 * to roll back all mutations given a single authorization error by wrapping them in a single transaction.
 * When certain portions of a mutation cannot be rolled back transactionally (third pary calls,
 * legacy code, etc), using this method can help decide whether the sequence of mutations will fail before
 * attempting them. Note that if any privacy policy rules use a piece of data being updated in the mutations
 * the result of this method and the update mutation itself may differ.
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
async function canViewerUpdateAsync(entityClass, sourceEntity, queryContext = sourceEntity
    .getViewerContext()
    .getViewerScopedEntityCompanionForClass(entityClass)
    .getQueryContextProvider()
    .getQueryContext()) {
    const result = await canViewerUpdateInternalAsync(entityClass, sourceEntity, 
    /* cascadingDeleteCause */ null, queryContext);
    return result.allowed;
}
/**
 * Check whether an entity loaded by a viewer can be updated by that same viewer and return the evaluation result.
 *
 * @see canViewerUpdateAsync
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
async function getCanViewerUpdateResultAsync(entityClass, sourceEntity, queryContext = sourceEntity
    .getViewerContext()
    .getViewerScopedEntityCompanionForClass(entityClass)
    .getQueryContextProvider()
    .getQueryContext()) {
    return await canViewerUpdateInternalAsync(entityClass, sourceEntity, 
    /* cascadingDeleteCause */ null, queryContext);
}
async function canViewerUpdateInternalAsync(entityClass, sourceEntity, cascadingDeleteCause, queryContext) {
    const companion = sourceEntity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(entityClass);
    const privacyPolicy = companion.entityCompanion.privacyPolicy;
    const evaluationResult = await (0, results_1.asyncResult)(privacyPolicy.authorizeUpdateAsync(sourceEntity.getViewerContext(), queryContext, { previousValue: null, cascadingDeleteCause }, sourceEntity, companion.getMetricsAdapter()));
    if (!evaluationResult.ok) {
        if (evaluationResult.reason instanceof EntityNotAuthorizedError_1.default) {
            return { allowed: false, authorizationErrors: [evaluationResult.reason] };
        }
        else {
            throw evaluationResult.reason;
        }
    }
    return { allowed: true };
}
/**
 * Check whether a single entity loaded by a viewer can be deleted by that same viewer.
 * This recursively checks edge cascade permissions (EntityEdgeDeletionBehavior) as well.
 *
 * @see canViewerUpdateAsync
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
async function canViewerDeleteAsync(entityClass, sourceEntity, queryContext = sourceEntity
    .getViewerContext()
    .getViewerScopedEntityCompanionForClass(entityClass)
    .getQueryContextProvider()
    .getQueryContext()) {
    const result = await canViewerDeleteInternalAsync(entityClass, sourceEntity, 
    /* cascadingDeleteCause */ null, queryContext);
    return result.allowed;
}
/**
 * Check whether a single entity loaded by a viewer can be deleted by that same viewer and return the evaluation result.
 *
 * @see canViewerDeleteAsync
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
async function getCanViewerDeleteResultAsync(entityClass, sourceEntity, queryContext = sourceEntity
    .getViewerContext()
    .getViewerScopedEntityCompanionForClass(entityClass)
    .getQueryContextProvider()
    .getQueryContext()) {
    return await canViewerDeleteInternalAsync(entityClass, sourceEntity, 
    /* cascadingDeleteCause */ null, queryContext);
}
async function canViewerDeleteInternalAsync(entityClass, sourceEntity, cascadingDeleteCause, queryContext) {
    const viewerContext = sourceEntity.getViewerContext();
    const entityCompanionProvider = viewerContext.entityCompanionProvider;
    const viewerScopedCompanion = sourceEntity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(entityClass);
    const privacyPolicy = viewerScopedCompanion.entityCompanion.privacyPolicy;
    const evaluationResult = await (0, results_1.asyncResult)(privacyPolicy.authorizeDeleteAsync(sourceEntity.getViewerContext(), queryContext, { previousValue: null, cascadingDeleteCause }, sourceEntity, viewerScopedCompanion.getMetricsAdapter()));
    if (!evaluationResult.ok) {
        if (evaluationResult.reason instanceof EntityNotAuthorizedError_1.default) {
            return { allowed: false, authorizationErrors: [evaluationResult.reason] };
        }
        else {
            throw evaluationResult.reason;
        }
    }
    const newCascadingDeleteCause = {
        entity: sourceEntity,
        cascadingDeleteCause,
    };
    // Take entity X which is proposed to be deleted, look at inbound edges (entities that reference X).
    // These inbound edges are the entities that will either get deleted or have their references
    // to X nullified based on the EntityEdgeDeletionBehavior when entity X is deleted.
    // For each of these inboundEdge entities Y, look at the field(s) on Y that reference X.
    // For each of the field(s) on Y that reference X,
    // - if EntityEdgeDeletionBehavior is cascade set null, check if user can update Y
    // - if EntityEdgeDeletionBehavior is cascade delete, recursively run canViewerDeleteAsync on Y
    // Return the conjunction (returning eagerly when false) of all checks recursively.
    const entityConfiguration = viewerScopedCompanion.entityCompanion.entityCompanionDefinition.entityConfiguration;
    const inboundEdges = entityConfiguration.inboundEdges;
    for (const inboundEdge of inboundEdges) {
        const configurationForInboundEdge = entityCompanionProvider.getCompanionForEntity(inboundEdge).entityCompanionDefinition
            .entityConfiguration;
        const loader = viewerContext
            .getViewerScopedEntityCompanionForClass(inboundEdge)
            .getLoaderFactory()
            .forLoad(queryContext, {
            previousValue: null,
            cascadingDeleteCause: newCascadingDeleteCause,
        });
        for (const [fieldName, fieldDefinition] of configurationForInboundEdge.schema) {
            const association = fieldDefinition.association;
            if (!association) {
                continue;
            }
            const associatedConfiguration = entityCompanionProvider.getCompanionForEntity(association.associatedEntityClass).entityCompanionDefinition.entityConfiguration;
            if (associatedConfiguration !== entityConfiguration) {
                continue;
            }
            const edgeDeletionPermissionInferenceBehavior = association.edgeDeletionAuthorizationInferenceBehavior;
            let entityResultsToCheckForInboundEdge;
            if (edgeDeletionPermissionInferenceBehavior ===
                EntityFieldDefinition_1.EntityEdgeDeletionAuthorizationInferenceBehavior.ONE_IMPLIES_ALL) {
                const singleEntityToTestForInboundEdge = await loader
                    .withAuthorizationResults()
                    .loadFirstByFieldEqualityConjunctionAsync([
                    {
                        fieldName,
                        fieldValue: association.associatedEntityLookupByField
                            ? sourceEntity.getField(association.associatedEntityLookupByField)
                            : sourceEntity.getID(),
                    },
                ], { orderBy: [] });
                entityResultsToCheckForInboundEdge = singleEntityToTestForInboundEdge
                    ? [singleEntityToTestForInboundEdge]
                    : [];
            }
            else {
                const entityResultsForInboundEdge = await loader
                    .withAuthorizationResults()
                    .loadManyByFieldEqualingAsync(fieldName, association.associatedEntityLookupByField
                    ? sourceEntity.getField(association.associatedEntityLookupByField)
                    : sourceEntity.getID());
                entityResultsToCheckForInboundEdge = entityResultsForInboundEdge;
            }
            const failedEntityLoadResults = (0, entityUtils_1.failedResults)(entityResultsToCheckForInboundEdge);
            for (const failedResult of failedEntityLoadResults) {
                if (failedResult.reason instanceof EntityNotAuthorizedError_1.default) {
                    return { allowed: false, authorizationErrors: [failedResult.reason] };
                }
                else {
                    throw failedResult.reason;
                }
            }
            // all results should be success at this point due to check above
            const entitiesForInboundEdge = entityResultsToCheckForInboundEdge.map((r) => r.enforceValue());
            switch (association.edgeDeletionBehavior) {
                case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE:
                case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE_INVALIDATE_CACHE_ONLY: {
                    const canDeleteEvaluationResults = await Promise.all(entitiesForInboundEdge.map((entity) => canViewerDeleteInternalAsync(inboundEdge, entity, newCascadingDeleteCause, queryContext)));
                    const reducedEvaluationResult = reduceEvaluationResults(canDeleteEvaluationResults);
                    if (!reducedEvaluationResult.allowed) {
                        return reducedEvaluationResult;
                    }
                    break;
                }
                case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL:
                case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL_INVALIDATE_CACHE_ONLY: {
                    const canUpdateEvaluationResults = await Promise.all(entitiesForInboundEdge.map((entity) => canViewerUpdateInternalAsync(inboundEdge, entity, newCascadingDeleteCause, queryContext)));
                    const reducedEvaluationResult = reduceEvaluationResults(canUpdateEvaluationResults);
                    if (!reducedEvaluationResult.allowed) {
                        return reducedEvaluationResult;
                    }
                    break;
                }
            }
        }
    }
    return { allowed: true };
}
function reduceEvaluationResults(evaluationResults) {
    const [successResults, failureResults] = (0, entityUtils_1.partitionArray)(evaluationResults, (evaluationResult) => evaluationResult.allowed);
    if (successResults.length === evaluationResults.length) {
        return { allowed: true };
    }
    return {
        allowed: false,
        authorizationErrors: failureResults.flatMap((failureResult) => failureResult.authorizationErrors),
    };
}
//# sourceMappingURL=EntityPrivacyUtils.js.map