"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nullthrows_1 = __importDefault(require("nullthrows"));
const Entity_1 = __importDefault(require("../../Entity"));
const EntityConfiguration_1 = __importDefault(require("../../EntityConfiguration"));
const EntityFieldDefinition_1 = require("../../EntityFieldDefinition");
const EntityFields_1 = require("../../EntityFields");
const EntityPrivacyPolicy_1 = __importStar(require("../../EntityPrivacyPolicy"));
const ViewerContext_1 = __importDefault(require("../../ViewerContext"));
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../../rules/AlwaysAllowPrivacyPolicyRule"));
const AlwaysDenyPrivacyPolicyRule_1 = __importDefault(require("../../rules/AlwaysDenyPrivacyPolicyRule"));
const PrivacyPolicyRule_1 = require("../../rules/PrivacyPolicyRule");
const EntityPrivacyUtils_1 = require("../EntityPrivacyUtils");
const createUnitTestEntityCompanionProvider_1 = require("../testing/createUnitTestEntityCompanionProvider");
function assertEntityPrivacyEvaluationResultFailure(evaluationResult) {
    if (evaluationResult.allowed) {
        throw new Error('Evaluation result not failure');
    }
}
function expectAuthorizationError(evaluationResult, { entityId, action }) {
    expect(evaluationResult.allowed).toBe(false);
    assertEntityPrivacyEvaluationResultFailure(evaluationResult);
    const authorizationErrors = evaluationResult.authorizationErrors;
    expect(authorizationErrors).toHaveLength(1);
    const authorizationError = (0, nullthrows_1.default)(authorizationErrors[0]);
    expect(authorizationError.message).toContain(entityId);
    expect(authorizationError.message).toContain(EntityPrivacyPolicy_1.EntityAuthorizationAction[action]);
}
describe(EntityPrivacyUtils_1.canViewerUpdateAsync, () => {
    it('appropriately executes update privacy policy', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyDeleteEntity.creator(viewerContext).enforceCreateAsync();
        const canViewerUpdate = await (0, EntityPrivacyUtils_1.canViewerUpdateAsync)(SimpleTestDenyDeleteEntity, testEntity);
        expect(canViewerUpdate).toBe(true);
        const canViewerUpdateResult = await (0, EntityPrivacyUtils_1.getCanViewerUpdateResultAsync)(SimpleTestDenyDeleteEntity, testEntity);
        expect(canViewerUpdateResult.allowed).toBe(true);
    });
    it('denies when policy denies', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext).enforceCreateAsync();
        const canViewerUpdate = await (0, EntityPrivacyUtils_1.canViewerUpdateAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerUpdate).toBe(false);
        const canViewerUpdateResult = await (0, EntityPrivacyUtils_1.getCanViewerUpdateResultAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expectAuthorizationError(canViewerUpdateResult, {
            entityId: testEntity.getID(),
            action: EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE,
        });
    });
    it('rethrows non-authorization errors', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestThrowOtherErrorEntity.creator(viewerContext).enforceCreateAsync();
        await expect((0, EntityPrivacyUtils_1.canViewerUpdateAsync)(SimpleTestThrowOtherErrorEntity, testEntity)).rejects.toThrow('update error');
        await expect((0, EntityPrivacyUtils_1.getCanViewerUpdateResultAsync)(SimpleTestThrowOtherErrorEntity, testEntity)).rejects.toThrow('update error');
    });
});
describe(EntityPrivacyUtils_1.canViewerDeleteAsync, () => {
    it('appropriately executes update privacy policy', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext).enforceCreateAsync();
        const canViewerDelete = await (0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerDelete).toBe(true);
        const canViewerDeleteResult = await (0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerDeleteResult.allowed).toBe(true);
    });
    it('denies when policy denies', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyDeleteEntity.creator(viewerContext).enforceCreateAsync();
        const canViewerDelete = await (0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyDeleteEntity, testEntity);
        expect(canViewerDelete).toBe(false);
        const canViewerDeleteResult = await (0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyDeleteEntity, testEntity);
        expectAuthorizationError(canViewerDeleteResult, {
            entityId: testEntity.getID(),
            action: EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE,
        });
    });
    it('denies when recursive policy denies for CASCADE_DELETE', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext).enforceCreateAsync();
        // add another entity referencing testEntity that would cascade deletion to itself when testEntity is deleted
        const leafEntity = await LeafDenyDeleteEntity.creator(viewerContext)
            .setField('simple_test_deny_update_cascade_delete_id', testEntity.getID())
            .enforceCreateAsync();
        const canViewerDelete = await (0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerDelete).toBe(false);
        const canViewerDeleteResult = await (0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expectAuthorizationError(canViewerDeleteResult, {
            entityId: leafEntity.getID(),
            action: EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE,
        });
    });
    it('denies when recursive policy denies for SET_NULL', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext).enforceCreateAsync();
        // add another entity referencing testEntity that would set null to its column when testEntity is deleted
        const leafEntity = await LeafDenyUpdateEntity.creator(viewerContext)
            .setField('simple_test_deny_update_set_null_id', testEntity.getID())
            .enforceCreateAsync();
        const canViewerDelete = await (0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerDelete).toBe(false);
        const canViewerDeleteResult = await (0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expectAuthorizationError(canViewerDeleteResult, {
            entityId: leafEntity.getID(),
            action: EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE,
        });
    });
    it('allows when recursive policy allows for CASCADE_DELETE and SET_NULL', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext).enforceCreateAsync();
        // add another entity referencing testEntity that would cascade deletion to itself when testEntity is deleted
        await LeafDenyUpdateEntity.creator(viewerContext)
            .setField('simple_test_deny_update_cascade_delete_id', testEntity.getID())
            .enforceCreateAsync();
        // add another entity referencing testEntity that would set null to its column when testEntity is deleted
        await LeafDenyDeleteEntity.creator(viewerContext)
            .setField('simple_test_deny_update_set_null_id', testEntity.getID())
            .enforceCreateAsync();
        const canViewerDelete = await (0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerDelete).toBe(true);
        const canViewerDeleteResult = await (0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerDeleteResult.allowed).toBe(true);
    });
    it('rethrows non-authorization errors', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestThrowOtherErrorEntity.creator(viewerContext).enforceCreateAsync();
        await expect((0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestThrowOtherErrorEntity, testEntity)).rejects.toThrowError('delete error');
        await expect((0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestThrowOtherErrorEntity, testEntity)).rejects.toThrowError('delete error');
    });
    it('returns false when edge cannot be read', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext).enforceCreateAsync();
        const leafEntity = await LeafDenyReadEntity.creator(viewerContext)
            .setField('simple_test_id', testEntity.getID())
            .enforceCreateAsync();
        const canViewerDelete = await (0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expect(canViewerDelete).toBe(false);
        const canViewerDeleteResult = await (0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyUpdateEntity, testEntity);
        expectAuthorizationError(canViewerDeleteResult, {
            entityId: leafEntity.getID(),
            action: EntityPrivacyPolicy_1.EntityAuthorizationAction.READ,
        });
    });
    it('rethrows non-authorization edge read errors', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext).enforceCreateAsync();
        await SimpleTestThrowOtherErrorEntity.creator(viewerContext)
            .setField('simple_test_id', testEntity.getID())
            .enforceCreateAsync();
        await expect((0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyUpdateEntity, testEntity)).rejects.toThrowError('read in cascading delete error');
        await expect((0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyUpdateEntity, testEntity)).rejects.toThrowError('read in cascading delete error');
    });
    it('supports running within a transaction', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const canViewerDelete = await viewerContext.runInTransactionForDatabaseAdaptorFlavorAsync('postgres', async (queryContext) => {
            const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext, queryContext).enforceCreateAsync();
            await LeafDenyReadEntity.creator(viewerContext, queryContext)
                .setField('simple_test_id', testEntity.getID())
                .enforceCreateAsync();
            // this would fail if transactions weren't supported or correctly passed through
            return await (0, EntityPrivacyUtils_1.canViewerDeleteAsync)(SimpleTestDenyUpdateEntity, testEntity, queryContext);
        });
        expect(canViewerDelete).toBe(true);
        const canViewerDeleteResult = await viewerContext.runInTransactionForDatabaseAdaptorFlavorAsync('postgres', async (queryContext) => {
            const testEntity = await SimpleTestDenyUpdateEntity.creator(viewerContext, queryContext).enforceCreateAsync();
            await LeafDenyReadEntity.creator(viewerContext, queryContext)
                .setField('simple_test_id', testEntity.getID())
                .enforceCreateAsync();
            // this would fail if transactions weren't supported or correctly passed through
            return await (0, EntityPrivacyUtils_1.getCanViewerDeleteResultAsync)(SimpleTestDenyUpdateEntity, testEntity, queryContext);
        });
        expect(canViewerDeleteResult.allowed).toBe(true);
    });
});
class DenyUpdateEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysDenyPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
class DenyDeleteEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysDenyPrivacyPolicyRule_1.default(),
    ];
}
class ThrowOtherErrorEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        {
            async evaluateAsync(_viewerContext, _queryContext, evaluationContext, _entity) {
                if (evaluationContext.cascadingDeleteCause) {
                    throw new Error('read in cascading delete error');
                }
                return PrivacyPolicyRule_1.RuleEvaluationResult.SKIP;
            },
        },
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        {
            async evaluateAsync() {
                throw new Error('update error');
            },
        },
    ];
    deleteRules = [
        {
            async evaluateAsync() {
                throw new Error('delete error');
            },
        },
    ];
}
class DenyReadEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        {
            async evaluateAsync(_viewerContext, queryContext, evaluationContext, _entity) {
                if (queryContext.isInTransaction()) {
                    return PrivacyPolicyRule_1.RuleEvaluationResult.ALLOW;
                }
                return evaluationContext.cascadingDeleteCause
                    ? PrivacyPolicyRule_1.RuleEvaluationResult.SKIP
                    : PrivacyPolicyRule_1.RuleEvaluationResult.ALLOW;
            },
        },
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
class LeafDenyUpdateEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: LeafDenyUpdateEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'leaf_1',
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'custom_id',
                    }),
                    // to ensure edge traversal doesn't process other edges
                    unused_other_association: new EntityFields_1.UUIDField({
                        columnName: 'unused_other_association',
                        association: {
                            associatedEntityClass: LeafDenyDeleteEntity,
                            edgeDeletionBehavior: EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL,
                        },
                    }),
                    // deletion behavior should fail since this entity can't be updated and a SET NULL does an update
                    simple_test_deny_update_set_null_id: new EntityFields_1.UUIDField({
                        columnName: 'simple_test_deny_update_set_null_id',
                        association: {
                            associatedEntityClass: SimpleTestDenyUpdateEntity,
                            edgeDeletionBehavior: EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL,
                        },
                    }),
                    // deletion behavior should succeed since this entity can be deleted
                    simple_test_deny_update_cascade_delete_id: new EntityFields_1.UUIDField({
                        columnName: 'simple_test_deny_update_cascade_delete_id',
                        association: {
                            associatedEntityClass: SimpleTestDenyUpdateEntity,
                            edgeDeletionBehavior: EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE,
                        },
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: DenyUpdateEntityPrivacyPolicy,
        };
    }
}
class LeafDenyDeleteEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: LeafDenyDeleteEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'leaf_2',
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'custom_id',
                    }),
                    // deletion behavior should fail since this entity can't be deleted
                    simple_test_deny_update_cascade_delete_id: new EntityFields_1.UUIDField({
                        columnName: 'simple_test_deny_update_cascade_delete_id',
                        association: {
                            associatedEntityClass: SimpleTestDenyUpdateEntity,
                            edgeDeletionBehavior: EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE,
                        },
                    }),
                    // deletion behavior should succeed since this entity can be updated and a SET NULL does an update
                    simple_test_deny_update_set_null_id: new EntityFields_1.UUIDField({
                        columnName: 'simple_test_deny_update_set_null_id',
                        association: {
                            associatedEntityClass: SimpleTestDenyUpdateEntity,
                            edgeDeletionBehavior: EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL,
                        },
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: DenyDeleteEntityPrivacyPolicy,
        };
    }
}
class LeafDenyReadEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: LeafDenyReadEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'leaf_4',
                inboundEdges: [],
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'custom_id',
                    }),
                    simple_test_id: new EntityFields_1.UUIDField({
                        columnName: 'simple_test_id',
                        association: {
                            associatedEntityClass: SimpleTestDenyUpdateEntity,
                            associatedEntityLookupByField: 'id',
                            edgeDeletionBehavior: EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL,
                        },
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: DenyReadEntityPrivacyPolicy,
        };
    }
}
class SimpleTestDenyUpdateEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: SimpleTestDenyUpdateEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'blah',
                inboundEdges: [
                    LeafDenyUpdateEntity,
                    LeafDenyDeleteEntity,
                    LeafDenyReadEntity,
                    SimpleTestThrowOtherErrorEntity,
                ],
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'custom_id',
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: DenyUpdateEntityPrivacyPolicy,
        };
    }
}
class SimpleTestDenyDeleteEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: SimpleTestDenyDeleteEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'blah_2',
                inboundEdges: [
                    LeafDenyUpdateEntity,
                    LeafDenyDeleteEntity,
                    LeafDenyReadEntity,
                    SimpleTestThrowOtherErrorEntity,
                ],
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'custom_id',
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: DenyDeleteEntityPrivacyPolicy,
        };
    }
}
class SimpleTestThrowOtherErrorEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: SimpleTestThrowOtherErrorEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'blah_3',
                inboundEdges: [],
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'custom_id',
                    }),
                    simple_test_id: new EntityFields_1.UUIDField({
                        columnName: 'simple_test_id',
                        association: {
                            associatedEntityClass: SimpleTestDenyUpdateEntity,
                            associatedEntityLookupByField: 'id',
                            edgeDeletionBehavior: EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL,
                        },
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: ThrowOtherErrorEntityPrivacyPolicy,
        };
    }
}
//# sourceMappingURL=EntityPrivacyUtils-test.js.map