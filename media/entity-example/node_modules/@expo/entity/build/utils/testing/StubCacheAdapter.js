"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryFullCacheStubCacheAdapter = exports.InMemoryFullCacheStubCacheAdapterProvider = exports.NoCacheStubCacheAdapter = exports.NoCacheStubCacheAdapterProvider = void 0;
const invariant_1 = __importDefault(require("invariant"));
const ReadThroughEntityCache_1 = require("../../internal/ReadThroughEntityCache");
class NoCacheStubCacheAdapterProvider {
    getCacheAdapter(_entityConfiguration) {
        return new NoCacheStubCacheAdapter();
    }
}
exports.NoCacheStubCacheAdapterProvider = NoCacheStubCacheAdapterProvider;
class NoCacheStubCacheAdapter {
    async loadManyAsync(_fieldName, fieldValues) {
        return fieldValues.reduce((acc, v) => {
            acc.set(v, {
                status: ReadThroughEntityCache_1.CacheStatus.MISS,
            });
            return acc;
        }, new Map());
    }
    async cacheManyAsync(_fieldName, _objectMap) { }
    async cacheDBMissesAsync(_fieldName, _fieldValues) { }
    async invalidateManyAsync(_fieldName, _fieldValues) { }
}
exports.NoCacheStubCacheAdapter = NoCacheStubCacheAdapter;
class InMemoryFullCacheStubCacheAdapterProvider {
    cache = new Map();
    getCacheAdapter(entityConfiguration) {
        return new InMemoryFullCacheStubCacheAdapter(entityConfiguration, this.cache);
    }
}
exports.InMemoryFullCacheStubCacheAdapterProvider = InMemoryFullCacheStubCacheAdapterProvider;
class InMemoryFullCacheStubCacheAdapter {
    entityConfiguration;
    cache;
    constructor(entityConfiguration, cache) {
        this.entityConfiguration = entityConfiguration;
        this.cache = cache;
    }
    async loadManyAsync(fieldName, fieldValues) {
        const results = new Map();
        fieldValues.forEach((fieldValue) => {
            const cacheKey = this.createCacheKey(fieldName, fieldValue);
            if (!this.cache.has(cacheKey)) {
                results.set(fieldValue, {
                    status: ReadThroughEntityCache_1.CacheStatus.MISS,
                });
            }
            else {
                const objectForFieldValue = this.cache.get(cacheKey);
                (0, invariant_1.default)(objectForFieldValue !== undefined, 'should have set value for key');
                results.set(fieldValue, {
                    status: ReadThroughEntityCache_1.CacheStatus.HIT,
                    item: objectForFieldValue,
                });
            }
        });
        return results;
    }
    async cacheManyAsync(fieldName, objectMap) {
        objectMap.forEach((obj, fieldValue) => {
            const cacheKey = this.createCacheKey(fieldName, fieldValue);
            this.cache.set(cacheKey, obj);
        });
    }
    async cacheDBMissesAsync(_fieldName, _fieldValues) { }
    async invalidateManyAsync(fieldName, fieldValues) {
        fieldValues.forEach((fieldValue) => {
            const cacheKey = this.createCacheKey(fieldName, fieldValue);
            this.cache.delete(cacheKey);
        });
    }
    createCacheKey(fieldName, fieldValue) {
        return [
            this.entityConfiguration.tableName,
            `v${this.entityConfiguration.cacheKeyVersion}`,
            fieldName,
            String(fieldValue),
        ].join(':');
    }
}
exports.InMemoryFullCacheStubCacheAdapter = InMemoryFullCacheStubCacheAdapter;
//# sourceMappingURL=StubCacheAdapter.js.map