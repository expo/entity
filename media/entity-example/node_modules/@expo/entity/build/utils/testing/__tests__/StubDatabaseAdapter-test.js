"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_mockito_1 = require("ts-mockito");
const EntityDatabaseAdapter_1 = require("../../../EntityDatabaseAdapter");
const EntityQueryContext_1 = require("../../../EntityQueryContext");
const DateIDTestEntity_1 = require("../../../testfixtures/DateIDTestEntity");
const SimpleTestEntity_1 = require("../../../testfixtures/SimpleTestEntity");
const TestEntity_1 = require("../../../testfixtures/TestEntity");
const TestEntityNumberKey_1 = require("../../../testfixtures/TestEntityNumberKey");
const StubDatabaseAdapter_1 = __importDefault(require("../StubDatabaseAdapter"));
describe(StubDatabaseAdapter_1.default, () => {
    describe('fetchManyWhereAsync', () => {
        it('fetches many where', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
                [
                    TestEntity_1.testEntityConfiguration.tableName,
                    [
                        {
                            customIdField: 'hello',
                            testIndexedField: 'h1',
                            intField: 5,
                            stringField: 'huh',
                            dateField: new Date(),
                            nullableField: null,
                        },
                        {
                            customIdField: 'world',
                            testIndexedField: 'h2',
                            intField: 3,
                            stringField: 'wat',
                            dateField: new Date(),
                            nullableField: null,
                        },
                    ],
                ],
            ])));
            const results = await databaseAdapter.fetchManyWhereAsync(queryContext, 'stringField', [
                'huh',
            ]);
            expect(results.get('huh')).toHaveLength(1);
        });
    });
    describe('fetchManyByFieldEqualityConjunctionAsync', () => {
        it('supports conjuntions and query modifiers', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
                [
                    TestEntity_1.testEntityConfiguration.tableName,
                    [
                        {
                            customIdField: 'hello',
                            testIndexedField: 'h1',
                            intField: 3,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: null,
                        },
                        {
                            customIdField: 'world',
                            testIndexedField: 'h2',
                            intField: 3,
                            stringField: 'b',
                            dateField: new Date(),
                            nullableField: null,
                        },
                        {
                            customIdField: 'world',
                            testIndexedField: 'h2',
                            intField: 3,
                            stringField: 'c',
                            dateField: new Date(),
                            nullableField: null,
                        },
                    ],
                ],
            ])));
            const results = await databaseAdapter.fetchManyByFieldEqualityConjunctionAsync(queryContext, [
                {
                    fieldName: 'customIdField',
                    fieldValues: ['hello', 'world'],
                },
                {
                    fieldName: 'intField',
                    fieldValue: 3,
                },
            ], {
                limit: 2,
                offset: 1,
                orderBy: [
                    {
                        fieldName: 'stringField',
                        order: EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING,
                    },
                ],
            });
            expect(results).toHaveLength(2);
            expect(results.map((e) => e.stringField)).toEqual(['b', 'a']);
        });
        it('supports multiple order bys', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
                [
                    TestEntity_1.testEntityConfiguration.tableName,
                    [
                        {
                            customIdField: 'hello',
                            testIndexedField: 'h1',
                            intField: 3,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: null,
                        },
                        {
                            customIdField: 'world',
                            testIndexedField: 'h2',
                            intField: 3,
                            stringField: 'b',
                            dateField: new Date(),
                            nullableField: null,
                        },
                        {
                            customIdField: 'world',
                            testIndexedField: 'h2',
                            intField: 3,
                            stringField: 'c',
                            dateField: new Date(),
                            nullableField: null,
                        },
                    ],
                ],
            ])));
            const results = await databaseAdapter.fetchManyByFieldEqualityConjunctionAsync(queryContext, [
                {
                    fieldName: 'intField',
                    fieldValue: 3,
                },
            ], {
                orderBy: [
                    {
                        fieldName: 'intField',
                        order: EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING,
                    },
                    {
                        fieldName: 'stringField',
                        order: EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING,
                    },
                ],
            });
            expect(results).toHaveLength(3);
            expect(results.map((e) => e.stringField)).toEqual(['c', 'b', 'a']);
        });
        it('supports null field values', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
                [
                    TestEntity_1.testEntityConfiguration.tableName,
                    [
                        {
                            customIdField: '1',
                            testIndexedField: 'h1',
                            intField: 1,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: 'a',
                        },
                        {
                            customIdField: '2',
                            testIndexedField: 'h2',
                            intField: 2,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: 'b',
                        },
                        {
                            customIdField: '3',
                            testIndexedField: 'h3',
                            intField: 3,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: null,
                        },
                        {
                            customIdField: '4',
                            testIndexedField: 'h4',
                            intField: 4,
                            stringField: 'b',
                            dateField: new Date(),
                            nullableField: null,
                        },
                    ],
                ],
            ])));
            const results = await databaseAdapter.fetchManyByFieldEqualityConjunctionAsync(queryContext, [{ fieldName: 'nullableField', fieldValue: null }], {});
            expect(results).toHaveLength(2);
            expect(results[0].nullableField).toBeNull();
            const results2 = await databaseAdapter.fetchManyByFieldEqualityConjunctionAsync(queryContext, [
                { fieldName: 'nullableField', fieldValues: ['a', null] },
                { fieldName: 'stringField', fieldValue: 'a' },
            ], {
                orderBy: [
                    {
                        fieldName: 'nullableField',
                        order: EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING,
                    },
                ],
            });
            expect(results2).toHaveLength(2);
            expect(results2.map((e) => e.nullableField)).toEqual([null, 'a']);
        });
    });
    describe('fetchManyByRawWhereClauseAsync', () => {
        it('throws because it is unsupported', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, new Map());
            await expect(databaseAdapter.fetchManyByRawWhereClauseAsync(queryContext, '', [], {})).rejects.toThrow();
        });
    });
    describe('insertAsync', () => {
        it('inserts a record', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, new Map());
            const result = await databaseAdapter.insertAsync(queryContext, {
                stringField: 'hello',
            });
            expect(result).toMatchObject({
                stringField: 'hello',
            });
            expect(databaseAdapter.getObjectCollectionForTable(TestEntity_1.testEntityConfiguration.tableName)).toHaveLength(1);
        });
        it('inserts a record with valid v7 id', async () => {
            const expectedTime = new Date('2024-06-03T20:16:33.761Z');
            jest.useFakeTimers({
                now: expectedTime,
            });
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, new Map());
            const result = await databaseAdapter.insertAsync(queryContext, {
                stringField: 'hello',
            });
            const ts = getTimeFromUUIDv7(result.customIdField);
            expect(ts).toEqual(expectedTime);
        });
    });
    describe('updateAsync', () => {
        it('updates a record', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
                [
                    TestEntity_1.testEntityConfiguration.tableName,
                    [
                        {
                            customIdField: 'hello',
                            testIndexedField: 'h1',
                            intField: 3,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: null,
                        },
                    ],
                ],
            ])));
            const result = await databaseAdapter.updateAsync(queryContext, 'customIdField', 'hello', {
                stringField: 'b',
            });
            expect(result).toMatchObject({
                stringField: 'b',
                testIndexedField: 'h1',
            });
        });
        it('throws error when empty update to match common DBMS behavior', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
                [
                    TestEntity_1.testEntityConfiguration.tableName,
                    [
                        {
                            customIdField: 'hello',
                            testIndexedField: 'h1',
                            intField: 3,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: null,
                        },
                    ],
                ],
            ])));
            await expect(databaseAdapter.updateAsync(queryContext, 'customIdField', 'hello', {})).rejects.toThrowError(`Empty update (custom_id = hello)`);
        });
    });
    describe('deleteAsync', () => {
        it('deletes an object', async () => {
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
                [
                    TestEntity_1.testEntityConfiguration.tableName,
                    [
                        {
                            customIdField: 'hello',
                            testIndexedField: 'h1',
                            intField: 3,
                            stringField: 'a',
                            dateField: new Date(),
                            nullableField: null,
                        },
                    ],
                ],
            ])));
            await databaseAdapter.deleteAsync(queryContext, 'customIdField', 'hello');
            expect(databaseAdapter.getObjectCollectionForTable(TestEntity_1.testEntityConfiguration.tableName)).toHaveLength(0);
        });
    });
    it('supports string and number IDs', async () => {
        const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
        const databaseAdapter1 = new StubDatabaseAdapter_1.default(SimpleTestEntity_1.simpleTestEntityConfiguration, new Map());
        const insertedObject1 = await databaseAdapter1.insertAsync(queryContext, {});
        expect(typeof insertedObject1.id).toBe('string');
        const databaseAdapter2 = new StubDatabaseAdapter_1.default(TestEntityNumberKey_1.numberKeyEntityConfiguration, new Map());
        const insertedObject2 = await databaseAdapter2.insertAsync(queryContext, {});
        expect(typeof insertedObject2.id).toBe('number');
        const databaseAdapter3 = new StubDatabaseAdapter_1.default(DateIDTestEntity_1.dateIDTestEntityConfiguration, new Map());
        await expect(databaseAdapter3.insertAsync(queryContext, {})).rejects.toThrowError('Unsupported ID type for StubDatabaseAdapter: DateField');
    });
    describe('compareByOrderBys', () => {
        describe('comparison', () => {
            it.each([
                // nulls compare with 0
                [EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING, null, 0, -1],
                [EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING, null, 0, 1],
                [EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING, 0, null, 1],
                [EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING, 0, null, -1],
                // nulls compare with nulls
                [EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING, null, null, 0],
                [EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING, null, null, 0],
                // nulls compare with -1
                [EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING, null, -1, -1],
                [EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING, null, -1, 1],
                [EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING, -1, null, 1],
                [EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING, -1, null, -1],
                // basic compares
                [EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING, 'a', 'b', -1],
                [EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING, 'b', 'a', 1],
                [EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING, 'a', 'b', 1],
                [EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING, 'b', 'a', -1],
            ])('case (%p; %p; %p)', (order, v1, v2, expectedResult) => {
                expect(StubDatabaseAdapter_1.default['compareByOrderBys']([
                    {
                        columnName: 'hello',
                        order,
                    },
                ], {
                    hello: v1,
                }, {
                    hello: v2,
                })).toEqual(expectedResult);
            });
            it('works for empty', () => {
                expect(StubDatabaseAdapter_1.default['compareByOrderBys']([], {
                    hello: 'test',
                }, {
                    hello: 'blah',
                })).toEqual(0);
            });
        });
        describe('recursing', () => {
            expect(StubDatabaseAdapter_1.default['compareByOrderBys']([
                {
                    columnName: 'hello',
                    order: EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING,
                },
                {
                    columnName: 'world',
                    order: EntityDatabaseAdapter_1.OrderByOrdering.ASCENDING,
                },
            ], {
                hello: 'a',
                world: 1,
            }, {
                hello: 'a',
                world: 2,
            })).toEqual(-1);
        });
    });
});
const UUIDV7_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
/**
 * Returns the Date object encoded in the first 48 bits of the given UUIDv7.
 * @throws TypeError if the UUID is not version 7
 */
function getTimeFromUUIDv7(uuid) {
    if (!UUIDV7_REGEX.test(uuid)) {
        throw new TypeError(`UUID must be version 7 to get its timestamp`);
    }
    // The first 48 bits = 12 hex characters of the UUID encode the timestamp in big endian
    const hexCharacters = uuid.replaceAll('-', '').split('', 12);
    const milliseconds = hexCharacters.reduce((milliseconds, character) => milliseconds * 16 + parseInt(character, 16), 0);
    return new Date(milliseconds);
}
//# sourceMappingURL=StubDatabaseAdapter-test.js.map