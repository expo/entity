import Entity, { IEntityClass } from '../Entity';
import EntityPrivacyPolicy from '../EntityPrivacyPolicy';
import { EntityQueryContext } from '../EntityQueryContext';
import ViewerContext from '../ViewerContext';
/**
 * Check whether an entity loaded by a viewer can be updated by that same viewer.
 *
 * @remarks
 *
 * This may be useful in situations relying upon the thrown privacy policy thrown authorization error
 * is insufficient for the task at hand. When dealing with purely a sequence of mutations it is easy
 * to roll back all mutations given a single authorization error by wrapping them in a single transaction.
 * When certain portions of a mutation cannot be rolled back transactionally (third pary calls,
 * legacy code, etc), using this method can help decide whether the sequence of mutations will fail before
 * attempting them. Note that if any privacy policy rules use a piece of data being updated in the mutations
 * the result of this method and the update mutation itself may differ.
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
export declare function canViewerUpdateAsync<TMFields extends object, TMID extends NonNullable<TMFields[TMSelectedFields]>, TMViewerContext extends ViewerContext, TMEntity extends Entity<TMFields, TMID, TMViewerContext, TMSelectedFields>, TMPrivacyPolicy extends EntityPrivacyPolicy<TMFields, TMID, TMViewerContext, TMEntity, TMSelectedFields>, TMSelectedFields extends keyof TMFields = keyof TMFields>(entityClass: IEntityClass<TMFields, TMID, TMViewerContext, TMEntity, TMPrivacyPolicy, TMSelectedFields>, sourceEntity: TMEntity, queryContext?: EntityQueryContext): Promise<boolean>;
/**
 * Check whether a single entity loaded by a viewer can be deleted by that same viewer.
 * This recursively checks edge cascade permissions (EntityEdgeDeletionBehavior) as well.
 *
 * @remarks
 * See remarks for canViewerUpdate.
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
export declare function canViewerDeleteAsync<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TMViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TMViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TMViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields = keyof TFields>(entityClass: IEntityClass<TFields, TID, TMViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, sourceEntity: TEntity, queryContext?: EntityQueryContext): Promise<boolean>;
