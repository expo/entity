import Entity, { IEntityClass } from '../Entity';
import EntityPrivacyPolicy from '../EntityPrivacyPolicy';
import { EntityQueryContext } from '../EntityQueryContext';
import ViewerContext from '../ViewerContext';
import EntityNotAuthorizedError from '../errors/EntityNotAuthorizedError';
export type EntityPrivacyEvaluationResultSuccess = {
    allowed: true;
};
export type EntityPrivacyEvaluationResultFailure = {
    allowed: false;
    authorizationErrors: EntityNotAuthorizedError<any, any, any, any, any>[];
};
export type EntityPrivacyEvaluationResult = EntityPrivacyEvaluationResultSuccess | EntityPrivacyEvaluationResultFailure;
/**
 * Check whether an entity loaded by a viewer can be updated by that same viewer.
 *
 * @remarks
 *
 * This may be useful in situations relying upon the thrown privacy policy thrown authorization error
 * is insufficient for the task at hand. When dealing with purely a sequence of mutations it is easy
 * to roll back all mutations given a single authorization error by wrapping them in a single transaction.
 * When certain portions of a mutation cannot be rolled back transactionally (third pary calls,
 * legacy code, etc), using this method can help decide whether the sequence of mutations will fail before
 * attempting them. Note that if any privacy policy rules use a piece of data being updated in the mutations
 * the result of this method and the update mutation itself may differ.
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
export declare function canViewerUpdateAsync<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields = keyof TFields>(entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, sourceEntity: TEntity, queryContext?: EntityQueryContext): Promise<boolean>;
/**
 * Check whether an entity loaded by a viewer can be updated by that same viewer and return the evaluation result.
 *
 * @see canViewerUpdateAsync
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
export declare function getCanViewerUpdateResultAsync<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields = keyof TFields>(entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, sourceEntity: TEntity, queryContext?: EntityQueryContext): Promise<EntityPrivacyEvaluationResult>;
/**
 * Check whether a single entity loaded by a viewer can be deleted by that same viewer.
 * This recursively checks edge cascade permissions (EntityEdgeDeletionBehavior) as well.
 *
 * @see canViewerUpdateAsync
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
export declare function canViewerDeleteAsync<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields = keyof TFields>(entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, sourceEntity: TEntity, queryContext?: EntityQueryContext): Promise<boolean>;
/**
 * Check whether a single entity loaded by a viewer can be deleted by that same viewer and return the evaluation result.
 *
 * @see canViewerDeleteAsync
 *
 * @param entityClass - class of entity
 * @param sourceEntity - entity loaded by viewer
 * @param queryContext - query context in which to perform the check
 */
export declare function getCanViewerDeleteResultAsync<TFields extends object, TID extends NonNullable<TFields[TSelectedFields]>, TViewerContext extends ViewerContext, TEntity extends Entity<TFields, TID, TViewerContext, TSelectedFields>, TPrivacyPolicy extends EntityPrivacyPolicy<TFields, TID, TViewerContext, TEntity, TSelectedFields>, TSelectedFields extends keyof TFields = keyof TFields>(entityClass: IEntityClass<TFields, TID, TViewerContext, TEntity, TPrivacyPolicy, TSelectedFields>, sourceEntity: TEntity, queryContext?: EntityQueryContext): Promise<EntityPrivacyEvaluationResult>;
