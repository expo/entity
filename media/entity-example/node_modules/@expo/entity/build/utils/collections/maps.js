"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reduceMapAsync = exports.reduceMap = exports.invertMap = exports.zipToMap = exports.mapKeys = exports.mapMapAsync = exports.mapMap = exports.computeIfAbsent = void 0;
exports.filterMap = filterMap;
const invariant_1 = __importDefault(require("invariant"));
/**
 * If the specified key is not already associated with a value in this map, attempts to compute
 * its value using the given mapping function and enters it into this map unless null.
 *
 * @param map - map from which to get the key's value or compute and associate
 * @param key - key for which to get the value or with which the computed value is to be associated
 * @param mappingFunction - function to compute a value for key
 */
const computeIfAbsent = (map, key, mappingFunction) => {
    if (!map.has(key)) {
        const value = mappingFunction(key);
        map.set(key, value);
    }
    return map.get(key);
};
exports.computeIfAbsent = computeIfAbsent;
/**
 * Create a new Map by associating the value of mapper executed for each key in the source map.
 *
 * @param map - source map
 * @param mapper - function to compute a value in the resulting map for the source key and value
 */
const mapMap = (map, mapper) => {
    const resultingMap = new Map();
    for (const [k, v] of map) {
        resultingMap.set(k, mapper(v, k));
    }
    return resultingMap;
};
exports.mapMap = mapMap;
/**
 * Create a new Map by associating the value of mapper executed for each key in the source map.
 *
 * @param map - source map
 * @param mapper - asynchronous function to compute a value in the resulting map for the source key and value
 */
const mapMapAsync = async function (map, mapper) {
    const resultingMap = new Map();
    await Promise.all(Array.from(map.keys()).map(async (k) => {
        const initialValue = map.get(k);
        const result = await mapper(initialValue, k);
        resultingMap.set(k, result);
    }));
    return resultingMap;
};
exports.mapMapAsync = mapMapAsync;
/**
 * Create a new Map by associating the value of each key with mapper executed for each key in the source map.
 * The opposite of mapMap. In the event two source keys map to the same result key, the second source key's
 * value will overwrite the first, in which case the cardinality of the returned map may be smaller than the
 * source map's.
 *
 * @param map - source map
 * @param mapper - function to compute a key in the resulting map for the source key and value
 */
const mapKeys = (map, mapper) => {
    const resultingMap = new Map();
    for (const [k, v] of map) {
        resultingMap.set(mapper(k, v), v);
    }
    return resultingMap;
};
exports.mapKeys = mapKeys;
/**
 * Create a new Map from each member of keys to the corresponding member of values.
 *
 * @example
 * ```
 * zipToMap([1, 2], ['a', 'b']) => Map({1: 'a', 2: 'b'})
 * ```
 *
 * @param keys - keys
 * @param values - corresponding ordered values for keys
 */
const zipToMap = (keys, values) => {
    (0, invariant_1.default)(keys.length === values.length, `zipToMap input length mismatch: keys[${keys.length}], values[${values.length}]`);
    const resultingMap = new Map();
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        resultingMap.set(key, values[i]);
    }
    return resultingMap;
};
exports.zipToMap = zipToMap;
/**
 * Create a new Map by inverting keys and values of specified map.
 *
 * @param map - map to invert
 */
const invertMap = (map) => {
    const resultingMap = new Map();
    for (const [k, v] of map) {
        resultingMap.set(v, k);
    }
    return resultingMap;
};
exports.invertMap = invertMap;
/**
 * Execute a reducer function on each element of the source map, resulting in a single output value.
 *
 * @param map - source map
 * @param reducer - reducer function that takes an accumulated value, current iteration value, and current
 *                  iteration key and returns a new accumulated value
 * @param initialValue - initial accumulated value
 */
const reduceMap = (map, reducer, initialValue) => {
    let newAccumulator = initialValue;
    for (const [k, v] of map) {
        newAccumulator = reducer(newAccumulator, v, k);
    }
    return newAccumulator;
};
exports.reduceMap = reduceMap;
/**
 * Execute an asynchronous reducer function on each element of the source map, resulting in a single output value.
 * Note that this does not parallelize asynchronous reduce steps so it should be used with caution.
 *
 * @param map - source map
 * @param reducer - asynchronous reducer function that takes an accumulated value, current iteration value, and
 *                  current iteration key and returns a new accumulated value
 * @param initialValue - initial accumulated value
 */
const reduceMapAsync = async (map, reducer, initialValue) => {
    let newAccumulator = initialValue;
    for (const [k, v] of map) {
        newAccumulator = await reducer(newAccumulator, v, k);
    }
    return newAccumulator;
};
exports.reduceMapAsync = reduceMapAsync;
/**
 * Create a new Map containing all elements from the source map that pass the provided test predicate.
 * @param map - source map
 * @param predicate - function to test each element of source map
 */
function filterMap(map, predicate) {
    const resultingMap = new Map();
    map.forEach((v, k) => {
        if (predicate(v, k)) {
            resultingMap.set(k, v);
        }
    });
    return resultingMap;
}
//# sourceMappingURL=maps.js.map