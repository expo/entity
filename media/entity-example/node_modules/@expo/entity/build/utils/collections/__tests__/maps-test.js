"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const maps_1 = require("../maps");
describe(maps_1.computeIfAbsent, () => {
    it('computes a value when absent', () => {
        const map = new Map();
        const blah = (0, maps_1.computeIfAbsent)(map, 'hello', () => 'world');
        expect(blah).toEqual(map.get('hello'));
    });
    it('does not compute a value when already present', () => {
        const map = new Map([['hello', 'world']]);
        let didCompute = false;
        const blah = (0, maps_1.computeIfAbsent)(map, 'hello', () => {
            didCompute = true;
            return 'world2';
        });
        expect(blah).toEqual(map.get('hello'));
        expect(didCompute).toBe(false);
    });
});
describe(maps_1.mapMap, () => {
    it('maps a map', () => {
        const map = new Map([['hello', 'world']]);
        const map2 = (0, maps_1.mapMap)(map, () => 2);
        expect(map2.get('hello')).toEqual(2);
    });
});
describe(maps_1.mapMapAsync, () => {
    it('maps a map with async mapper', async () => {
        const map = new Map([['hello', 'world']]);
        const map2 = await (0, maps_1.mapMapAsync)(map, async () => await Promise.resolve(2));
        expect(map2.get('hello')).toEqual(2);
    });
});
describe(maps_1.mapKeys, () => {
    it('maps keys', async () => {
        const map = new Map([
            ['hello', 'world'],
            ['amphibian', 'creature'],
        ]);
        const map2 = await (0, maps_1.mapKeys)(map, (k) => k.length);
        expect(map2.size).toEqual(2);
        expect(map2.get(5)).toEqual('world');
        expect(map2.get(9)).toEqual('creature');
    });
});
describe(maps_1.zipToMap, () => {
    it('zips keys to values', () => {
        const keys = [1, 2, 3];
        const values = ['a', 'b', 'c'];
        const map = (0, maps_1.zipToMap)(keys, values);
        expect(map.get(2)).toEqual('b');
    });
    it('throws when input lengths mismatch', () => {
        const keys = [1, 2];
        const values = [1];
        expect(() => (0, maps_1.zipToMap)(keys, values)).toThrowError('zipToMap input length mismatch: keys[2], values[1]');
    });
});
describe(maps_1.invertMap, () => {
    it('inverts a map', () => {
        const map = new Map([
            [1, 'world'],
            [2, 'what'],
        ]);
        const inverted = (0, maps_1.invertMap)(map);
        expect(inverted.get('world')).toEqual(1);
    });
    it('keeps last inverted key instance', () => {
        const map = new Map([
            [1, 'world'],
            [2, 'world'],
        ]);
        const inverted = (0, maps_1.invertMap)(map);
        expect(inverted.get('world')).toEqual(2);
    });
});
describe(maps_1.reduceMap, () => {
    it('reduces a map', () => {
        const map = new Map([
            ['a', 'a'],
            ['b', 'b'],
        ]);
        const reduction = (0, maps_1.reduceMap)(map, (acc, v, k) => acc.concat(v).concat(k), 'initial-');
        expect(reduction).toEqual('initial-aabb');
    });
});
describe(maps_1.reduceMapAsync, () => {
    it('reduces a map (async)', async () => {
        const map = new Map([
            ['a', 'a'],
            ['b', 'b'],
        ]);
        const reduction = await (0, maps_1.reduceMapAsync)(map, async (acc, v, k) => acc.concat(v).concat(k), 'initial-');
        expect(reduction).toEqual('initial-aabb');
    });
});
describe(maps_1.filterMap, () => {
    it('filters a map', () => {
        const map = new Map([
            ['a', false],
            ['b', true],
        ]);
        const filteredMap = (0, maps_1.filterMap)(map, (v) => v);
        expect(filteredMap.get('a')).toBeUndefined();
        expect(filteredMap.get('b')).toBe(true);
    });
    it('can use predicates', () => {
        function truthy(value) {
            return !!value;
        }
        const map = new Map([
            ['a', 'yes'],
            ['b', null],
        ]);
        const filteredMap = (0, maps_1.filterMap)(map, truthy);
        expect(filteredMap.size).toBe(1);
    });
});
//# sourceMappingURL=maps-test.js.map