import EntityQueryContextProvider from './EntityQueryContextProvider';
export type PostCommitCallback = (...args: any) => Promise<any>;
export type PreCommitCallback = (queryContext: EntityTransactionalQueryContext, ...args: any) => Promise<any>;
export declare enum TransactionIsolationLevel {
    READ_COMMITTED = "READ_COMMITTED",
    REPEATABLE_READ = "REPEATABLE_READ",
    SERIALIZABLE = "SERIALIZABLE"
}
export type TransactionConfig = {
    isolationLevel?: TransactionIsolationLevel;
};
/**
 * Entity framework representation of transactional and non-transactional database
 * query execution units.
 *
 * The behavior of EntityMutator and EntityLoader
 * differs when in a transactional context.
 */
export declare abstract class EntityQueryContext {
    private readonly queryInterface;
    constructor(queryInterface: any);
    abstract isInTransaction(): boolean;
    getQueryInterface(): any;
    abstract runInTransactionIfNotInTransactionAsync<T>(transactionScope: (queryContext: EntityTransactionalQueryContext) => Promise<T>, transactionConfig?: TransactionConfig): Promise<T>;
}
/**
 * Entity framework representation of a non-transactional query execution unit.
 * When supplied to EntityMutator and EntityLoader methods, they will be
 * run independently of any running transaction (though mutations start their own
 * independent transactions internally when not being run in a transaction).
 */
export declare class EntityNonTransactionalQueryContext extends EntityQueryContext {
    private readonly entityQueryContextProvider;
    constructor(queryInterface: any, entityQueryContextProvider: EntityQueryContextProvider);
    isInTransaction(): boolean;
    runInTransactionIfNotInTransactionAsync<T>(transactionScope: (queryContext: EntityTransactionalQueryContext) => Promise<T>, transactionConfig?: TransactionConfig): Promise<T>;
}
/**
 * Entity framework representation of a transactional query execution unit. When supplied
 * to EntityMutator and EntityLoader methods, those methods and their
 * dependent triggers and validators will run within the transaction.
 */
export declare class EntityTransactionalQueryContext extends EntityQueryContext {
    private readonly entityQueryContextProvider;
    private readonly postCommitInvalidationCallbacks;
    private readonly postCommitCallbacks;
    private readonly preCommitCallbacks;
    constructor(queryInterface: any, entityQueryContextProvider: EntityQueryContextProvider);
    /**
     * Schedule a pre-commit callback. These will be run within the transaction right before it is
     * committed, and will be run in the order specified. Ordering of callbacks scheduled with the
     * same value for the order parameter is undefined within that ordering group.
     * @param callback - callback to schedule
     * @param order - order in which this should be run relative to other scheduled pre-commit callbacks,
     *                with higher numbers running later than lower numbers.
     */
    appendPreCommitCallback(callback: PreCommitCallback, order: number): void;
    /**
     * Schedule a post-commit cache invalidation callback. These are run before normal
     * post-commit callbacks in order to have cache consistency in normal post-commit callbacks.
     * @param callback - callback to schedule
     */
    appendPostCommitInvalidationCallback(callback: PostCommitCallback): void;
    /**
     * Schedule a post-commit callback. These will be run after the transaction has
     * been committed.
     * @param callback - callback to schedule
     */
    appendPostCommitCallback(callback: PostCommitCallback): void;
    runPreCommitCallbacksAsync(): Promise<void>;
    runPostCommitCallbacksAsync(): Promise<void>;
    isInTransaction(): boolean;
    runInTransactionIfNotInTransactionAsync<T>(transactionScope: (queryContext: EntityTransactionalQueryContext) => Promise<T>, transactionConfig?: TransactionConfig): Promise<T>;
    runInNestedTransactionAsync<T>(transactionScope: (innerQueryContext: EntityTransactionalQueryContext) => Promise<T>): Promise<T>;
}
/**
 * Entity framework representation of a nested transactional query execution unit. When supplied
 * to EntityMutator and EntityLoader methods, those methods and their
 * dependent triggers and validators will run within the nested transaction.
 *
 * This exists to forward post-commit callbacks to the parent query context but only after
 * successful commit of the nested transaction.
 */
export declare class EntityNestedTransactionalQueryContext extends EntityTransactionalQueryContext {
    private readonly parentQueryContext;
    private readonly postCommitInvalidationCallbacksToTransfer;
    private readonly postCommitCallbacksToTransfer;
    constructor(queryInterface: any, parentQueryContext: EntityTransactionalQueryContext, entityQueryContextProvider: EntityQueryContextProvider);
    appendPostCommitCallback(callback: PostCommitCallback): void;
    appendPostCommitInvalidationCallback(callback: PostCommitCallback): void;
    runPostCommitCallbacksAsync(): Promise<void>;
    transferPostCommitCallbacksToParent(): void;
}
