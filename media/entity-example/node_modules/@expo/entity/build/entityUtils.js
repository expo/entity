"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pick = exports.partitionErrors = exports.partitionArray = exports.failedResultsFilterMap = exports.successfulResultsFilterMap = exports.failedResults = exports.successfulResults = exports.enforceResultsAsync = void 0;
/**
 * Enforce an array of results resolved from supplied promise.
 * @param resultsPromise - promise returning an array of results to enforce
 */
const enforceResultsAsync = async (resultsPromise) => {
    const results = await resultsPromise;
    return results.map((result) => result.enforceValue());
};
exports.enforceResultsAsync = enforceResultsAsync;
/**
 * Filter out unsuccessful results.
 * @param results - array of results to filter
 */
const successfulResults = (results) => {
    const ret = [];
    for (const result of results) {
        if (result.ok) {
            ret.push(result);
        }
    }
    return ret;
};
exports.successfulResults = successfulResults;
/**
 * Filter out successful results.
 * @param results - array of results to filter
 */
const failedResults = (results) => {
    const ret = [];
    for (const result of results) {
        if (!result.ok) {
            ret.push(result);
        }
    }
    return ret;
};
exports.failedResults = failedResults;
/**
 * Filter out failed results from a map with result values.
 * @param results - map of results to filter.
 */
const successfulResultsFilterMap = (results) => {
    const ret = new Map();
    for (const [k, result] of results) {
        if (result.ok) {
            ret.set(k, result);
        }
    }
    return ret;
};
exports.successfulResultsFilterMap = successfulResultsFilterMap;
/**
 * Filter out successful results from a map with result values.
 * @param results - map of results to filter.
 */
const failedResultsFilterMap = (results) => {
    const ret = new Map();
    for (const [k, result] of results) {
        if (!result.ok) {
            ret.set(k, result);
        }
    }
    return ret;
};
exports.failedResultsFilterMap = failedResultsFilterMap;
/**
 * Partition an array of values into two arrays based on evaluation of a binary predicate.
 * @param values - array of values to partition
 * @param predicate - binary predicate to evaluate partition group of each value
 */
const partitionArray = (values, predicate) => {
    const ts = [];
    const us = [];
    for (const value of values) {
        if (predicate(value)) {
            ts.push(value);
        }
        else {
            us.push(value);
        }
    }
    return [ts, us];
};
exports.partitionArray = partitionArray;
/**
 * Partition array of values and errors into an array of values and an array of errors.
 * @param valuesAndErrors - array of values and errors
 */
const partitionErrors = (valuesAndErrors) => {
    const [errors, values] = (0, exports.partitionArray)(valuesAndErrors, isError);
    return [values, errors];
};
exports.partitionErrors = partitionErrors;
const isError = (value) => {
    return value instanceof Error;
};
const pick = (object, props) => {
    const propsSet = new Set(props);
    return Object.fromEntries(Object.entries(object).filter((entry) => propsSet.has(entry[0])));
};
exports.pick = pick;
//# sourceMappingURL=entityUtils.js.map