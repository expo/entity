"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nullthrows_1 = __importDefault(require("nullthrows"));
const ReadThroughEntityCache_1 = require("./internal/ReadThroughEntityCache");
/**
 * A IEntityCacheAdapter that composes other IEntityCacheAdapter instances.
 */
class ComposedEntityCacheAdapter {
    cacheAdapters;
    /**
     * @param cacheAdapters - list of cache adapters to compose in order of precedence.
     *                        Earlier cache adapters are read from first and written to (including invalidations) last.
     *                        Typically, caches closer to the application should be ordered before caches closer to the database.
     *                        A lower layer cache is closer to the database, while a higher layer cache is closer to the application.
     */
    constructor(cacheAdapters) {
        this.cacheAdapters = cacheAdapters;
    }
    async loadManyAsync(fieldName, fieldValues) {
        const retMap = new Map();
        const fulfilledFieldValuesByCacheIndex = Array.from({ length: this.cacheAdapters.length }, () => []);
        let unfulfilledFieldValues = fieldValues;
        for (let i = 0; i < this.cacheAdapters.length; i++) {
            const cacheAdapter = (0, nullthrows_1.default)(this.cacheAdapters[i]);
            const cacheResultsFromAdapter = await cacheAdapter.loadManyAsync(fieldName, unfulfilledFieldValues);
            const newUnfulfilledFieldValues = [];
            for (const [fieldValue, cacheResult] of cacheResultsFromAdapter) {
                if (cacheResult.status === ReadThroughEntityCache_1.CacheStatus.MISS) {
                    newUnfulfilledFieldValues.push(fieldValue);
                }
                else {
                    retMap.set(fieldValue, cacheResult);
                    (0, nullthrows_1.default)(fulfilledFieldValuesByCacheIndex[i]).push(fieldValue);
                }
            }
            unfulfilledFieldValues = newUnfulfilledFieldValues;
            if (unfulfilledFieldValues.length === 0) {
                break;
            }
        }
        // Recache values from lower layers that were not found in higher layers
        // Write to lower layers first
        for (let i = this.cacheAdapters.length - 1; i >= 0; i--) {
            const cacheAdapter = (0, nullthrows_1.default)(this.cacheAdapters[i]);
            const hitsToCache = new Map();
            const negativesToCache = [];
            // Loop over all lower layer caches to collect hits and misses
            for (let j = i + 1; j < this.cacheAdapters.length; j++) {
                const fulfilledFieldValues = (0, nullthrows_1.default)(fulfilledFieldValuesByCacheIndex[j]);
                fulfilledFieldValues.forEach((fieldValue) => {
                    const cacheResult = (0, nullthrows_1.default)(retMap.get(fieldValue));
                    if (cacheResult.status === ReadThroughEntityCache_1.CacheStatus.HIT) {
                        hitsToCache.set(fieldValue, cacheResult.item);
                    }
                    else if (cacheResult.status === ReadThroughEntityCache_1.CacheStatus.NEGATIVE) {
                        negativesToCache.push(fieldValue);
                    }
                });
            }
            const promises = [];
            if (hitsToCache.size > 0) {
                promises.push(cacheAdapter.cacheManyAsync(fieldName, hitsToCache));
            }
            if (negativesToCache.length > 0) {
                promises.push(cacheAdapter.cacheDBMissesAsync(fieldName, negativesToCache));
            }
            await Promise.all(promises);
        }
        for (const fieldValue of unfulfilledFieldValues) {
            retMap.set(fieldValue, { status: ReadThroughEntityCache_1.CacheStatus.MISS });
        }
        return retMap;
    }
    async cacheManyAsync(fieldName, objectMap) {
        // write to lower layers first
        for (let i = this.cacheAdapters.length - 1; i >= 0; i--) {
            const cacheAdapter = (0, nullthrows_1.default)(this.cacheAdapters[i]);
            await cacheAdapter.cacheManyAsync(fieldName, objectMap);
        }
    }
    async cacheDBMissesAsync(fieldName, fieldValues) {
        // write to lower layers first
        for (let i = this.cacheAdapters.length - 1; i >= 0; i--) {
            const cacheAdapter = (0, nullthrows_1.default)(this.cacheAdapters[i]);
            await cacheAdapter.cacheDBMissesAsync(fieldName, fieldValues);
        }
    }
    async invalidateManyAsync(fieldName, fieldValues) {
        // delete from lower layers first
        for (let i = this.cacheAdapters.length - 1; i >= 0; i--) {
            const cacheAdapter = (0, nullthrows_1.default)(this.cacheAdapters[i]);
            await cacheAdapter.invalidateManyAsync(fieldName, fieldValues);
        }
    }
}
exports.default = ComposedEntityCacheAdapter;
//# sourceMappingURL=ComposedEntityCacheAdapter.js.map