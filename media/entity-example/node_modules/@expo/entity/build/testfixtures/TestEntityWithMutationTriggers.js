"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonTransactionalTestMutationTrigger = exports.TestMutationTrigger = exports.TestEntityMTPrivacyPolicy = exports.testEntityMTConfiguration = void 0;
const Entity_1 = __importDefault(require("../Entity"));
const EntityConfiguration_1 = __importDefault(require("../EntityConfiguration"));
const EntityFields_1 = require("../EntityFields");
const EntityMutationTriggerConfiguration_1 = require("../EntityMutationTriggerConfiguration");
const EntityPrivacyPolicy_1 = __importDefault(require("../EntityPrivacyPolicy"));
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysAllowPrivacyPolicyRule"));
exports.testEntityMTConfiguration = new EntityConfiguration_1.default({
    idField: 'id',
    tableName: 'test_entity_should_not_write_to_db_3',
    schema: {
        id: new EntityFields_1.UUIDField({
            columnName: 'id',
        }),
        stringField: new EntityFields_1.StringField({
            columnName: 'string_field',
        }),
    },
    databaseAdapterFlavor: 'postgres',
    cacheAdapterFlavor: 'redis',
});
class TestEntityMTPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
exports.TestEntityMTPrivacyPolicy = TestEntityMTPrivacyPolicy;
class TestMutationTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
    key;
    constructor(
    // @ts-expect-error key is never used but is helpful for debugging
    key) {
        super();
        this.key = key;
    }
    async executeAsync(_viewerContext, _queryContext, _entity, _mutationInfo) { }
}
exports.TestMutationTrigger = TestMutationTrigger;
class NonTransactionalTestMutationTrigger extends EntityMutationTriggerConfiguration_1.EntityNonTransactionalMutationTrigger {
    key;
    constructor(
    // @ts-expect-error key is never used but is helpful for debugging
    key) {
        super();
        this.key = key;
    }
    async executeAsync(_viewerContext, _entity, _mutationInfo) { }
}
exports.NonTransactionalTestMutationTrigger = NonTransactionalTestMutationTrigger;
/**
 * A test Entity that has one afterCreate and one afterAll trigger
 */
class TestEntityWithMutationTriggers extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: TestEntityWithMutationTriggers,
            entityConfiguration: exports.testEntityMTConfiguration,
            privacyPolicyClass: TestEntityMTPrivacyPolicy,
            mutationTriggers: {
                afterCreate: [new TestMutationTrigger('localAfterCreate')],
                afterAll: [new TestMutationTrigger('localAfterAll')],
                afterCommit: [new NonTransactionalTestMutationTrigger('localAfterCommit')],
            },
        };
    }
}
exports.default = TestEntityWithMutationTriggers;
//# sourceMappingURL=TestEntityWithMutationTriggers.js.map