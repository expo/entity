"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
const nullthrows_1 = __importDefault(require("nullthrows"));
const entityUtils_1 = require("./entityUtils");
const maps_1 = require("./utils/collections/maps");
/**
 * Entity loader utilities for things like invalidation, entity construction, and authorization.
 * Methods are exposed publicly since in rare cases they may need to be called manually.
 */
class EntityLoaderUtils {
    viewerContext;
    queryContext;
    privacyPolicyEvaluationContext;
    entityConfiguration;
    entityClass;
    entitySelectedFields;
    privacyPolicy;
    dataManager;
    metricsAdapter;
    constructor(viewerContext, queryContext, privacyPolicyEvaluationContext, entityConfiguration, entityClass, entitySelectedFields, privacyPolicy, dataManager, metricsAdapter) {
        this.viewerContext = viewerContext;
        this.queryContext = queryContext;
        this.privacyPolicyEvaluationContext = privacyPolicyEvaluationContext;
        this.entityConfiguration = entityConfiguration;
        this.entityClass = entityClass;
        this.entitySelectedFields = entitySelectedFields;
        this.privacyPolicy = privacyPolicy;
        this.dataManager = dataManager;
        this.metricsAdapter = metricsAdapter;
    }
    /**
     * Invalidate all caches for an entity's fields. Exposed primarily for internal use by EntityMutator.
     * @param objectFields - entity data object to be invalidated
     */
    async invalidateFieldsAsync(objectFields) {
        await this.dataManager.invalidateObjectFieldsAsync(objectFields);
    }
    /**
     * Invalidate all caches for an entity. One potential use case would be to keep the entity
     * framework in sync with changes made to data outside of the framework.
     * @param entity - entity to be invalidated
     */
    async invalidateEntityAsync(entity) {
        await this.invalidateFieldsAsync(entity.getAllDatabaseFields());
    }
    /**
     * Construct an entity from a fields object (applying field selection if applicable),
     * checking that the ID field is specified.
     *
     * @param fieldsObject - fields object
     */
    constructEntity(fieldsObject) {
        const idField = this.entityConfiguration.idField;
        const id = (0, nullthrows_1.default)(fieldsObject[idField], 'must provide ID to create an entity');
        const entitySelectedFields = this.entitySelectedFields ?? Array.from(this.entityConfiguration.schema.keys());
        const selectedFields = (0, entityUtils_1.pick)(fieldsObject, entitySelectedFields);
        return new this.entityClass({
            viewerContext: this.viewerContext,
            id: id,
            databaseFields: fieldsObject,
            selectedFields,
        });
    }
    /**
     * Construct and authorize entities from fields map, returning error results for entities that fail
     * to construct or fail to authorize.
     *
     * @param map - map from an arbitrary key type to an array of entity field objects
     */
    async constructAndAuthorizeEntitiesAsync(map) {
        return await (0, maps_1.mapMapAsync)(map, async (fieldObjects) => {
            return await this.constructAndAuthorizeEntitiesArrayAsync(fieldObjects);
        });
    }
    /**
     * Construct and authorize entities from field objects array, returning error results for entities that fail
     * to construct or fail to authorize.
     *
     * @param fieldObjects - array of field objects
     */
    async constructAndAuthorizeEntitiesArrayAsync(fieldObjects) {
        const uncheckedEntityResults = this.tryConstructEntities(fieldObjects);
        return await Promise.all(uncheckedEntityResults.map(async (uncheckedEntityResult) => {
            if (!uncheckedEntityResult.ok) {
                return uncheckedEntityResult;
            }
            return await (0, results_1.asyncResult)(this.privacyPolicy.authorizeReadAsync(this.viewerContext, this.queryContext, this.privacyPolicyEvaluationContext, uncheckedEntityResult.value, this.metricsAdapter));
        }));
    }
    tryConstructEntities(fieldsObjects) {
        return fieldsObjects.map((fieldsObject) => {
            try {
                return (0, results_1.result)(this.constructEntity(fieldsObject));
            }
            catch (e) {
                if (!(e instanceof Error)) {
                    throw e;
                }
                return (0, results_1.result)(e);
            }
        });
    }
}
exports.default = EntityLoaderUtils;
//# sourceMappingURL=EntityLoaderUtils.js.map