"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ReadonlyEntity_1 = __importDefault(require("./ReadonlyEntity"));
/**
 * Entity is a privacy-first data model.
 *
 * A instance of an entity represents a single "row" of persisted data in a database that a
 * viewer, represented by the corresponding ViewerContext, has permission to read.
 *
 * Create, read, update, and delete permissions for an entity are declaratively defined using an
 * EntityPrivacyPolicy.
 *
 * Entites are loaded through an EntityLoader, which is responsible for
 * orchestrating fetching, caching, and authorization of reading "rows".
 *
 * Entities are mutated and deleted through an EntityMutator, which is responsible for
 * orchestrating database writes, cache invalidation, and authorization of writing "rows".
 *
 * All concrete entity implementations should extend this class and provide their
 * own EntityCompanionDefinition.
 */
class Entity extends ReadonlyEntity_1.default {
    /**
     * Vend mutator for creating a new entity in given query context.
     * @param viewerContext - viewer context of creating user
     * @param queryContext - query context in which to perform the create
     * @returns mutator for creating an entity
     */
    static creator(viewerContext, queryContext = viewerContext
        .getViewerScopedEntityCompanionForClass(this)
        .getQueryContextProvider()
        .getQueryContext()) {
        return viewerContext
            .getViewerScopedEntityCompanionForClass(this)
            .getMutatorFactory()
            .forCreate(queryContext);
    }
    /**
     * Vend mutator for updating an existing entity in given query context.
     * @param existingEntity - entity to update
     * @param queryContext - query context in which to perform the update
     * @returns mutator for updating existingEntity
     */
    static updater(existingEntity, queryContext = existingEntity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(this)
        .getQueryContextProvider()
        .getQueryContext()) {
        return existingEntity
            .getViewerContext()
            .getViewerScopedEntityCompanionForClass(this)
            .getMutatorFactory()
            .forUpdate(existingEntity, queryContext);
    }
    /**
     * Delete an existing entity in given query context.
     * @param existingEntity - entity to delete
     * @param queryContext - query context in which to perform the delete
     */
    static deleteAsync(existingEntity, queryContext = existingEntity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(this)
        .getQueryContextProvider()
        .getQueryContext()) {
        return existingEntity
            .getViewerContext()
            .getViewerScopedEntityCompanionForClass(this)
            .getMutatorFactory()
            .forDelete(existingEntity, queryContext)
            .deleteAsync();
    }
    /**
     * Delete an existing entity in given query context, throwing if deletion is unsuccessful.
     * @param existingEntity - entity to delete
     * @param queryContext - query context in which to perform the delete
     */
    static enforceDeleteAsync(existingEntity, queryContext = existingEntity
        .getViewerContext()
        .getViewerScopedEntityCompanionForClass(this)
        .getQueryContextProvider()
        .getQueryContext()) {
        return existingEntity
            .getViewerContext()
            .getViewerScopedEntityCompanionForClass(this)
            .getMutatorFactory()
            .forDelete(existingEntity, queryContext)
            .enforceDeleteAsync();
    }
}
exports.default = Entity;
//# sourceMappingURL=Entity.js.map