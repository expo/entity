"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleteMutator = exports.UpdateMutator = exports.CreateMutator = void 0;
const results_1 = require("@expo/results");
const invariant_1 = __importDefault(require("invariant"));
const EntityFieldDefinition_1 = require("./EntityFieldDefinition");
const EntityMutationInfo_1 = require("./EntityMutationInfo");
const EntityInvalidFieldValueError_1 = __importDefault(require("./errors/EntityInvalidFieldValueError"));
const EntityMetricsUtils_1 = require("./metrics/EntityMetricsUtils");
const IEntityMetricsAdapter_1 = require("./metrics/IEntityMetricsAdapter");
const maps_1 = require("./utils/collections/maps");
class BaseMutator {
    companionProvider;
    viewerContext;
    queryContext;
    entityConfiguration;
    entityClass;
    privacyPolicy;
    mutationValidators;
    mutationTriggers;
    entityLoaderFactory;
    databaseAdapter;
    metricsAdapter;
    constructor(companionProvider, viewerContext, queryContext, entityConfiguration, entityClass, privacyPolicy, mutationValidators, mutationTriggers, entityLoaderFactory, databaseAdapter, metricsAdapter) {
        this.companionProvider = companionProvider;
        this.viewerContext = viewerContext;
        this.queryContext = queryContext;
        this.entityConfiguration = entityConfiguration;
        this.entityClass = entityClass;
        this.privacyPolicy = privacyPolicy;
        this.mutationValidators = mutationValidators;
        this.mutationTriggers = mutationTriggers;
        this.entityLoaderFactory = entityLoaderFactory;
        this.databaseAdapter = databaseAdapter;
        this.metricsAdapter = metricsAdapter;
    }
    validateFields(fields) {
        for (const fieldName in fields) {
            const fieldValue = fields[fieldName];
            const fieldDefinition = this.entityConfiguration.schema.get(fieldName);
            (0, invariant_1.default)(fieldDefinition, `must have field definition for field = ${fieldName}`);
            const isInputValid = fieldDefinition.validateInputValue(fieldValue);
            if (!isInputValid) {
                throw new EntityInvalidFieldValueError_1.default(this.entityClass, fieldName, fieldValue);
            }
        }
    }
    async executeMutationValidatorsAsync(validators, queryContext, entity, mutationInfo) {
        await Promise.all(validators.map((validator) => validator.executeAsync(this.viewerContext, queryContext, entity, mutationInfo)));
    }
    async executeMutationTriggersAsync(triggers, queryContext, entity, mutationInfo) {
        if (!triggers) {
            return;
        }
        await Promise.all(triggers.map((trigger) => trigger.executeAsync(this.viewerContext, queryContext, entity, mutationInfo)));
    }
    async executeNonTransactionalMutationTriggersAsync(triggers, entity, mutationInfo) {
        if (!triggers) {
            return;
        }
        await Promise.all(triggers.map((trigger) => trigger.executeAsync(this.viewerContext, entity, mutationInfo)));
    }
}
/**
 * Mutator for creating a new entity.
 */
class CreateMutator extends BaseMutator {
    fieldsForEntity = {};
    /**
     * Set the value for entity field.
     * @param fieldName - entity field being updated
     * @param value - value for entity field
     */
    setField(fieldName, value) {
        this.fieldsForEntity[fieldName] = value;
        return this;
    }
    /**
     * Commit the new entity after authorizing against creation privacy rules. Invalidates all caches for
     * queries that would return new entity.
     * @returns authorized, cached, newly-created entity result, where result error can be UnauthorizedError
     */
    async createAsync() {
        return await (0, EntityMetricsUtils_1.timeAndLogMutationEventAsync)(this.metricsAdapter, IEntityMetricsAdapter_1.EntityMetricsMutationType.CREATE, this.entityClass.name)(this.createInTransactionAsync());
    }
    /**
     * Convenience method that returns the new entity or throws upon create failure.
     */
    async enforceCreateAsync() {
        return await (0, results_1.enforceAsyncResult)(this.createAsync());
    }
    async createInTransactionAsync() {
        return await this.queryContext.runInTransactionIfNotInTransactionAsync((innerQueryContext) => this.createInternalAsync(innerQueryContext));
    }
    async createInternalAsync(queryContext) {
        this.validateFields(this.fieldsForEntity);
        const entityLoader = this.entityLoaderFactory.forLoad(this.viewerContext, queryContext, {
            previousValue: null,
            cascadingDeleteCause: null,
        });
        const temporaryEntityForPrivacyCheck = entityLoader.utils().constructEntity({
            [this.entityConfiguration.idField]: '00000000-0000-0000-0000-000000000000', // zero UUID
            ...this.fieldsForEntity,
        });
        const authorizeCreateResult = await (0, results_1.asyncResult)(this.privacyPolicy.authorizeCreateAsync(this.viewerContext, queryContext, { previousValue: null, cascadingDeleteCause: null }, temporaryEntityForPrivacyCheck, this.metricsAdapter));
        if (!authorizeCreateResult.ok) {
            return authorizeCreateResult;
        }
        await this.executeMutationValidatorsAsync(this.mutationValidators, queryContext, temporaryEntityForPrivacyCheck, { type: EntityMutationInfo_1.EntityMutationType.CREATE });
        await this.executeMutationTriggersAsync(this.mutationTriggers.beforeAll, queryContext, temporaryEntityForPrivacyCheck, { type: EntityMutationInfo_1.EntityMutationType.CREATE });
        await this.executeMutationTriggersAsync(this.mutationTriggers.beforeCreate, queryContext, temporaryEntityForPrivacyCheck, { type: EntityMutationInfo_1.EntityMutationType.CREATE });
        const insertResult = await this.databaseAdapter.insertAsync(queryContext, this.fieldsForEntity);
        queryContext.appendPostCommitInvalidationCallback(entityLoader.utils().invalidateFieldsAsync.bind(entityLoader, insertResult));
        const unauthorizedEntityAfterInsert = entityLoader.utils().constructEntity(insertResult);
        const newEntity = await entityLoader
            .enforcing()
            .loadByIDAsync(unauthorizedEntityAfterInsert.getID());
        await this.executeMutationTriggersAsync(this.mutationTriggers.afterCreate, queryContext, newEntity, { type: EntityMutationInfo_1.EntityMutationType.CREATE });
        await this.executeMutationTriggersAsync(this.mutationTriggers.afterAll, queryContext, newEntity, { type: EntityMutationInfo_1.EntityMutationType.CREATE });
        queryContext.appendPostCommitCallback(this.executeNonTransactionalMutationTriggersAsync.bind(this, this.mutationTriggers.afterCommit, newEntity, { type: EntityMutationInfo_1.EntityMutationType.CREATE }));
        return (0, results_1.result)(newEntity);
    }
}
exports.CreateMutator = CreateMutator;
/**
 * Mutator for updating an existing entity.
 */
class UpdateMutator extends BaseMutator {
    originalEntity;
    fieldsForEntity;
    updatedFields = {};
    constructor(companionProvider, viewerContext, queryContext, entityConfiguration, entityClass, privacyPolicy, mutationValidators, mutationTriggers, entityLoaderFactory, databaseAdapter, metricsAdapter, originalEntity) {
        super(companionProvider, viewerContext, queryContext, entityConfiguration, entityClass, privacyPolicy, mutationValidators, mutationTriggers, entityLoaderFactory, databaseAdapter, metricsAdapter);
        this.originalEntity = originalEntity;
        this.fieldsForEntity = { ...originalEntity.getAllDatabaseFields() };
    }
    /**
     * Set the value for entity field.
     * @param fieldName - entity field being updated
     * @param value - value for entity field
     */
    setField(fieldName, value) {
        this.fieldsForEntity[fieldName] = value;
        this.updatedFields[fieldName] = value;
        return this;
    }
    /**
     * Commit the changes to the entity after authorizing against update privacy rules.
     * Invalidates all caches for pre-update entity.
     * @returns authorized updated entity result, where result error can be UnauthorizedError
     */
    async updateAsync() {
        return await (0, EntityMetricsUtils_1.timeAndLogMutationEventAsync)(this.metricsAdapter, IEntityMetricsAdapter_1.EntityMetricsMutationType.UPDATE, this.entityClass.name)(this.updateInTransactionAsync(false, null));
    }
    /**
     * Convenience method that returns the updated entity or throws upon update failure.
     */
    async enforceUpdateAsync() {
        return await (0, results_1.enforceAsyncResult)(this.updateAsync());
    }
    async updateInTransactionAsync(skipDatabaseUpdate, cascadingDeleteCause) {
        return await this.queryContext.runInTransactionIfNotInTransactionAsync((innerQueryContext) => this.updateInternalAsync(innerQueryContext, skipDatabaseUpdate, cascadingDeleteCause));
    }
    async updateInternalAsync(queryContext, skipDatabaseUpdate, cascadingDeleteCause) {
        this.validateFields(this.updatedFields);
        this.ensureStableIDField(this.updatedFields);
        const entityLoader = this.entityLoaderFactory.forLoad(this.viewerContext, queryContext, {
            previousValue: this.originalEntity,
            cascadingDeleteCause,
        });
        const entityAboutToBeUpdated = entityLoader.utils().constructEntity(this.fieldsForEntity);
        const authorizeUpdateResult = await (0, results_1.asyncResult)(this.privacyPolicy.authorizeUpdateAsync(this.viewerContext, queryContext, { previousValue: this.originalEntity, cascadingDeleteCause }, entityAboutToBeUpdated, this.metricsAdapter));
        if (!authorizeUpdateResult.ok) {
            return authorizeUpdateResult;
        }
        await this.executeMutationValidatorsAsync(this.mutationValidators, queryContext, entityAboutToBeUpdated, { type: EntityMutationInfo_1.EntityMutationType.UPDATE, previousValue: this.originalEntity, cascadingDeleteCause });
        await this.executeMutationTriggersAsync(this.mutationTriggers.beforeAll, queryContext, entityAboutToBeUpdated, { type: EntityMutationInfo_1.EntityMutationType.UPDATE, previousValue: this.originalEntity, cascadingDeleteCause });
        await this.executeMutationTriggersAsync(this.mutationTriggers.beforeUpdate, queryContext, entityAboutToBeUpdated, { type: EntityMutationInfo_1.EntityMutationType.UPDATE, previousValue: this.originalEntity, cascadingDeleteCause });
        // skip the database update when specified
        if (!skipDatabaseUpdate) {
            await this.databaseAdapter.updateAsync(queryContext, this.entityConfiguration.idField, entityAboutToBeUpdated.getID(), this.updatedFields);
        }
        queryContext.appendPostCommitInvalidationCallback(entityLoader
            .utils()
            .invalidateFieldsAsync.bind(entityLoader, this.originalEntity.getAllDatabaseFields()));
        queryContext.appendPostCommitInvalidationCallback(entityLoader.utils().invalidateFieldsAsync.bind(entityLoader, this.fieldsForEntity));
        const updatedEntity = await entityLoader
            .enforcing()
            .loadByIDAsync(entityAboutToBeUpdated.getID()); // ID is guaranteed to be stable by ensureStableIDField
        await this.executeMutationTriggersAsync(this.mutationTriggers.afterUpdate, queryContext, updatedEntity, { type: EntityMutationInfo_1.EntityMutationType.UPDATE, previousValue: this.originalEntity, cascadingDeleteCause });
        await this.executeMutationTriggersAsync(this.mutationTriggers.afterAll, queryContext, updatedEntity, { type: EntityMutationInfo_1.EntityMutationType.UPDATE, previousValue: this.originalEntity, cascadingDeleteCause });
        queryContext.appendPostCommitCallback(this.executeNonTransactionalMutationTriggersAsync.bind(this, this.mutationTriggers.afterCommit, updatedEntity, {
            type: EntityMutationInfo_1.EntityMutationType.UPDATE,
            previousValue: this.originalEntity,
            cascadingDeleteCause,
        }));
        return (0, results_1.result)(updatedEntity);
    }
    ensureStableIDField(updatedFields) {
        const originalId = this.originalEntity.getID();
        const idField = this.entityConfiguration.idField;
        if (updatedFields.hasOwnProperty(idField) && originalId !== updatedFields[idField]) {
            throw new Error(`id field updates not supported: (entityClass = ${this.entityClass.name})`);
        }
    }
}
exports.UpdateMutator = UpdateMutator;
/**
 * Mutator for deleting an existing entity.
 */
class DeleteMutator extends BaseMutator {
    entity;
    constructor(companionProvider, viewerContext, queryContext, entityConfiguration, entityClass, privacyPolicy, mutationValidators, mutationTriggers, entityLoaderFactory, databaseAdapter, metricsAdapter, entity) {
        super(companionProvider, viewerContext, queryContext, entityConfiguration, entityClass, privacyPolicy, mutationValidators, mutationTriggers, entityLoaderFactory, databaseAdapter, metricsAdapter);
        this.entity = entity;
    }
    /**
     * Delete the entity after authorizing against delete privacy rules. The entity is invalidated in all caches.
     * @returns void result, where result error can be UnauthorizedError
     */
    async deleteAsync() {
        return await (0, EntityMetricsUtils_1.timeAndLogMutationEventAsync)(this.metricsAdapter, IEntityMetricsAdapter_1.EntityMetricsMutationType.DELETE, this.entityClass.name)(this.deleteInTransactionAsync(new Set(), false, null));
    }
    /**
     * Convenience method that throws upon delete failure.
     */
    async enforceDeleteAsync() {
        return await (0, results_1.enforceAsyncResult)(this.deleteAsync());
    }
    async deleteInTransactionAsync(processedEntityIdentifiersFromTransitiveDeletions, skipDatabaseDeletion, cascadingDeleteCause) {
        return await this.queryContext.runInTransactionIfNotInTransactionAsync((innerQueryContext) => this.deleteInternalAsync(innerQueryContext, processedEntityIdentifiersFromTransitiveDeletions, skipDatabaseDeletion, cascadingDeleteCause));
    }
    async deleteInternalAsync(queryContext, processedEntityIdentifiersFromTransitiveDeletions, skipDatabaseDeletion, cascadingDeleteCause) {
        const authorizeDeleteResult = await (0, results_1.asyncResult)(this.privacyPolicy.authorizeDeleteAsync(this.viewerContext, queryContext, { previousValue: null, cascadingDeleteCause }, this.entity, this.metricsAdapter));
        if (!authorizeDeleteResult.ok) {
            return authorizeDeleteResult;
        }
        await this.processEntityDeletionForInboundEdgesAsync(this.entity, queryContext, processedEntityIdentifiersFromTransitiveDeletions, cascadingDeleteCause);
        await this.executeMutationTriggersAsync(this.mutationTriggers.beforeAll, queryContext, this.entity, { type: EntityMutationInfo_1.EntityMutationType.DELETE, cascadingDeleteCause });
        await this.executeMutationTriggersAsync(this.mutationTriggers.beforeDelete, queryContext, this.entity, { type: EntityMutationInfo_1.EntityMutationType.DELETE, cascadingDeleteCause });
        if (!skipDatabaseDeletion) {
            await this.databaseAdapter.deleteAsync(queryContext, this.entityConfiguration.idField, this.entity.getID());
        }
        const entityLoader = this.entityLoaderFactory.forLoad(this.viewerContext, queryContext, {
            previousValue: null,
            cascadingDeleteCause,
        });
        queryContext.appendPostCommitInvalidationCallback(entityLoader
            .utils()
            .invalidateFieldsAsync.bind(entityLoader, this.entity.getAllDatabaseFields()));
        await this.executeMutationTriggersAsync(this.mutationTriggers.afterDelete, queryContext, this.entity, { type: EntityMutationInfo_1.EntityMutationType.DELETE, cascadingDeleteCause });
        await this.executeMutationTriggersAsync(this.mutationTriggers.afterAll, queryContext, this.entity, { type: EntityMutationInfo_1.EntityMutationType.DELETE, cascadingDeleteCause });
        queryContext.appendPostCommitCallback(this.executeNonTransactionalMutationTriggersAsync.bind(this, this.mutationTriggers.afterCommit, this.entity, { type: EntityMutationInfo_1.EntityMutationType.DELETE, cascadingDeleteCause }));
        return (0, results_1.result)();
    }
    /**
     * Finds all entities referencing the specified entity and either deletes them, nullifies
     * their references to the specified entity, or invalidates the cache depending on the
     * OnDeleteBehavior of the field referencing the specified entity.
     *
     * @remarks
     * This works by doing reverse fan-out queries:
     * 1. Load all entity configurations of entity types that reference this type of entity
     * 2. For each entity configuration, find all fields that contain edges to this type of entity
     * 3. For each edge field, load all entities with an edge from target entity to this entity via that field
     * 4. Perform desired OnDeleteBehavior for entities
     *
     * @param entity - entity to find all references to
     */
    async processEntityDeletionForInboundEdgesAsync(entity, queryContext, processedEntityIdentifiers, cascadingDeleteCause) {
        // prevent infinite reference cycles by keeping track of entities already processed
        if (processedEntityIdentifiers.has(entity.getUniqueIdentifier())) {
            return;
        }
        processedEntityIdentifiers.add(entity.getUniqueIdentifier());
        const companionDefinition = this.companionProvider.getCompanionForEntity(entity.constructor).entityCompanionDefinition;
        const entityConfiguration = companionDefinition.entityConfiguration;
        const inboundEdges = entityConfiguration.inboundEdges;
        const newCascadingDeleteCause = {
            entity,
            cascadingDeleteCause,
        };
        await Promise.all(inboundEdges.map(async (entityClass) => {
            const loaderFactory = entity
                .getViewerContext()
                .getViewerScopedEntityCompanionForClass(entityClass)
                .getLoaderFactory();
            const mutatorFactory = entity
                .getViewerContext()
                .getViewerScopedEntityCompanionForClass(entityClass)
                .getMutatorFactory();
            return await (0, maps_1.mapMapAsync)(this.companionProvider.getCompanionForEntity(entityClass).entityCompanionDefinition
                .entityConfiguration.schema, async (fieldDefinition, fieldName) => {
                const association = fieldDefinition.association;
                if (!association) {
                    return;
                }
                const associatedConfiguration = this.companionProvider.getCompanionForEntity(association.associatedEntityClass).entityCompanionDefinition.entityConfiguration;
                if (associatedConfiguration !== entityConfiguration) {
                    return;
                }
                const inboundReferenceEntities = await loaderFactory
                    .forLoad(queryContext, {
                    previousValue: null,
                    cascadingDeleteCause: newCascadingDeleteCause,
                })
                    .enforcing()
                    .loadManyByFieldEqualingAsync(fieldName, association.associatedEntityLookupByField
                    ? entity.getField(association.associatedEntityLookupByField)
                    : entity.getID());
                switch (association.edgeDeletionBehavior) {
                    case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE_INVALIDATE_CACHE_ONLY: {
                        await Promise.all(inboundReferenceEntities.map((inboundReferenceEntity) => (0, results_1.enforceAsyncResult)(mutatorFactory
                            .forDelete(inboundReferenceEntity, queryContext)
                            .deleteInTransactionAsync(processedEntityIdentifiers, 
                        /* skipDatabaseDeletion */ true, // deletion is handled by DB
                        newCascadingDeleteCause))));
                        break;
                    }
                    case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL_INVALIDATE_CACHE_ONLY: {
                        await Promise.all(inboundReferenceEntities.map((inboundReferenceEntity) => (0, results_1.enforceAsyncResult)(mutatorFactory
                            .forUpdate(inboundReferenceEntity, queryContext)
                            .setField(fieldName, null)['updateInTransactionAsync'](/* skipDatabaseUpdate */ true, newCascadingDeleteCause))));
                        break;
                    }
                    case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL: {
                        await Promise.all(inboundReferenceEntities.map((inboundReferenceEntity) => (0, results_1.enforceAsyncResult)(mutatorFactory
                            .forUpdate(inboundReferenceEntity, queryContext)
                            .setField(fieldName, null)['updateInTransactionAsync'](/* skipDatabaseUpdate */ false, newCascadingDeleteCause))));
                        break;
                    }
                    case EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE: {
                        await Promise.all(inboundReferenceEntities.map((inboundReferenceEntity) => (0, results_1.enforceAsyncResult)(mutatorFactory
                            .forDelete(inboundReferenceEntity, queryContext)
                            .deleteInTransactionAsync(processedEntityIdentifiers, 
                        /* skipDatabaseDeletion */ false, newCascadingDeleteCause))));
                    }
                }
            });
        }));
    }
}
exports.DeleteMutator = DeleteMutator;
//# sourceMappingURL=EntityMutator.js.map