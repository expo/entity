"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityNestedTransactionalQueryContext = exports.EntityTransactionalQueryContext = exports.EntityNonTransactionalQueryContext = exports.EntityQueryContext = exports.TransactionIsolationLevel = void 0;
const assert_1 = __importDefault(require("assert"));
var TransactionIsolationLevel;
(function (TransactionIsolationLevel) {
    TransactionIsolationLevel["READ_COMMITTED"] = "READ_COMMITTED";
    TransactionIsolationLevel["REPEATABLE_READ"] = "REPEATABLE_READ";
    TransactionIsolationLevel["SERIALIZABLE"] = "SERIALIZABLE";
})(TransactionIsolationLevel || (exports.TransactionIsolationLevel = TransactionIsolationLevel = {}));
/**
 * Entity framework representation of transactional and non-transactional database
 * query execution units.
 *
 * The behavior of EntityMutator and EntityLoader
 * differs when in a transactional context.
 */
class EntityQueryContext {
    queryInterface;
    constructor(queryInterface) {
        this.queryInterface = queryInterface;
    }
    getQueryInterface() {
        return this.queryInterface;
    }
}
exports.EntityQueryContext = EntityQueryContext;
/**
 * Entity framework representation of a non-transactional query execution unit.
 * When supplied to EntityMutator and EntityLoader methods, they will be
 * run independently of any running transaction (though mutations start their own
 * independent transactions internally when not being run in a transaction).
 */
class EntityNonTransactionalQueryContext extends EntityQueryContext {
    entityQueryContextProvider;
    constructor(queryInterface, entityQueryContextProvider) {
        super(queryInterface);
        this.entityQueryContextProvider = entityQueryContextProvider;
    }
    isInTransaction() {
        return false;
    }
    async runInTransactionIfNotInTransactionAsync(transactionScope, transactionConfig) {
        return await this.entityQueryContextProvider.runInTransactionAsync(transactionScope, transactionConfig);
    }
}
exports.EntityNonTransactionalQueryContext = EntityNonTransactionalQueryContext;
/**
 * Entity framework representation of a transactional query execution unit. When supplied
 * to EntityMutator and EntityLoader methods, those methods and their
 * dependent triggers and validators will run within the transaction.
 */
class EntityTransactionalQueryContext extends EntityQueryContext {
    entityQueryContextProvider;
    postCommitInvalidationCallbacks = [];
    postCommitCallbacks = [];
    preCommitCallbacks = [];
    constructor(queryInterface, entityQueryContextProvider) {
        super(queryInterface);
        this.entityQueryContextProvider = entityQueryContextProvider;
    }
    /**
     * Schedule a pre-commit callback. These will be run within the transaction right before it is
     * committed, and will be run in the order specified. Ordering of callbacks scheduled with the
     * same value for the order parameter is undefined within that ordering group.
     * @param callback - callback to schedule
     * @param order - order in which this should be run relative to other scheduled pre-commit callbacks,
     *                with higher numbers running later than lower numbers.
     */
    appendPreCommitCallback(callback, order) {
        (0, assert_1.default)(order >= Number.MIN_SAFE_INTEGER && order <= Number.MAX_SAFE_INTEGER, `Invalid order specified: ${order}`);
        this.preCommitCallbacks.push({ callback, order });
    }
    /**
     * Schedule a post-commit cache invalidation callback. These are run before normal
     * post-commit callbacks in order to have cache consistency in normal post-commit callbacks.
     * @param callback - callback to schedule
     */
    appendPostCommitInvalidationCallback(callback) {
        this.postCommitInvalidationCallbacks.push(callback);
    }
    /**
     * Schedule a post-commit callback. These will be run after the transaction has
     * been committed.
     * @param callback - callback to schedule
     */
    appendPostCommitCallback(callback) {
        this.postCommitCallbacks.push(callback);
    }
    async runPreCommitCallbacksAsync() {
        const callbacks = [...this.preCommitCallbacks]
            .sort((a, b) => a.order - b.order)
            .map((c) => c.callback);
        this.preCommitCallbacks.length = 0;
        for (const callback of callbacks) {
            await callback(this);
        }
    }
    async runPostCommitCallbacksAsync() {
        const invalidationCallbacks = [...this.postCommitInvalidationCallbacks];
        this.postCommitInvalidationCallbacks.length = 0;
        await Promise.all(invalidationCallbacks.map((callback) => callback()));
        const callbacks = [...this.postCommitCallbacks];
        this.postCommitCallbacks.length = 0;
        await Promise.all(callbacks.map((callback) => callback()));
    }
    isInTransaction() {
        return true;
    }
    async runInTransactionIfNotInTransactionAsync(transactionScope, transactionConfig) {
        (0, assert_1.default)(transactionConfig === undefined, 'Should not pass transactionConfig to a nested transaction');
        return await transactionScope(this);
    }
    async runInNestedTransactionAsync(transactionScope) {
        return await this.entityQueryContextProvider.runInNestedTransactionAsync(this, transactionScope);
    }
}
exports.EntityTransactionalQueryContext = EntityTransactionalQueryContext;
/**
 * Entity framework representation of a nested transactional query execution unit. When supplied
 * to EntityMutator and EntityLoader methods, those methods and their
 * dependent triggers and validators will run within the nested transaction.
 *
 * This exists to forward post-commit callbacks to the parent query context but only after
 * successful commit of the nested transaction.
 */
class EntityNestedTransactionalQueryContext extends EntityTransactionalQueryContext {
    parentQueryContext;
    postCommitInvalidationCallbacksToTransfer = [];
    postCommitCallbacksToTransfer = [];
    constructor(queryInterface, parentQueryContext, entityQueryContextProvider) {
        super(queryInterface, entityQueryContextProvider);
        this.parentQueryContext = parentQueryContext;
    }
    appendPostCommitCallback(callback) {
        this.postCommitInvalidationCallbacksToTransfer.push(callback);
    }
    appendPostCommitInvalidationCallback(callback) {
        this.postCommitCallbacksToTransfer.push(callback);
    }
    runPostCommitCallbacksAsync() {
        throw new Error('Must not call runPostCommitCallbacksAsync on EntityNestedTransactionalQueryContext');
    }
    transferPostCommitCallbacksToParent() {
        for (const callback of this.postCommitInvalidationCallbacksToTransfer) {
            this.parentQueryContext.appendPostCommitInvalidationCallback(callback);
        }
        for (const callback of this.postCommitCallbacksToTransfer) {
            this.parentQueryContext.appendPostCommitCallback(callback);
        }
    }
}
exports.EntityNestedTransactionalQueryContext = EntityNestedTransactionalQueryContext;
//# sourceMappingURL=EntityQueryContext.js.map