"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
const entityUtils_1 = require("../entityUtils");
describe(entityUtils_1.enforceResultsAsync, () => {
    it('throws when any result is an error', async () => {
        const error = new Error('hi');
        const results = Promise.resolve([(0, results_1.result)(error), (0, results_1.result)(3)]);
        await expect((0, entityUtils_1.enforceResultsAsync)(results)).rejects.toEqual(error);
    });
    it('returns values when results are all value', async () => {
        const results = Promise.resolve([(0, results_1.result)(2), (0, results_1.result)(3)]);
        await expect((0, entityUtils_1.enforceResultsAsync)(results)).resolves.toEqual([2, 3]);
    });
});
describe(entityUtils_1.successfulResults, () => {
    it('filters out failed results', () => {
        const result1 = (0, results_1.result)(1);
        const result2 = (0, results_1.result)(new Error('hello'));
        const result3 = (0, results_1.result)(1);
        const allResults = [result1, result2, result3];
        expect((0, entityUtils_1.successfulResults)(allResults)).toEqual([result1, result3]);
    });
});
describe(entityUtils_1.failedResults, () => {
    it('filters out successful results', () => {
        const result1 = (0, results_1.result)(1);
        const result2 = (0, results_1.result)(new Error('hello'));
        const result3 = (0, results_1.result)(1);
        const allResults = [result1, result2, result3];
        expect((0, entityUtils_1.failedResults)(allResults)).toEqual([result2]);
    });
});
describe(entityUtils_1.successfulResultsFilterMap, () => {
    it('filters out failed results', () => {
        const result1 = (0, results_1.result)(1);
        const result2 = (0, results_1.result)(new Error('hello'));
        const result3 = (0, results_1.result)(1);
        const allResults = new Map(Object.entries({
            a: result1,
            b: result2,
            c: result3,
        }));
        const resultingMap = (0, entityUtils_1.successfulResultsFilterMap)(allResults);
        expect(resultingMap.get('a')).toEqual(result1);
        expect(resultingMap.get('b')).toBeUndefined();
        expect(resultingMap.get('c')).toEqual(result3);
    });
});
describe(entityUtils_1.failedResultsFilterMap, () => {
    it('filters out successful results', () => {
        const result1 = (0, results_1.result)(1);
        const result2 = (0, results_1.result)(new Error('hello'));
        const result3 = (0, results_1.result)(1);
        const allResults = new Map(Object.entries({
            a: result1,
            b: result2,
            c: result3,
        }));
        const resultingMap = (0, entityUtils_1.failedResultsFilterMap)(allResults);
        expect(resultingMap.get('a')).toBeUndefined();
        expect(resultingMap.get('b')).toEqual(result2);
        expect(resultingMap.get('c')).toBeUndefined();
    });
});
describe(entityUtils_1.pick, () => {
    it('picks specified keys', () => {
        const object = {
            a: 1,
            b: 2,
            c: 3,
        };
        expect((0, entityUtils_1.pick)(object, ['a', 'b'])).toEqual({
            a: 1,
            b: 2,
        });
    });
});
describe(entityUtils_1.partitionArray, () => {
    it('partitions array', () => {
        const arr = [true, false, true, true, false];
        const [as, bs] = (0, entityUtils_1.partitionArray)(arr, (val) => val === true);
        expect(as).toMatchObject([true, true, true]);
        expect(bs).toMatchObject([false, false]);
    });
});
//# sourceMappingURL=entityUtils-test.js.map