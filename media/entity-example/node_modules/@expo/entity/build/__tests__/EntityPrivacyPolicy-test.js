"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_mockito_1 = require("ts-mockito");
const Entity_1 = __importDefault(require("../Entity"));
const EntityConfiguration_1 = __importDefault(require("../EntityConfiguration"));
const EntityFields_1 = require("../EntityFields");
const EntityPrivacyPolicy_1 = __importStar(require("../EntityPrivacyPolicy"));
const EntityQueryContext_1 = require("../EntityQueryContext");
const ViewerContext_1 = __importDefault(require("../ViewerContext"));
const EntityNotAuthorizedError_1 = __importDefault(require("../errors/EntityNotAuthorizedError"));
const IEntityMetricsAdapter_1 = require("../metrics/IEntityMetricsAdapter");
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysAllowPrivacyPolicyRule"));
const AlwaysDenyPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysDenyPrivacyPolicyRule"));
const AlwaysSkipPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysSkipPrivacyPolicyRule"));
const PrivacyPolicyRule_1 = __importDefault(require("../rules/PrivacyPolicyRule"));
class BlahEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: BlahEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'blah_table',
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'id',
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: AlwaysDenyPolicy,
        };
    }
}
class AlwaysDenyPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [
        new AlwaysDenyPrivacyPolicyRule_1.default(),
    ];
    readRules = [
        new AlwaysDenyPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysDenyPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysDenyPrivacyPolicyRule_1.default(),
    ];
}
class DryRunAlwaysDenyPolicy extends AlwaysDenyPolicy {
    // public method for test spying
    denyHandler(_error) { }
    getPrivacyPolicyEvaluator() {
        return {
            mode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.DRY_RUN,
            denyHandler: this.denyHandler,
        };
    }
}
class LoggingEnforceAlwaysDenyPolicy extends AlwaysDenyPolicy {
    // public method for test spying
    denyHandler(_error) { }
    getPrivacyPolicyEvaluator() {
        return {
            mode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE_AND_LOG,
            denyHandler: this.denyHandler,
        };
    }
}
class AlwaysAllowPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
class DryRunAlwaysAllowPolicy extends AlwaysAllowPolicy {
    // public method for test spying
    denyHandler(_error) { }
    getPrivacyPolicyEvaluator() {
        return {
            mode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.DRY_RUN,
            denyHandler: this.denyHandler,
        };
    }
}
class LoggingEnforceAlwaysAllowPolicy extends AlwaysAllowPolicy {
    // public method for test spying
    denyHandler(_error) { }
    getPrivacyPolicyEvaluator() {
        return {
            mode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE_AND_LOG,
            denyHandler: this.denyHandler,
        };
    }
}
class SkipAllPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [
        new AlwaysSkipPrivacyPolicyRule_1.default(),
    ];
    readRules = [
        new AlwaysSkipPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysSkipPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysSkipPrivacyPolicyRule_1.default(),
    ];
}
class InvalidCreateRuleResultPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [
        {
            async evaluateAsync() {
                return 2;
            },
        },
    ];
    readRules = [
        new AlwaysSkipPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysSkipPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysSkipPrivacyPolicyRule_1.default(),
    ];
}
class AlwaysThrowPrivacyPolicyRule extends PrivacyPolicyRule_1.default {
    evaluateAsync(_viewerContext, _queryContext, _evaluationContext, _entity) {
        throw new Error('WooHoo!');
    }
}
class ThrowAllPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [new AlwaysThrowPrivacyPolicyRule()];
    readRules = [new AlwaysThrowPrivacyPolicyRule()];
    updateRules = [new AlwaysThrowPrivacyPolicyRule()];
    deleteRules = [new AlwaysThrowPrivacyPolicyRule()];
}
class DryRunThrowAllPolicy extends ThrowAllPolicy {
    // public method for test spying
    denyHandler(_error) { }
    getPrivacyPolicyEvaluator() {
        return {
            mode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.DRY_RUN,
            denyHandler: this.denyHandler,
        };
    }
}
class LoggingEnforceThrowAllPolicy extends ThrowAllPolicy {
    // public method for test spying
    denyHandler(_error) { }
    getPrivacyPolicyEvaluator() {
        return {
            mode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE_AND_LOG,
            denyHandler: this.denyHandler,
        };
    }
}
class EmptyPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [];
    readRules = [];
    updateRules = [];
    deleteRules = [];
}
describe(EntityPrivacyPolicy_1.default, () => {
    describe(EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE.toString(), () => {
        it('throws EntityNotAuthorizedError when deny', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new AlwaysDenyPolicy();
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE,
            }))).once();
        });
        it('returns entity when allowed', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new AlwaysAllowPolicy();
            const approvedEntity = await policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter);
            expect(approvedEntity).toEqual(entity);
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.ALLOW,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE,
            }))).once();
        });
        it('throws EntityNotAuthorizedError when all skipped', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new SkipAllPolicy();
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE,
            }))).once();
        });
        it('throws when an invalid result is returned', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new InvalidCreateRuleResultPolicy();
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toThrow('Invalid RuleEvaluationResult returned from rule');
        });
        it('throws EntityNotAuthorizedError when empty policy', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new EmptyPolicy();
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE,
            }))).once();
        });
        it('throws when rule throws', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new ThrowAllPolicy();
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toThrowError('WooHoo!');
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.anything)())).never();
        });
    });
    describe(EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.DRY_RUN.toString(), () => {
        it('returns entity when denied but calls denialHandler', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new DryRunAlwaysDenyPolicy();
            const policySpy = (0, ts_mockito_1.spy)(policy);
            const approvedEntity = await policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter);
            expect(approvedEntity).toEqual(entity);
            (0, ts_mockito_1.verify)(policySpy.denyHandler((0, ts_mockito_1.anyOfClass)(EntityNotAuthorizedError_1.default))).once();
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.DRY_RUN,
            }))).once();
        });
        it('does not log when not denied', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new DryRunAlwaysAllowPolicy();
            const policySpy = (0, ts_mockito_1.spy)(policy);
            const approvedEntity = await policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter);
            expect(approvedEntity).toEqual(entity);
            (0, ts_mockito_1.verify)(policySpy.denyHandler((0, ts_mockito_1.anyOfClass)(EntityNotAuthorizedError_1.default))).never();
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.ALLOW,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.DRY_RUN,
            }))).once();
        });
        it('passes through other errors', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new DryRunThrowAllPolicy();
            const policySpy = (0, ts_mockito_1.spy)(policy);
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toThrowError('WooHoo!');
            (0, ts_mockito_1.verify)(policySpy.denyHandler((0, ts_mockito_1.anyOfClass)(EntityNotAuthorizedError_1.default))).never();
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.anything)())).never();
        });
    });
    describe(EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE_AND_LOG.toString(), () => {
        it('denies when denied but calls denialHandler', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new LoggingEnforceAlwaysDenyPolicy();
            const policySpy = (0, ts_mockito_1.spy)(policy);
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
            (0, ts_mockito_1.verify)(policySpy.denyHandler((0, ts_mockito_1.anyOfClass)(EntityNotAuthorizedError_1.default))).once();
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.DENY,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE_AND_LOG,
            }))).once();
        });
        it('does not log when not denied', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new LoggingEnforceAlwaysAllowPolicy();
            const policySpy = (0, ts_mockito_1.spy)(policy);
            const approvedEntity = await policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter);
            expect(approvedEntity).toEqual(entity);
            (0, ts_mockito_1.verify)(policySpy.denyHandler((0, ts_mockito_1.anyOfClass)(EntityNotAuthorizedError_1.default))).never();
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.objectContaining)({
                entityClassName: entity.constructor.name,
                action: EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE,
                evaluationResult: IEntityMetricsAdapter_1.EntityMetricsAuthorizationResult.ALLOW,
                privacyPolicyEvaluationMode: EntityPrivacyPolicy_1.EntityPrivacyPolicyEvaluationMode.ENFORCE_AND_LOG,
            }))).once();
        });
        it('passes through other errors', async () => {
            const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
            const queryContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityQueryContext_1.EntityQueryContext));
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const metricsAdapterMock = (0, ts_mockito_1.mock)();
            const metricsAdapter = (0, ts_mockito_1.instance)(metricsAdapterMock);
            const entity = new BlahEntity({
                viewerContext,
                id: '1',
                databaseFields: { id: '1' },
                selectedFields: { id: '1' },
            });
            const policy = new LoggingEnforceThrowAllPolicy();
            const policySpy = (0, ts_mockito_1.spy)(policy);
            await expect(policy.authorizeCreateAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, metricsAdapter)).rejects.toThrowError('WooHoo!');
            (0, ts_mockito_1.verify)(policySpy.denyHandler((0, ts_mockito_1.anyOfClass)(EntityNotAuthorizedError_1.default))).never();
            (0, ts_mockito_1.verify)(metricsAdapterMock.logAuthorizationEvent((0, ts_mockito_1.anything)())).never();
        });
    });
});
//# sourceMappingURL=EntityPrivacyPolicy-test.js.map