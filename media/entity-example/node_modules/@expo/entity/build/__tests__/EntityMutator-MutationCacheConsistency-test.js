"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Entity_1 = __importDefault(require("../Entity"));
const EntityConfiguration_1 = __importDefault(require("../EntityConfiguration"));
const EntityFields_1 = require("../EntityFields");
const EntityMutationInfo_1 = require("../EntityMutationInfo");
const EntityMutationTriggerConfiguration_1 = require("../EntityMutationTriggerConfiguration");
const EntityPrivacyPolicy_1 = __importDefault(require("../EntityPrivacyPolicy"));
const ViewerContext_1 = __importDefault(require("../ViewerContext"));
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysAllowPrivacyPolicyRule"));
const createUnitTestEntityCompanionProvider_1 = require("../utils/testing/createUnitTestEntityCompanionProvider");
class BlahEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
class BlahEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: BlahEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'blah_table',
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'id',
                        cache: true,
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: BlahEntityPrivacyPolicy,
            mutationTriggers: {
                afterCommit: [new TestNonTransactionalMutationTrigger()],
            },
        };
    }
}
class TestNonTransactionalMutationTrigger extends EntityMutationTriggerConfiguration_1.EntityNonTransactionalMutationTrigger {
    async executeAsync(viewerContext, entity, mutationInfo) {
        if (mutationInfo.type === EntityMutationInfo_1.EntityMutationType.DELETE) {
            const entityLoaded = await BlahEntity.loader(viewerContext)
                .enforcing()
                .loadByIDNullableAsync(entity.getID());
            if (entityLoaded) {
                throw new Error('should not have been able to re-load the entity after delete. this means the cache has not been cleared');
            }
        }
    }
}
describe('EntityMutator', () => {
    test('cache consistency with post-commit callbacks', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        // put it in cache
        const entity = await BlahEntity.creator(viewerContext).enforceCreateAsync();
        const entityLoaded = await BlahEntity.loader(viewerContext)
            .enforcing()
            .loadByIDAsync(entity.getID());
        await BlahEntity.enforceDeleteAsync(entityLoaded);
    });
});
//# sourceMappingURL=EntityMutator-MutationCacheConsistency-test.js.map