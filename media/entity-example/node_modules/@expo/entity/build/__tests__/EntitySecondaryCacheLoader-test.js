"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_mockito_1 = require("ts-mockito");
const EntityQueryContext_1 = require("../EntityQueryContext");
const EntitySecondaryCacheLoader_1 = __importDefault(require("../EntitySecondaryCacheLoader"));
const ViewerContext_1 = __importDefault(require("../ViewerContext"));
const SimpleTestEntity_1 = __importDefault(require("../testfixtures/SimpleTestEntity"));
const createUnitTestEntityCompanionProvider_1 = require("../utils/testing/createUnitTestEntityCompanionProvider");
class TestSecondaryRedisCacheLoader extends EntitySecondaryCacheLoader_1.default {
    async fetchObjectsFromDatabaseAsync(_loadParamsArray) {
        // unused
        return new Map();
    }
}
describe(EntitySecondaryCacheLoader_1.default, () => {
    describe('loadManyAsync', () => {
        it('calls into secondary cache with correct params', async () => {
            const vc1 = new ViewerContext_1.default((0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)());
            const createdEntity = await SimpleTestEntity_1.default.creator(vc1).enforceCreateAsync();
            const loadParams = { id: createdEntity.getID() };
            const secondaryEntityCacheMock = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(secondaryEntityCacheMock.loadManyThroughAsync((0, ts_mockito_1.deepEqual)([loadParams]), (0, ts_mockito_1.anything)())).thenResolve(new Map());
            const secondaryEntityCache = (0, ts_mockito_1.instance)(secondaryEntityCacheMock);
            const secondaryCacheLoader = new TestSecondaryRedisCacheLoader(secondaryEntityCache, SimpleTestEntity_1.default.loader(vc1));
            await secondaryCacheLoader.loadManyAsync([loadParams]);
            (0, ts_mockito_1.verify)(secondaryEntityCacheMock.loadManyThroughAsync((0, ts_mockito_1.deepEqual)([loadParams]), (0, ts_mockito_1.anything)())).once();
        });
        it('constructs and authorizes entities', async () => {
            const vc1 = new ViewerContext_1.default((0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)());
            const createdEntity = await SimpleTestEntity_1.default.creator(vc1).enforceCreateAsync();
            const loadParams = { id: createdEntity.getID() };
            const secondaryEntityCacheMock = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(secondaryEntityCacheMock.loadManyThroughAsync((0, ts_mockito_1.deepEqual)([loadParams]), (0, ts_mockito_1.anything)())).thenResolve(new Map([[loadParams, createdEntity.getAllFields()]]));
            const secondaryEntityCache = (0, ts_mockito_1.instance)(secondaryEntityCacheMock);
            const loader = SimpleTestEntity_1.default.loader(vc1);
            const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(loader['privacyPolicy']);
            const secondaryCacheLoader = new TestSecondaryRedisCacheLoader(secondaryEntityCache, loader);
            const result = await secondaryCacheLoader.loadManyAsync([loadParams]);
            expect(result.get(loadParams)?.enforceValue().getID()).toEqual(createdEntity.getID());
            (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeReadAsync(vc1, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityNonTransactionalQueryContext), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).once();
        });
    });
    describe('invalidateManyAsync', () => {
        it('calls invalidate on the secondary cache', async () => {
            const vc1 = new ViewerContext_1.default((0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)());
            const createdEntity = await SimpleTestEntity_1.default.creator(vc1).enforceCreateAsync();
            const loadParams = { id: createdEntity.getID() };
            const secondaryEntityCacheMock = (0, ts_mockito_1.mock)();
            const secondaryEntityCache = (0, ts_mockito_1.instance)(secondaryEntityCacheMock);
            const loader = SimpleTestEntity_1.default.loader(vc1);
            const secondaryCacheLoader = new TestSecondaryRedisCacheLoader(secondaryEntityCache, loader);
            await secondaryCacheLoader.invalidateManyAsync([loadParams]);
            (0, ts_mockito_1.verify)(secondaryEntityCacheMock.invalidateManyAsync((0, ts_mockito_1.deepEqual)([loadParams]))).once();
        });
    });
});
//# sourceMappingURL=EntitySecondaryCacheLoader-test.js.map