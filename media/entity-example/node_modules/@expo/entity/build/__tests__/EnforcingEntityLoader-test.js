"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
const ts_mockito_1 = require("ts-mockito");
const AuthorizationResultBasedEntityLoader_1 = __importDefault(require("../AuthorizationResultBasedEntityLoader"));
const EnforcingEntityLoader_1 = __importDefault(require("../EnforcingEntityLoader"));
describe(EnforcingEntityLoader_1.default, () => {
    describe('loadManyByFieldEqualingManyAsync', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByFieldEqualingManyAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve(new Map(Object.entries({
                hello: [(0, results_1.result)(rejection)],
            })));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByFieldEqualingManyAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByFieldEqualingManyAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve(new Map(Object.entries({
                hello: [(0, results_1.result)(resolved)],
            })));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByFieldEqualingManyAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toEqual(new Map(Object.entries({
                hello: [resolved],
            })));
        });
    });
    describe('loadManyByFieldEqualingAsync', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([(0, results_1.result)(rejection)]);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([(0, results_1.result)(resolved)]);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toEqual([resolved]);
        });
    });
    describe('loadByFieldEqualingAsync', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(rejection));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(resolved));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toEqual(resolved);
        });
        it('returns null when result is successful and no entity is found', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = null;
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(resolved));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toEqual(resolved);
        });
        it('throws when multiple matching entities are found', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const multipleEntitiesError = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenReject(multipleEntitiesError);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).rejects.toEqual(multipleEntitiesError);
        });
    });
    describe('loadByIDAsync', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByIDAsync((0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(rejection));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByIDAsync((0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByIDAsync((0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(resolved));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByIDAsync((0, ts_mockito_1.anything)())).resolves.toEqual(resolved);
        });
    });
    describe('loadByIDNullableAsync', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByIDNullableAsync((0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(rejection));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByIDNullableAsync((0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByIDNullableAsync((0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(resolved));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByIDNullableAsync((0, ts_mockito_1.anything)())).resolves.toEqual(resolved);
        });
        it('returns null when non-existent object', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = null;
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadByIDNullableAsync((0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(resolved));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadByIDNullableAsync((0, ts_mockito_1.anything)())).resolves.toEqual(resolved);
        });
    });
    describe('loadManyByIDsAsync', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByIDsAsync((0, ts_mockito_1.anything)())).thenResolve(new Map(Object.entries({
                hello: (0, results_1.result)(rejection),
            })));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByIDsAsync((0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByIDsAsync((0, ts_mockito_1.anything)())).thenResolve(new Map(Object.entries({
                hello: (0, results_1.result)(resolved),
            })));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByIDsAsync((0, ts_mockito_1.anything)())).resolves.toEqual(new Map(Object.entries({
                hello: resolved,
            })));
        });
    });
    describe('loadManyByIDsNullableAsync', () => {
        it('throws when result is unsuccessful even when there is a null result', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByIDsNullableAsync((0, ts_mockito_1.anything)())).thenResolve(new Map(Object.entries({
                hello: (0, results_1.result)(rejection),
                world: null,
            })));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByIDsNullableAsync((0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByIDsNullableAsync((0, ts_mockito_1.anything)())).thenResolve(new Map(Object.entries({
                hello: (0, results_1.result)(resolved),
                world: null,
            })));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByIDsNullableAsync((0, ts_mockito_1.anything)())).resolves.toEqual(new Map(Object.entries({
                hello: resolved,
                world: null,
            })));
        });
    });
    describe('loadFirstByFieldEqualityConjunction', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadFirstByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(rejection));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadFirstByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadFirstByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve((0, results_1.result)(resolved));
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadFirstByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toEqual(resolved);
        });
        it('returns null when the query is successful but no rows match', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadFirstByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve(null);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadFirstByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toBeNull();
        });
    });
    describe('loadManyByFieldEqualityConjunction', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([(0, results_1.result)(rejection)]);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([(0, results_1.result)(resolved)]);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByFieldEqualityConjunctionAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toEqual([resolved]);
        });
    });
    describe('loadManyByRawWhereClause', () => {
        it('throws when result is unsuccessful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const rejection = new Error();
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByRawWhereClauseAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([(0, results_1.result)(rejection)]);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByRawWhereClauseAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).rejects.toThrow(rejection);
        });
        it('returns value when result is successful', async () => {
            const nonEnforcingEntityLoaderMock = (0, ts_mockito_1.mock)(AuthorizationResultBasedEntityLoader_1.default);
            const resolved = {};
            (0, ts_mockito_1.when)(nonEnforcingEntityLoaderMock.loadManyByRawWhereClauseAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([(0, results_1.result)(resolved)]);
            const nonEnforcingEntityLoader = (0, ts_mockito_1.instance)(nonEnforcingEntityLoaderMock);
            const enforcingEntityLoader = new EnforcingEntityLoader_1.default(nonEnforcingEntityLoader);
            await expect(enforcingEntityLoader.loadManyByRawWhereClauseAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).resolves.toEqual([resolved]);
        });
    });
    it('has the same method names as EntityLoader', () => {
        const enforcingLoaderProperties = Object.getOwnPropertyNames(EnforcingEntityLoader_1.default.prototype);
        const nonEnforcingLoaderProperties = Object.getOwnPropertyNames(AuthorizationResultBasedEntityLoader_1.default.prototype);
        // ensure known differences still exist for sanity check
        const knownLoaderOnlyDifferences = ['validateFieldValues'];
        expect(nonEnforcingLoaderProperties).toEqual(expect.arrayContaining(knownLoaderOnlyDifferences));
        const loaderPropertiesWithoutKnownDifferences = nonEnforcingLoaderProperties.filter((p) => !knownLoaderOnlyDifferences.includes(p));
        expect(enforcingLoaderProperties).toEqual(loaderPropertiesWithoutKnownDifferences);
    });
});
//# sourceMappingURL=EnforcingEntityLoader-test.js.map