"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
const ts_mockito_1 = require("ts-mockito");
const uuid_1 = require("uuid");
const EntityDatabaseAdapter_1 = require("../EntityDatabaseAdapter");
const EntityLoader_1 = __importDefault(require("../EntityLoader"));
const ViewerContext_1 = __importDefault(require("../ViewerContext"));
const entityUtils_1 = require("../entityUtils");
const EntityNotFoundError_1 = __importDefault(require("../errors/EntityNotFoundError"));
const EntityDataManager_1 = __importDefault(require("../internal/EntityDataManager"));
const ReadThroughEntityCache_1 = __importDefault(require("../internal/ReadThroughEntityCache"));
const TestEntity_1 = __importStar(require("../testfixtures/TestEntity"));
const StubCacheAdapter_1 = require("../utils/testing/StubCacheAdapter");
const StubDatabaseAdapter_1 = __importDefault(require("../utils/testing/StubDatabaseAdapter"));
const StubQueryContextProvider_1 = __importDefault(require("../utils/testing/StubQueryContextProvider"));
describe(EntityLoader_1.default, () => {
    it('loads entities', async () => {
        const dateToInsert = new Date();
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const id1 = (0, uuid_1.v4)();
        const id2 = (0, uuid_1.v4)();
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
            [
                TestEntity_1.testEntityConfiguration.tableName,
                [
                    {
                        customIdField: id1,
                        testIndexedField: 'h1',
                        intField: 5,
                        stringField: 'huh',
                        dateField: dateToInsert,
                        nullableField: null,
                    },
                    {
                        customIdField: id2,
                        testIndexedField: 'h2',
                        intField: 3,
                        stringField: 'huh',
                        dateField: dateToInsert,
                        nullableField: null,
                    },
                ],
            ],
        ])));
        const privacyPolicy = new TestEntity_1.TestEntityPrivacyPolicy();
        const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const dataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)()), TestEntity_1.default.name);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManager, metricsAdapter);
        const entity = await (0, results_1.enforceAsyncResult)(entityLoader.withAuthorizationResults().loadByIDAsync(id1));
        expect(entity.getID()).toEqual(id1);
        expect(entity.getField('dateField')).toEqual(dateToInsert);
        const entities = await (0, entityUtils_1.enforceResultsAsync)(entityLoader.withAuthorizationResults().loadManyByFieldEqualingAsync('stringField', 'huh'));
        expect(entities.map((m) => m.getID())).toEqual([id1, id2]);
        const entityResultNumber3 = await entityLoader
            .withAuthorizationResults()
            .loadByFieldEqualingAsync('intField', 3);
        expect(entityResultNumber3).not.toBeNull();
        expect(entityResultNumber3.enforceValue().getID()).toEqual(id2);
        const entityResultNumber4 = await entityLoader
            .withAuthorizationResults()
            .loadByFieldEqualingAsync('intField', 4);
        expect(entityResultNumber4).toBeNull();
        const entityResultDuplicateValues = await entityLoader
            .enforcing()
            .loadManyByFieldEqualingManyAsync('stringField', ['huh', 'huh']);
        expect(entityResultDuplicateValues.size).toBe(1);
        expect(entityResultDuplicateValues.get('huh')?.map((m) => m.getID())).toEqual([id1, id2]);
        await expect(entityLoader.withAuthorizationResults().loadByFieldEqualingAsync('stringField', 'huh')).rejects.toThrowError('loadByFieldEqualing: Multiple entities of type TestEntity found for stringField=huh');
        await expect(entityLoader.withAuthorizationResults().loadByIDNullableAsync((0, uuid_1.v4)())).resolves.toBeNull();
        await expect(entityLoader.withAuthorizationResults().loadByIDNullableAsync(id1)).resolves.not.toBeNull();
        const nonExistentId = (0, uuid_1.v4)();
        const manyIdResults = await entityLoader
            .withAuthorizationResults()
            .loadManyByIDsNullableAsync([nonExistentId, id1]);
        expect(manyIdResults.get(nonExistentId)).toBeNull();
        expect(manyIdResults.get(id1)).not.toBeNull();
        await expect((0, results_1.enforceAsyncResult)(entityLoader.withAuthorizationResults().loadByIDAsync(nonExistentId))).rejects.toThrow(EntityNotFoundError_1.default);
        await expect(entityLoader.withAuthorizationResults().loadByIDAsync('not-a-uuid')).rejects.toThrowError('Entity field not valid: TestEntity (customIdField = not-a-uuid)');
    });
    it('loads entities with loadManyByFieldEqualityConjunction', async () => {
        const privacyPolicy = new TestEntity_1.TestEntityPrivacyPolicy();
        const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(privacyPolicy);
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const id1 = (0, uuid_1.v4)();
        const id2 = (0, uuid_1.v4)();
        const id3 = (0, uuid_1.v4)();
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
            [
                TestEntity_1.testEntityConfiguration.tableName,
                [
                    {
                        customIdField: id1,
                        stringField: 'huh',
                        intField: 4,
                        testIndexedField: '4',
                        dateField: new Date(),
                        nullableField: null,
                    },
                    {
                        customIdField: id2,
                        stringField: 'huh',
                        intField: 4,
                        testIndexedField: '5',
                        dateField: new Date(),
                        nullableField: null,
                    },
                    {
                        customIdField: id3,
                        stringField: 'huh2',
                        intField: 4,
                        testIndexedField: '6',
                        dateField: new Date(),
                        nullableField: null,
                    },
                ],
            ],
        ])));
        const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const dataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)()), TestEntity_1.default.name);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManager, metricsAdapter);
        const entities = await (0, entityUtils_1.enforceResultsAsync)(entityLoader.withAuthorizationResults().loadManyByFieldEqualityConjunctionAsync([
            {
                fieldName: 'stringField',
                fieldValue: 'huh',
            },
            {
                fieldName: 'intField',
                fieldValues: [4],
            },
        ]));
        expect(entities).toHaveLength(2);
        (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeReadAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).twice();
        await expect(entityLoader
            .withAuthorizationResults()
            .loadManyByFieldEqualityConjunctionAsync([
            { fieldName: 'customIdField', fieldValue: 'not-a-uuid' },
        ])).rejects.toThrowError('Entity field not valid: TestEntity (customIdField = not-a-uuid)');
    });
    it('loads entities with loadFirstByFieldEqualityConjunction', async () => {
        const privacyPolicy = new TestEntity_1.TestEntityPrivacyPolicy();
        const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(privacyPolicy);
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const id1 = (0, uuid_1.v4)();
        const id2 = (0, uuid_1.v4)();
        const id3 = (0, uuid_1.v4)();
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
            [
                TestEntity_1.testEntityConfiguration.tableName,
                [
                    {
                        customIdField: id1,
                        stringField: 'huh',
                        intField: 4,
                        testIndexedField: '4',
                        dateField: new Date(),
                        nullableField: null,
                    },
                    {
                        customIdField: id2,
                        stringField: 'huh',
                        intField: 4,
                        testIndexedField: '5',
                        dateField: new Date(),
                        nullableField: null,
                    },
                    {
                        customIdField: id3,
                        stringField: 'huh2',
                        intField: 4,
                        testIndexedField: '6',
                        dateField: new Date(),
                        nullableField: null,
                    },
                ],
            ],
        ])));
        const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const dataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)()), TestEntity_1.default.name);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManager, metricsAdapter);
        const result = await entityLoader
            .withAuthorizationResults()
            .loadFirstByFieldEqualityConjunctionAsync([
            {
                fieldName: 'stringField',
                fieldValue: 'huh',
            },
            {
                fieldName: 'intField',
                fieldValue: 4,
            },
        ], { orderBy: [{ fieldName: 'testIndexedField', order: EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING }] });
        expect(result).not.toBeNull();
        expect(result.ok).toBe(true);
        expect(result.enforceValue().getField('testIndexedField')).toEqual('5');
        (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeReadAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).once();
    });
    it('loads entities with loadManyByRawWhereClauseAsync', async () => {
        const privacyPolicy = new TestEntity_1.TestEntityPrivacyPolicy();
        const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(privacyPolicy);
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const dataManagerMock = (0, ts_mockito_1.mock)(EntityDataManager_1.default);
        (0, ts_mockito_1.when)(dataManagerMock.loadManyByRawWhereClauseAsync(queryContext, (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve([
            {
                customIdField: 'id',
                stringField: 'huh',
                intField: 4,
                testIndexedField: '4',
                dateField: new Date(),
                nullableField: null,
            },
        ]);
        const dataManager = (0, ts_mockito_1.instance)(dataManagerMock);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManager, metricsAdapter);
        const result = await entityLoader
            .withAuthorizationResults()
            .loadManyByRawWhereClauseAsync('id = ?', [1], {
            orderBy: [{ fieldName: 'testIndexedField', order: EntityDatabaseAdapter_1.OrderByOrdering.DESCENDING }],
        });
        expect(result).toHaveLength(1);
        expect(result[0]).not.toBeNull();
        expect(result[0].ok).toBe(true);
        expect(result[0].enforceValue().getField('testIndexedField')).toEqual('4');
        (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeReadAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).once();
    });
    it('authorizes loaded entities', async () => {
        const privacyPolicy = new TestEntity_1.TestEntityPrivacyPolicy();
        const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(privacyPolicy);
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const id1 = (0, uuid_1.v4)();
        const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([
            [
                TestEntity_1.testEntityConfiguration.tableName,
                [
                    {
                        customIdField: id1,
                        stringField: 'huh',
                        testIndexedField: '1',
                        intField: 3,
                        dateField: new Date(),
                        nullableField: null,
                    },
                ],
            ],
        ])));
        const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
        const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
        const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
        const dataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)()), TestEntity_1.default.name);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManager, metricsAdapter);
        const entity = await (0, results_1.enforceAsyncResult)(entityLoader.withAuthorizationResults().loadByIDAsync(id1));
        (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeReadAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, entity, (0, ts_mockito_1.anything)())).once();
    });
    it('invalidates upon invalidate one', async () => {
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const privacyPolicy = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(TestEntity_1.TestEntityPrivacyPolicy));
        const dataManagerMock = (0, ts_mockito_1.mock)();
        const dataManagerInstance = (0, ts_mockito_1.instance)(dataManagerMock);
        const id1 = (0, uuid_1.v4)();
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManagerInstance, metricsAdapter);
        await entityLoader.utils().invalidateFieldsAsync({ customIdField: id1 });
        (0, ts_mockito_1.verify)(dataManagerMock.invalidateObjectFieldsAsync((0, ts_mockito_1.deepEqual)({ customIdField: id1 }))).once();
    });
    it('invalidates upon invalidate by field', async () => {
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const privacyPolicy = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(TestEntity_1.TestEntityPrivacyPolicy));
        const dataManagerMock = (0, ts_mockito_1.mock)();
        const dataManagerInstance = (0, ts_mockito_1.instance)(dataManagerMock);
        const id1 = (0, uuid_1.v4)();
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManagerInstance, metricsAdapter);
        await entityLoader.utils().invalidateFieldsAsync({ customIdField: id1 });
        (0, ts_mockito_1.verify)(dataManagerMock.invalidateObjectFieldsAsync((0, ts_mockito_1.deepEqual)({ customIdField: id1 }))).once();
    });
    it('invalidates upon invalidate by entity', async () => {
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const privacyPolicy = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(TestEntity_1.TestEntityPrivacyPolicy));
        const dataManagerMock = (0, ts_mockito_1.mock)();
        const dataManagerInstance = (0, ts_mockito_1.instance)(dataManagerMock);
        const id1 = (0, uuid_1.v4)();
        const entityMock = (0, ts_mockito_1.mock)(TestEntity_1.default);
        (0, ts_mockito_1.when)(entityMock.getAllDatabaseFields()).thenReturn({ customIdField: id1 });
        const entityInstance = (0, ts_mockito_1.instance)(entityMock);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManagerInstance, metricsAdapter);
        await entityLoader.utils().invalidateEntityAsync(entityInstance);
        (0, ts_mockito_1.verify)(dataManagerMock.invalidateObjectFieldsAsync((0, ts_mockito_1.deepEqual)({ customIdField: id1 }))).once();
    });
    it('returns error result when not allowed', async () => {
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const privacyPolicyMock = (0, ts_mockito_1.mock)(TestEntity_1.TestEntityPrivacyPolicy);
        const dataManagerMock = (0, ts_mockito_1.mock)();
        const id1 = (0, uuid_1.v4)();
        (0, ts_mockito_1.when)(dataManagerMock.loadManyByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenResolve(new Map().set(id1, [{ customIdField: id1 }]));
        const rejectionError = new Error();
        (0, ts_mockito_1.when)(privacyPolicyMock.authorizeReadAsync(viewerContext, queryContext, privacyPolicyEvaluationContext, (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).thenReject(rejectionError);
        const privacyPolicy = (0, ts_mockito_1.instance)(privacyPolicyMock);
        const dataManagerInstance = (0, ts_mockito_1.instance)(dataManagerMock);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManagerInstance, metricsAdapter);
        const entityResult = await entityLoader.withAuthorizationResults().loadByIDAsync(id1);
        expect(entityResult.ok).toBe(false);
        expect(entityResult.reason).toEqual(rejectionError);
        expect(entityResult.value).toBe(undefined);
    });
    it('throws upon database adapter error', async () => {
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const privacyPolicy = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(TestEntity_1.TestEntityPrivacyPolicy));
        const dataManagerMock = (0, ts_mockito_1.mock)();
        const error = new Error();
        (0, ts_mockito_1.when)(dataManagerMock.loadManyByFieldEqualingAsync((0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenReject(error);
        const dataManagerInstance = (0, ts_mockito_1.instance)(dataManagerMock);
        const entityLoader = new EntityLoader_1.default(viewerContext, queryContext, privacyPolicyEvaluationContext, TestEntity_1.testEntityConfiguration, TestEntity_1.default, 
        /* entitySelectedFields */ undefined, privacyPolicy, dataManagerInstance, metricsAdapter);
        const loadByValue = (0, uuid_1.v4)();
        await expect(entityLoader.withAuthorizationResults().loadByIDAsync(loadByValue)).rejects.toEqual(error);
        await expect(entityLoader.enforcing().loadByIDAsync(loadByValue)).rejects.toEqual(error);
        await expect(entityLoader.withAuthorizationResults().loadManyByIDsAsync([loadByValue])).rejects.toEqual(error);
        await expect(entityLoader.enforcing().loadManyByIDsAsync([loadByValue])).rejects.toEqual(error);
        await expect(entityLoader.withAuthorizationResults().loadManyByIDsNullableAsync([loadByValue])).rejects.toEqual(error);
        await expect(entityLoader.enforcing().loadManyByIDsNullableAsync([loadByValue])).rejects.toEqual(error);
        await expect(entityLoader
            .withAuthorizationResults()
            .loadManyByFieldEqualingAsync('customIdField', loadByValue)).rejects.toEqual(error);
        await expect(entityLoader.enforcing().loadManyByFieldEqualingAsync('customIdField', loadByValue)).rejects.toEqual(error);
        await expect(entityLoader
            .withAuthorizationResults()
            .loadManyByFieldEqualingManyAsync('customIdField', [loadByValue])).rejects.toEqual(error);
        await expect(entityLoader.enforcing().loadManyByFieldEqualingManyAsync('customIdField', [loadByValue])).rejects.toEqual(error);
    });
});
//# sourceMappingURL=EntityLoader-test.js.map