"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts_mockito_1 = require("ts-mockito");
const GenericEntityCacheAdapter_1 = __importDefault(require("../GenericEntityCacheAdapter"));
const ReadThroughEntityCache_1 = require("../internal/ReadThroughEntityCache");
describe(GenericEntityCacheAdapter_1.default, () => {
    describe('loadManyAsync', () => {
        it('returns appropriate cache results', async () => {
            const mockGenericCacher = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(mockGenericCacher.makeCacheKey('id', (0, ts_mockito_1.anyString)())).thenCall((fieldName, fieldValue) => {
                return `${fieldName}.${fieldValue}`;
            });
            (0, ts_mockito_1.when)(mockGenericCacher.loadManyAsync((0, ts_mockito_1.deepEqual)(['id.wat', 'id.who', 'id.why']))).thenResolve(new Map([
                ['id.wat', { status: ReadThroughEntityCache_1.CacheStatus.HIT, item: { id: 'wat' } }],
                ['id.who', { status: ReadThroughEntityCache_1.CacheStatus.NEGATIVE }],
                ['id.why', { status: ReadThroughEntityCache_1.CacheStatus.MISS }],
            ]));
            const cacheAdapter = new GenericEntityCacheAdapter_1.default((0, ts_mockito_1.instance)(mockGenericCacher));
            const results = await cacheAdapter.loadManyAsync('id', ['wat', 'who', 'why']);
            expect(results.get('wat')).toMatchObject({ status: ReadThroughEntityCache_1.CacheStatus.HIT, item: { id: 'wat' } });
            expect(results.get('who')).toMatchObject({ status: ReadThroughEntityCache_1.CacheStatus.NEGATIVE });
            expect(results.get('why')).toMatchObject({ status: ReadThroughEntityCache_1.CacheStatus.MISS });
            expect(results.size).toBe(3);
            (0, ts_mockito_1.verify)(mockGenericCacher.loadManyAsync((0, ts_mockito_1.anything)())).once();
        });
        it('returns empty map when passed empty array of fieldValues', async () => {
            const mockGenericCacher = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(mockGenericCacher.loadManyAsync((0, ts_mockito_1.deepEqual)([]))).thenResolve(new Map([]));
            const cacheAdapter = new GenericEntityCacheAdapter_1.default((0, ts_mockito_1.instance)(mockGenericCacher));
            const results = await cacheAdapter.loadManyAsync('id', []);
            expect(results).toEqual(new Map());
        });
    });
    describe('cacheManyAsync', () => {
        it('correctly caches all objects', async () => {
            const mockGenericCacher = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(mockGenericCacher.makeCacheKey('id', (0, ts_mockito_1.anyString)())).thenCall((fieldName, fieldValue) => {
                return `${fieldName}.${fieldValue}`;
            });
            const cacheAdapter = new GenericEntityCacheAdapter_1.default((0, ts_mockito_1.instance)(mockGenericCacher));
            await cacheAdapter.cacheManyAsync('id', new Map([['wat', { id: 'wat' }]]));
            (0, ts_mockito_1.verify)(mockGenericCacher.cacheManyAsync((0, ts_mockito_1.deepEqual)(new Map([['id.wat', { id: 'wat' }]])))).once();
        });
    });
    describe('cacheDBMissesAsync', () => {
        it('correctly caches misses', async () => {
            const mockGenericCacher = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(mockGenericCacher.makeCacheKey('id', (0, ts_mockito_1.anyString)())).thenCall((fieldName, fieldValue) => {
                return `${fieldName}.${fieldValue}`;
            });
            const cacheAdapter = new GenericEntityCacheAdapter_1.default((0, ts_mockito_1.instance)(mockGenericCacher));
            await cacheAdapter.cacheDBMissesAsync('id', ['wat']);
            (0, ts_mockito_1.verify)(mockGenericCacher.cacheDBMissesAsync((0, ts_mockito_1.deepEqual)(['id.wat']))).once();
        });
    });
    describe('invalidateManyAsync', () => {
        it('invalidates correctly', async () => {
            const mockGenericCacher = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(mockGenericCacher.makeCacheKey('id', (0, ts_mockito_1.anyString)())).thenCall((fieldName, fieldValue) => {
                return `${fieldName}.${fieldValue}`;
            });
            const cacheAdapter = new GenericEntityCacheAdapter_1.default((0, ts_mockito_1.instance)(mockGenericCacher));
            await cacheAdapter.invalidateManyAsync('id', ['wat']);
            (0, ts_mockito_1.verify)(mockGenericCacher.invalidateManyAsync((0, ts_mockito_1.deepEqual)(['id.wat']))).once();
        });
        it('returns when passed empty array of fieldValues', async () => {
            const mockGenericCacher = (0, ts_mockito_1.mock)();
            (0, ts_mockito_1.when)(mockGenericCacher.makeCacheKey('id', (0, ts_mockito_1.anyString)())).thenCall((fieldName, fieldValue) => {
                return `${fieldName}.${fieldValue}`;
            });
            const cacheAdapter = new GenericEntityCacheAdapter_1.default((0, ts_mockito_1.instance)(mockGenericCacher));
            await cacheAdapter.invalidateManyAsync('id', []);
            (0, ts_mockito_1.verify)(mockGenericCacher.invalidateManyAsync((0, ts_mockito_1.deepEqual)([]))).once();
        });
    });
});
//# sourceMappingURL=GenericEntityCacheAdapter-test.js.map