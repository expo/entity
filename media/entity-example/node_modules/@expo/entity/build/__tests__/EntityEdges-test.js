"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const invariant_1 = __importDefault(require("invariant"));
const Entity_1 = __importDefault(require("../Entity"));
const EntityConfiguration_1 = __importDefault(require("../EntityConfiguration"));
const EntityFieldDefinition_1 = require("../EntityFieldDefinition");
const EntityFields_1 = require("../EntityFields");
const EntityMutationInfo_1 = require("../EntityMutationInfo");
const EntityMutationTriggerConfiguration_1 = require("../EntityMutationTriggerConfiguration");
const EntityPrivacyPolicy_1 = __importStar(require("../EntityPrivacyPolicy"));
const ReadThroughEntityCache_1 = require("../internal/ReadThroughEntityCache");
const PrivacyPolicyRule_1 = __importStar(require("../rules/PrivacyPolicyRule"));
const TestViewerContext_1 = __importDefault(require("../testfixtures/TestViewerContext"));
const createUnitTestEntityCompanionProvider_1 = require("../utils/testing/createUnitTestEntityCompanionProvider");
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
const makeEntityClasses = (edgeDeletionBehavior) => {
    const triggerExecutionCounts = {
        ParentEntityDeletion: 0,
        ChildEntityDeletion: 0,
        GrandChildEntityDeletion: 0,
        ParentEntityUpdate: 0,
        ChildEntityUpdate: 0,
        GrandChildEntityUpdate: 0,
    };
    const privacyPolicyEvaluationRecords = {
        shouldRecord: false,
        ParentEntity: {
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [],
        },
        ChildEntity: {
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [],
        },
        GrandChildEntity: {
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
            [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [],
        },
    };
    class AlwaysAllowPrivacyPolicyRuleThatRecords extends PrivacyPolicyRule_1.default {
        action;
        constructor(action) {
            super();
            this.action = action;
        }
        async evaluateAsync(_viewerContext, _queryContext, evaluationContext, entity) {
            if (privacyPolicyEvaluationRecords.shouldRecord) {
                privacyPolicyEvaluationRecords[entity.constructor.name][this.action].push(evaluationContext);
            }
            return PrivacyPolicyRule_1.RuleEvaluationResult.ALLOW;
        }
    }
    class TestEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
        readRules = [
            new AlwaysAllowPrivacyPolicyRuleThatRecords(EntityPrivacyPolicy_1.EntityAuthorizationAction.READ),
        ];
        createRules = [
            new AlwaysAllowPrivacyPolicyRuleThatRecords(EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE),
        ];
        updateRules = [
            new AlwaysAllowPrivacyPolicyRuleThatRecords(EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE),
        ];
        deleteRules = [
            new AlwaysAllowPrivacyPolicyRuleThatRecords(EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE),
        ];
    }
    class ParentCheckInfoDeletionTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
        async executeAsync(_viewerContext, _queryContext, _entity, mutationInfo) {
            (0, invariant_1.default)(mutationInfo.type === EntityMutationInfo_1.EntityMutationType.DELETE, 'invalid EntityMutationType');
            if (mutationInfo.cascadingDeleteCause !== null) {
                throw new Error('Parent entity should not have casade delete cause');
            }
            triggerExecutionCounts.ParentEntityDeletion++;
        }
    }
    class ParentCheckInfoUpdateTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
        async executeAsync(_viewerContext, _queryContext, _entity, mutationInfo) {
            (0, invariant_1.default)(mutationInfo.type === EntityMutationInfo_1.EntityMutationType.UPDATE, 'invalid EntityMutationType');
            if (mutationInfo.cascadingDeleteCause !== null) {
                throw new Error('Parent entity should not have casade delete cause');
            }
            triggerExecutionCounts.ParentEntityUpdate++;
        }
    }
    class ChildCheckInfoDeletionTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
        async executeAsync(_viewerContext, _queryContext, _entity, mutationInfo) {
            (0, invariant_1.default)(mutationInfo.type === EntityMutationInfo_1.EntityMutationType.DELETE, 'invalid EntityMutationType');
            if (mutationInfo.cascadingDeleteCause === null) {
                throw new Error('Child entity should have casade delete cause');
            }
            const cascadingDeleteCauseEntity = mutationInfo.cascadingDeleteCause.entity;
            if (!(cascadingDeleteCauseEntity instanceof ParentEntity)) {
                throw new Error('Child entity should have casade delete cause entity of type ParentEntity');
            }
            const secondLevelCascadingDeleteCause = mutationInfo.cascadingDeleteCause.cascadingDeleteCause;
            if (secondLevelCascadingDeleteCause) {
                throw new Error('Child entity should not have two-level casade delete cause');
            }
            triggerExecutionCounts.ChildEntityDeletion++;
        }
    }
    class ChildCheckInfoUpdateTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
        async executeAsync(_viewerContext, _queryContext, _entity, mutationInfo) {
            (0, invariant_1.default)(mutationInfo.type === EntityMutationInfo_1.EntityMutationType.UPDATE, 'invalid EntityMutationType');
            if (mutationInfo.cascadingDeleteCause === null) {
                throw new Error('Child entity should have casade delete cause');
            }
            const cascadingDeleteCauseEntity = mutationInfo.cascadingDeleteCause.entity;
            if (!(cascadingDeleteCauseEntity instanceof ParentEntity)) {
                throw new Error('Child entity should have casade delete cause entity of type ParentEntity');
            }
            const secondLevelCascadingDeleteCause = mutationInfo.cascadingDeleteCause.cascadingDeleteCause;
            if (secondLevelCascadingDeleteCause) {
                throw new Error('Child entity should not have two-level casade delete cause');
            }
            triggerExecutionCounts.ChildEntityUpdate++;
        }
    }
    class GrandChildCheckInfoDeletionTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
        async executeAsync(_viewerContext, _queryContext, _entity, mutationInfo) {
            (0, invariant_1.default)(mutationInfo.type === EntityMutationInfo_1.EntityMutationType.DELETE, 'invalid EntityMutationType');
            if (mutationInfo.cascadingDeleteCause === null) {
                throw new Error('GrandChild entity should have cascade delete cause');
            }
            const cascadingDeleteCauseEntity = mutationInfo.cascadingDeleteCause.entity;
            if (!(cascadingDeleteCauseEntity instanceof ChildEntity)) {
                throw new Error('GrandChild entity should have cascade delete cause entity of type ChildEntity');
            }
            const secondLevelCascadingDeleteCause = mutationInfo.cascadingDeleteCause.cascadingDeleteCause;
            if (!secondLevelCascadingDeleteCause) {
                throw new Error('GrandChild entity should have two-level casade delete cause');
            }
            const secondLevelCascadingDeleteCauseEntity = secondLevelCascadingDeleteCause.entity;
            if (!(secondLevelCascadingDeleteCauseEntity instanceof ParentEntity)) {
                throw new Error('GrandChild entity should have second level casade delete cause entity of type ParentEntity');
            }
            const thirdLevelCascadingDeleteCause = secondLevelCascadingDeleteCause.cascadingDeleteCause;
            if (thirdLevelCascadingDeleteCause) {
                throw new Error('GrandChild entity should not have three-level casade delete cause');
            }
            triggerExecutionCounts.GrandChildEntityDeletion++;
        }
    }
    class GrandChildCheckInfoUpdateTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
        async executeAsync(_viewerContext, _queryContext, _entity, mutationInfo) {
            (0, invariant_1.default)(mutationInfo.type === EntityMutationInfo_1.EntityMutationType.UPDATE, 'invalid EntityMutationType');
            if (mutationInfo.cascadingDeleteCause === null) {
                throw new Error('GrandChild entity should have cascade delete cause');
            }
            const cascadingDeleteCauseEntity = mutationInfo.cascadingDeleteCause.entity;
            if (!(cascadingDeleteCauseEntity instanceof ChildEntity)) {
                throw new Error('GrandChild entity should have cascade delete cause entity of type ChildEntity');
            }
            const secondLevelCascadingDeleteCause = mutationInfo.cascadingDeleteCause.cascadingDeleteCause;
            if (!secondLevelCascadingDeleteCause) {
                throw new Error('GrandChild entity should have two-level casade delete cause');
            }
            const secondLevelCascadingDeleteCauseEntity = secondLevelCascadingDeleteCause.entity;
            if (!(secondLevelCascadingDeleteCauseEntity instanceof ParentEntity)) {
                throw new Error('GrandChild entity should have second level casade delete cause entity of type ParentEntity');
            }
            const thirdLevelCascadingDeleteCause = secondLevelCascadingDeleteCause.cascadingDeleteCause;
            if (thirdLevelCascadingDeleteCause) {
                throw new Error('GrandChild entity should not have three-level casade delete cause');
            }
            triggerExecutionCounts.GrandChildEntityUpdate++;
        }
    }
    class OtherEntity extends Entity_1.default {
        static defineCompanionDefinition() {
            return {
                entityClass: ParentEntity,
                entityConfiguration: otherEntityConfiguration,
                privacyPolicyClass: TestEntityPrivacyPolicy,
            };
        }
    }
    class ParentEntity extends Entity_1.default {
        static defineCompanionDefinition() {
            return {
                entityClass: ParentEntity,
                entityConfiguration: parentEntityConfiguration,
                privacyPolicyClass: TestEntityPrivacyPolicy,
                mutationTriggers: {
                    beforeDelete: [new ParentCheckInfoDeletionTrigger()],
                    afterDelete: [new ParentCheckInfoDeletionTrigger()],
                    beforeUpdate: [new ParentCheckInfoUpdateTrigger()],
                    afterUpdate: [new ParentCheckInfoUpdateTrigger()],
                },
            };
        }
    }
    class ChildEntity extends Entity_1.default {
        static defineCompanionDefinition() {
            return {
                entityClass: ChildEntity,
                entityConfiguration: childEntityConfiguration,
                privacyPolicyClass: TestEntityPrivacyPolicy,
                mutationTriggers: {
                    beforeDelete: [new ChildCheckInfoDeletionTrigger()],
                    afterDelete: [new ChildCheckInfoDeletionTrigger()],
                    beforeUpdate: [new ChildCheckInfoUpdateTrigger()],
                    afterUpdate: [new ChildCheckInfoUpdateTrigger()],
                },
            };
        }
    }
    class GrandChildEntity extends Entity_1.default {
        static defineCompanionDefinition() {
            return {
                entityClass: GrandChildEntity,
                entityConfiguration: grandChildEntityConfiguration,
                privacyPolicyClass: TestEntityPrivacyPolicy,
                mutationTriggers: {
                    beforeDelete: [new GrandChildCheckInfoDeletionTrigger()],
                    afterDelete: [new GrandChildCheckInfoDeletionTrigger()],
                    beforeUpdate: [new GrandChildCheckInfoUpdateTrigger()],
                    afterUpdate: [new GrandChildCheckInfoUpdateTrigger()],
                },
            };
        }
    }
    const otherEntityConfiguration = new EntityConfiguration_1.default({
        idField: 'id',
        tableName: 'others',
        schema: {
            id: new EntityFields_1.UUIDField({
                columnName: 'id',
                cache: true,
            }),
        },
        databaseAdapterFlavor: 'postgres',
        cacheAdapterFlavor: 'redis',
    });
    const parentEntityConfiguration = new EntityConfiguration_1.default({
        idField: 'id',
        tableName: 'parents',
        inboundEdges: [ChildEntity],
        schema: {
            id: new EntityFields_1.UUIDField({
                columnName: 'id',
                cache: true,
            }),
        },
        databaseAdapterFlavor: 'postgres',
        cacheAdapterFlavor: 'redis',
    });
    const childEntityConfiguration = new EntityConfiguration_1.default({
        idField: 'id',
        tableName: 'children',
        inboundEdges: [GrandChildEntity],
        schema: {
            id: new EntityFields_1.UUIDField({
                columnName: 'id',
                cache: true,
            }),
            unused_other_edge_id: new EntityFields_1.UUIDField({
                columnName: 'unused_other_edge_id',
                association: {
                    associatedEntityClass: OtherEntity,
                    edgeDeletionBehavior,
                },
            }),
            parent_id: new EntityFields_1.UUIDField({
                columnName: 'parent_id',
                cache: true,
                association: {
                    associatedEntityClass: ParentEntity,
                    associatedEntityLookupByField: 'id', // sanity check that this functionality works by using it for one edge
                    edgeDeletionBehavior,
                },
            }),
        },
        databaseAdapterFlavor: 'postgres',
        cacheAdapterFlavor: 'redis',
    });
    const grandChildEntityConfiguration = new EntityConfiguration_1.default({
        idField: 'id',
        tableName: 'grandchildren',
        schema: {
            id: new EntityFields_1.UUIDField({
                columnName: 'id',
                cache: true,
            }),
            parent_id: new EntityFields_1.UUIDField({
                columnName: 'parent_id',
                cache: true,
                association: {
                    associatedEntityClass: ChildEntity,
                    edgeDeletionBehavior,
                },
            }),
        },
        databaseAdapterFlavor: 'postgres',
        cacheAdapterFlavor: 'redis',
    });
    return {
        ParentEntity,
        ChildEntity,
        GrandChildEntity,
        triggerExecutionCounts,
        privacyPolicyEvaluationRecords,
    };
};
describe('EntityMutator.processEntityDeletionForInboundEdgesAsync', () => {
    describe('EntityEdgeDeletionBehavior.CASCADE_DELETE', () => {
        it('deletes', async () => {
            const { ParentEntity, ChildEntity, GrandChildEntity, triggerExecutionCounts, privacyPolicyEvaluationRecords, } = makeEntityClasses(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE);
            const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
            const viewerContext = new TestViewerContext_1.default(companionProvider);
            const parent = await ParentEntity.creator(viewerContext).enforceCreateAsync();
            const child = await ChildEntity.creator(viewerContext)
                .setField('parent_id', parent.getID())
                .enforceCreateAsync();
            const grandchild = await GrandChildEntity.creator(viewerContext)
                .setField('parent_id', child.getID())
                .enforceCreateAsync();
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.not.toBeNull();
            await expect(ChildEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(child.getID())).resolves.not.toBeNull();
            await expect(GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDNullableAsync(grandchild.getID())).resolves.not.toBeNull();
            privacyPolicyEvaluationRecords.shouldRecord = true;
            await ParentEntity.enforceDeleteAsync(parent);
            privacyPolicyEvaluationRecords.shouldRecord = false;
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.toBeNull();
            await expect(ChildEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(child.getID())).resolves.toBeNull();
            await expect(GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDNullableAsync(grandchild.getID())).resolves.toBeNull();
            // two calls for each trigger, one beforeDelete, one afterDelete
            expect(triggerExecutionCounts).toMatchObject({
                ParentEntityDeletion: 2,
                ChildEntityDeletion: 2,
                GrandChildEntityDeletion: 2,
                ParentEntityUpdate: 0,
                ChildEntityUpdate: 0,
                GrandChildEntityUpdate: 0,
            });
            expect(privacyPolicyEvaluationRecords).toMatchObject({
                ParentEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for parent (since it's being deleted)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [{ cascadingDeleteCause: null }],
                },
                ChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    // one READ auth action for child in order to delete via cascade
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for child (since it's being deleted via cascade)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                },
                GrandChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    // one READ auth action for grandchild in order to delete via cascade
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ChildEntity),
                                cascadingDeleteCause: {
                                    entity: expect.any(ParentEntity),
                                    cascadingDeleteCause: null,
                                },
                            },
                        },
                    ],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for grandchild (since it's being deleted via cascade)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ChildEntity),
                                cascadingDeleteCause: {
                                    entity: expect.any(ParentEntity),
                                    cascadingDeleteCause: null,
                                },
                            },
                        },
                    ],
                },
            });
        });
    });
    describe('EntityEdgeDeletionBehavior.SET_NULL', () => {
        it('sets null', async () => {
            const { ParentEntity, ChildEntity, GrandChildEntity, triggerExecutionCounts, privacyPolicyEvaluationRecords, } = makeEntityClasses(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL);
            const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
            const viewerContext = new TestViewerContext_1.default(companionProvider);
            const parent = await ParentEntity.creator(viewerContext).enforceCreateAsync();
            const child = await ChildEntity.creator(viewerContext)
                .setField('parent_id', parent.getID())
                .enforceCreateAsync();
            const grandchild = await GrandChildEntity.creator(viewerContext)
                .setField('parent_id', child.getID())
                .enforceCreateAsync();
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.not.toBeNull();
            await expect(ChildEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(child.getID())).resolves.not.toBeNull();
            await expect(GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDNullableAsync(grandchild.getID())).resolves.not.toBeNull();
            privacyPolicyEvaluationRecords.shouldRecord = true;
            await ParentEntity.enforceDeleteAsync(parent);
            privacyPolicyEvaluationRecords.shouldRecord = false;
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.toBeNull();
            const loadedChild = await ChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDAsync(child.getID());
            expect(loadedChild.getField('parent_id')).toBeNull();
            const loadedGrandchild = await GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDAsync(grandchild.getID());
            expect(loadedGrandchild.getField('parent_id')).toEqual(loadedChild.getID());
            // two calls for only parent trigger, one beforeDelete, one afterDelete
            // when using set null the descendants aren't deleted
            expect(triggerExecutionCounts).toMatchObject({
                ParentEntityDeletion: 2,
                ChildEntityDeletion: 0,
                GrandChildEntityDeletion: 0,
                ParentEntityUpdate: 0,
                ChildEntityUpdate: 2,
                GrandChildEntityUpdate: 0,
            });
            expect(privacyPolicyEvaluationRecords).toMatchObject({
                ParentEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for parent (since it's being deleted)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [{ cascadingDeleteCause: null }],
                },
                ChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    // two READs auth action for Child during parent deletion:
                    // 1. Read to initiate the SET_NULL (to update the entity)
                    // 1. Read automatically post-update
                    // no other entities are read since it is not cascaded past first entity
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                    // one UPDATE to set null
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [],
                },
                GrandChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [],
                },
            });
        });
    });
    describe('EntityEdgeDeletionBehavior.SET_NULL_INVALIDATE_CACHE_ONLY', () => {
        it('invalidates the cache', async () => {
            const { ParentEntity, ChildEntity, GrandChildEntity, triggerExecutionCounts, privacyPolicyEvaluationRecords, } = makeEntityClasses(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL_INVALIDATE_CACHE_ONLY);
            const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
            const viewerContext = new TestViewerContext_1.default(companionProvider);
            const parent = await ParentEntity.creator(viewerContext).enforceCreateAsync();
            const child = await ChildEntity.creator(viewerContext)
                .setField('parent_id', parent.getID())
                .enforceCreateAsync();
            const grandchild = await GrandChildEntity.creator(viewerContext)
                .setField('parent_id', child.getID())
                .enforceCreateAsync();
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.not.toBeNull();
            await expect(ChildEntity.loader(viewerContext)
                .enforcing()
                .loadByFieldEqualingAsync('parent_id', parent.getID())).resolves.not.toBeNull();
            await expect(GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByFieldEqualingAsync('parent_id', child.getID())).resolves.not.toBeNull();
            const childCacheAdapter = viewerContext.getViewerScopedEntityCompanionForClass(ChildEntity)['entityCompanion']['tableDataCoordinator']['cacheAdapter'];
            const childCachedBefore = await childCacheAdapter.loadManyAsync('parent_id', [
                parent.getID(),
            ]);
            expect(childCachedBefore.get(parent.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
            const grandChildCacheAdapter = viewerContext.getViewerScopedEntityCompanionForClass(GrandChildEntity)['entityCompanion']['tableDataCoordinator']['cacheAdapter'];
            const grandChildCachedBefore = await grandChildCacheAdapter.loadManyAsync('parent_id', [
                child.getID(),
            ]);
            expect(grandChildCachedBefore.get(child.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
            privacyPolicyEvaluationRecords.shouldRecord = true;
            await ParentEntity.enforceDeleteAsync(parent);
            privacyPolicyEvaluationRecords.shouldRecord = false;
            const childCachedAfter = await childCacheAdapter.loadManyAsync('parent_id', [parent.getID()]);
            expect(childCachedAfter.get(parent.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.MISS);
            const grandChildCachedAfter = await grandChildCacheAdapter.loadManyAsync('parent_id', [
                child.getID(),
            ]);
            expect(grandChildCachedAfter.get(child.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.toBeNull();
            const loadedChild = await ChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDAsync(child.getID());
            expect(loadedChild).not.toBeNull();
            const loadedGrandchild = await GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDAsync(grandchild.getID());
            expect(loadedGrandchild.getField('parent_id')).toEqual(loadedChild.getID());
            // two calls for only parent trigger, one beforeDelete, one afterDelete
            // when using set null the descendants aren't deleted
            expect(triggerExecutionCounts).toMatchObject({
                ParentEntityDeletion: 2,
                ChildEntityDeletion: 0,
                GrandChildEntityDeletion: 0,
                ParentEntityUpdate: 0,
                ChildEntityUpdate: 2,
                GrandChildEntityUpdate: 0,
            });
            expect(privacyPolicyEvaluationRecords).toMatchObject({
                ParentEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for parent (since it's being deleted)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [{ cascadingDeleteCause: null }],
                },
                ChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    // two READs auth action for child in order to update via cascade
                    // no other entities are read since it is not cascaded past first entity
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                    // one UPDATE to set null
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [],
                },
                GrandChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [],
                },
            });
        });
    });
    describe('EntityEdgeDeletionBehavior.CASCADE_DELETE_INVALIDATE_CACHE_ONLY', () => {
        it('invalidates the cache', async () => {
            const { ParentEntity, ChildEntity, GrandChildEntity, triggerExecutionCounts, privacyPolicyEvaluationRecords, } = makeEntityClasses(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE_INVALIDATE_CACHE_ONLY);
            const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
            const viewerContext = new TestViewerContext_1.default(companionProvider);
            const parent = await ParentEntity.creator(viewerContext).enforceCreateAsync();
            const child = await ChildEntity.creator(viewerContext)
                .setField('parent_id', parent.getID())
                .enforceCreateAsync();
            const grandchild = await GrandChildEntity.creator(viewerContext)
                .setField('parent_id', child.getID())
                .enforceCreateAsync();
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.not.toBeNull();
            await expect(ChildEntity.loader(viewerContext)
                .enforcing()
                .loadByFieldEqualingAsync('parent_id', parent.getID())).resolves.not.toBeNull();
            await expect(GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByFieldEqualingAsync('parent_id', child.getID())).resolves.not.toBeNull();
            const childCacheAdapter = viewerContext.getViewerScopedEntityCompanionForClass(ChildEntity)['entityCompanion']['tableDataCoordinator']['cacheAdapter'];
            const childCachedBefore = await childCacheAdapter.loadManyAsync('parent_id', [
                parent.getID(),
            ]);
            expect(childCachedBefore.get(parent.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
            const grandChildCacheAdapter = viewerContext.getViewerScopedEntityCompanionForClass(GrandChildEntity)['entityCompanion']['tableDataCoordinator']['cacheAdapter'];
            const grandChildCachedBefore = await grandChildCacheAdapter.loadManyAsync('parent_id', [
                child.getID(),
            ]);
            expect(grandChildCachedBefore.get(child.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
            privacyPolicyEvaluationRecords.shouldRecord = true;
            await ParentEntity.enforceDeleteAsync(parent);
            privacyPolicyEvaluationRecords.shouldRecord = false;
            const childCachedAfter = await childCacheAdapter.loadManyAsync('parent_id', [parent.getID()]);
            expect(childCachedAfter.get(parent.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.MISS);
            const grandChildCachedAfter = await grandChildCacheAdapter.loadManyAsync('parent_id', [
                child.getID(),
            ]);
            expect(grandChildCachedAfter.get(child.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.MISS);
            await expect(ParentEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(parent.getID())).resolves.toBeNull();
            await expect(ChildEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(child.getID())).resolves.not.toBeNull();
            await expect(GrandChildEntity.loader(viewerContext)
                .enforcing()
                .loadByIDNullableAsync(grandchild.getID())).resolves.not.toBeNull();
            // two calls for each trigger, one beforeDelete, one afterDelete
            expect(triggerExecutionCounts).toMatchObject({
                ParentEntityDeletion: 2,
                ChildEntityDeletion: 2,
                GrandChildEntityDeletion: 2,
                ParentEntityUpdate: 0,
                ChildEntityUpdate: 0,
                GrandChildEntityUpdate: 0,
            });
            expect(privacyPolicyEvaluationRecords).toMatchObject({
                ParentEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for parent (since it's being deleted)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [{ cascadingDeleteCause: null }],
                },
                ChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    // one READ auth action for child in order to delete via cascade
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for child (since it's being deleted via cascade)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ParentEntity),
                                cascadingDeleteCause: null,
                            },
                        },
                    ],
                },
                GrandChildEntity: {
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.CREATE]: [],
                    // one READ auth action for grandchild in order to delete via cascade
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.READ]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ChildEntity),
                                cascadingDeleteCause: {
                                    entity: expect.any(ParentEntity),
                                    cascadingDeleteCause: null,
                                },
                            },
                        },
                    ],
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.UPDATE]: [],
                    // one DELETE auth action for grandchild (since it's being deleted via cascade)
                    [EntityPrivacyPolicy_1.EntityAuthorizationAction.DELETE]: [
                        {
                            cascadingDeleteCause: {
                                entity: expect.any(ChildEntity),
                                cascadingDeleteCause: {
                                    entity: expect.any(ParentEntity),
                                    cascadingDeleteCause: null,
                                },
                            },
                        },
                    ],
                },
            });
        });
    });
});
//# sourceMappingURL=EntityEdges-test.js.map