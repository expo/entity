"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Entity_1 = __importDefault(require("../Entity"));
const EntityConfiguration_1 = __importDefault(require("../EntityConfiguration"));
const EntityFieldDefinition_1 = require("../EntityFieldDefinition");
const EntityFields_1 = require("../EntityFields");
const EntityPrivacyPolicy_1 = __importDefault(require("../EntityPrivacyPolicy"));
const ReadThroughEntityCache_1 = require("../internal/ReadThroughEntityCache");
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysAllowPrivacyPolicyRule"));
const TestViewerContext_1 = __importDefault(require("../testfixtures/TestViewerContext"));
const createUnitTestEntityCompanionProvider_1 = require("../utils/testing/createUnitTestEntityCompanionProvider");
class CategoryPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
const makeEntityClass = (edgeDeletionBehavior) => {
    class CategoryEntity extends Entity_1.default {
        static defineCompanionDefinition() {
            return {
                entityClass: CategoryEntity,
                entityConfiguration: categoryEntityConfiguration,
                privacyPolicyClass: CategoryPrivacyPolicy,
            };
        }
    }
    const categoryEntityConfiguration = new EntityConfiguration_1.default({
        idField: 'id',
        tableName: 'categories',
        inboundEdges: [CategoryEntity],
        schema: {
            id: new EntityFields_1.UUIDField({
                columnName: 'id',
                cache: true,
            }),
            parent_category_id: new EntityFields_1.UUIDField({
                columnName: 'parent_category_id',
                cache: true,
                association: {
                    associatedEntityClass: CategoryEntity,
                    edgeDeletionBehavior,
                },
            }),
        },
        databaseAdapterFlavor: 'postgres',
        cacheAdapterFlavor: 'redis',
    });
    return {
        CategoryEntity,
    };
};
describe('EntityEdgeDeletionBehavior.CASCADE_DELETE', () => {
    it('deletes', async () => {
        const { CategoryEntity } = makeEntityClass(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE);
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new TestViewerContext_1.default(companionProvider);
        const parentCategory = await CategoryEntity.creator(viewerContext).enforceCreateAsync();
        const subCategory = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', parentCategory.getID())
            .enforceCreateAsync();
        const subSubCategory = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', subCategory.getID())
            .enforceCreateAsync();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(parentCategory.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(subCategory.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(subSubCategory.getID())).resolves.not.toBeNull();
        await CategoryEntity.enforceDeleteAsync(parentCategory);
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(parentCategory.getID())).resolves.toBeNull();
        await expect(CategoryEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(subCategory.getID())).resolves.toBeNull();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(subSubCategory.getID())).resolves.toBeNull();
    });
    it('handles cycles', async () => {
        const { CategoryEntity } = makeEntityClass(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE);
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new TestViewerContext_1.default(companionProvider);
        const categoryA = await CategoryEntity.creator(viewerContext).enforceCreateAsync();
        const categoryB = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', categoryA.getID())
            .enforceCreateAsync();
        await CategoryEntity.updater(categoryA)
            .setField('parent_category_id', categoryB.getID())
            .enforceUpdateAsync();
        await CategoryEntity.enforceDeleteAsync(categoryA);
        await expect(CategoryEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(categoryA.getID())).resolves.toBeNull();
        await expect(CategoryEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(categoryB.getID())).resolves.toBeNull();
    });
});
describe('EntityEdgeDeletionBehavior.SET_NULL', () => {
    it('sets null', async () => {
        const { CategoryEntity } = makeEntityClass(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL);
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new TestViewerContext_1.default(companionProvider);
        const parentCategory = await CategoryEntity.creator(viewerContext).enforceCreateAsync();
        const subCategory = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', parentCategory.getID())
            .enforceCreateAsync();
        const subSubCategory = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', subCategory.getID())
            .enforceCreateAsync();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(parentCategory.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(subCategory.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(subSubCategory.getID())).resolves.not.toBeNull();
        await CategoryEntity.enforceDeleteAsync(parentCategory);
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(parentCategory.getID())).resolves.toBeNull();
        const loadedSubCategory = await CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDAsync(subCategory.getID());
        expect(loadedSubCategory.getField('parent_category_id')).toBeNull();
        const loadedSubSubCategory = await CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDAsync(subSubCategory.getID());
        expect(loadedSubSubCategory.getField('parent_category_id')).not.toBeNull();
    });
    it('handles cycles', async () => {
        const { CategoryEntity } = makeEntityClass(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.SET_NULL);
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new TestViewerContext_1.default(companionProvider);
        const categoryA = await CategoryEntity.creator(viewerContext).enforceCreateAsync();
        const categoryB = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', categoryA.getID())
            .enforceCreateAsync();
        await CategoryEntity.updater(categoryA)
            .setField('parent_category_id', categoryB.getID())
            .enforceUpdateAsync();
        await CategoryEntity.enforceDeleteAsync(categoryA);
        const loadedCategoryB = await CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDAsync(categoryB.getID());
        expect(loadedCategoryB.getField('parent_category_id')).toBeNull();
    });
});
describe('EntityEdgeDeletionBehavior.CASCADE_DELETE_INVALIDATE_CACHE', () => {
    it('invalidates the cache', async () => {
        const { CategoryEntity } = makeEntityClass(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE_INVALIDATE_CACHE_ONLY);
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new TestViewerContext_1.default(companionProvider);
        const parentCategory = await CategoryEntity.creator(viewerContext).enforceCreateAsync();
        const subCategory = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', parentCategory.getID())
            .enforceCreateAsync();
        const subSubCategory = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', subCategory.getID())
            .enforceCreateAsync();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(parentCategory.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByFieldEqualingAsync('parent_category_id', parentCategory.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByFieldEqualingAsync('parent_category_id', subCategory.getID())).resolves.not.toBeNull();
        const categoryCacheAdapter = viewerContext.getViewerScopedEntityCompanionForClass(CategoryEntity)['entityCompanion']['tableDataCoordinator']['cacheAdapter'];
        const subCategoryCachedBefore = await categoryCacheAdapter.loadManyAsync('parent_category_id', [
            parentCategory.getID(),
        ]);
        expect(subCategoryCachedBefore.get(parentCategory.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
        const subSubCategoryCachedBefore = await categoryCacheAdapter.loadManyAsync('parent_category_id', [subCategory.getID()]);
        expect(subSubCategoryCachedBefore.get(subCategory.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
        await CategoryEntity.enforceDeleteAsync(parentCategory);
        const subCategoryCachedAfter = await categoryCacheAdapter.loadManyAsync('parent_category_id', [
            parentCategory.getID(),
        ]);
        expect(subCategoryCachedAfter.get(parentCategory.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.MISS);
        const subSubCategoryCachedAfter = await categoryCacheAdapter.loadManyAsync('parent_category_id', [subCategory.getID()]);
        expect(subSubCategoryCachedAfter.get(subCategory.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.MISS);
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(parentCategory.getID())).resolves.toBeNull();
        await expect(CategoryEntity.loader(viewerContext).enforcing().loadByIDNullableAsync(subCategory.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByIDNullableAsync(subSubCategory.getID())).resolves.not.toBeNull();
    });
    it('handles cycles', async () => {
        const { CategoryEntity } = makeEntityClass(EntityFieldDefinition_1.EntityEdgeDeletionBehavior.CASCADE_DELETE_INVALIDATE_CACHE_ONLY);
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new TestViewerContext_1.default(companionProvider);
        const categoryA = await CategoryEntity.creator(viewerContext).enforceCreateAsync();
        const categoryB = await CategoryEntity.creator(viewerContext)
            .setField('parent_category_id', categoryA.getID())
            .enforceCreateAsync();
        await CategoryEntity.updater(categoryA)
            .setField('parent_category_id', categoryB.getID())
            .enforceUpdateAsync();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByFieldEqualingAsync('parent_category_id', categoryA.getID())).resolves.not.toBeNull();
        await expect(CategoryEntity.loader(viewerContext)
            .enforcing()
            .loadByFieldEqualingAsync('parent_category_id', categoryB.getID())).resolves.not.toBeNull();
        const categoryCacheAdapter = viewerContext.getViewerScopedEntityCompanionForClass(CategoryEntity)['entityCompanion']['tableDataCoordinator']['cacheAdapter'];
        const categoriesCachedBefore = await categoryCacheAdapter.loadManyAsync('parent_category_id', [
            categoryA.getID(),
            categoryB.getID(),
        ]);
        expect(categoriesCachedBefore.get(categoryA.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
        expect(categoriesCachedBefore.get(categoryB.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.HIT);
        await CategoryEntity.enforceDeleteAsync(categoryA);
        const categoriesCachedAfter = await categoryCacheAdapter.loadManyAsync('parent_category_id', [
            categoryA.getID(),
            categoryB.getID(),
        ]);
        expect(categoriesCachedAfter.get(categoryA.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.MISS);
        expect(categoriesCachedAfter.get(categoryB.getID())?.status).toEqual(ReadThroughEntityCache_1.CacheStatus.MISS);
    });
});
//# sourceMappingURL=EntitySelfReferentialEdges-test.js.map