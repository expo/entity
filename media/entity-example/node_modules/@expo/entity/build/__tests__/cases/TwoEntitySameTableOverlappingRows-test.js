"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Entity_1 = __importDefault(require("../../Entity"));
const EntityConfiguration_1 = __importDefault(require("../../EntityConfiguration"));
const EntityFields_1 = require("../../EntityFields");
const EntityPrivacyPolicy_1 = __importDefault(require("../../EntityPrivacyPolicy"));
const ViewerContext_1 = __importDefault(require("../../ViewerContext"));
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../../rules/AlwaysAllowPrivacyPolicyRule"));
const createUnitTestEntityCompanionProvider_1 = require("../../utils/testing/createUnitTestEntityCompanionProvider");
describe('Two entities backed by the same table', () => {
    test('mutate through different types and keep consistent cache and dataloader', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const entity1 = await OneTestEntity.creator(viewerContext)
            .setField('fake_field', 'hello')
            .enforceCreateAsync();
        expect(entity1).toBeInstanceOf(OneTestEntity);
        const entity2 = await TwoTestEntity.loader(viewerContext)
            .enforcing()
            .loadByIDAsync(entity1.getID());
        expect(entity2).toBeInstanceOf(TwoTestEntity);
        const updated2 = await TwoTestEntity.updater(entity2)
            .setField('fake_field', 'world')
            .setField('other_field', 'wat')
            .enforceUpdateAsync();
        expect(updated2.getAllFields()).toMatchObject({
            id: updated2.getID(),
            other_field: 'wat',
            fake_field: 'world',
        });
        const loaded1 = await OneTestEntity.loader(viewerContext)
            .enforcing()
            .loadByIDAsync(entity1.getID());
        expect(loaded1.getAllFields()).toMatchObject({
            id: updated2.getID(),
            fake_field: 'world',
        });
    });
    test('cached field that differs between the two to test invalidation', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const entity = await TwoTestEntity.creator(viewerContext)
            .setField('fake_field', 'hello')
            .setField('other_field', 'huh')
            .enforceCreateAsync();
        const loadedEntity = await TwoTestEntity.loader(viewerContext)
            .enforcing()
            .loadByFieldEqualingAsync('other_field', 'huh');
        expect(loadedEntity?.getAllFields()).toMatchObject({
            id: entity.getID(),
            fake_field: 'hello',
            other_field: 'huh',
        });
        const loaded1 = await OneTestEntity.loader(viewerContext)
            .enforcing()
            .loadByIDAsync(entity.getID());
        await OneTestEntity.updater(loaded1).setField('fake_field', 'world').enforceUpdateAsync();
        const loaded2 = await TwoTestEntity.loader(viewerContext)
            .enforcing()
            .loadByFieldEqualingAsync('other_field', 'huh');
        expect(loaded2?.getAllFields()).toMatchObject({
            id: entity.getID(),
            fake_field: 'world',
            other_field: 'huh',
        });
        const loaded22 = await TwoTestEntity.loader(viewerContext)
            .enforcing()
            .loadByFieldEqualingAsync('fake_field', 'world');
        expect(loaded22?.getAllFields()).toMatchObject({
            id: entity.getID(),
            fake_field: 'world',
            other_field: 'huh',
        });
    });
});
const testEntityConfiguration = new EntityConfiguration_1.default({
    idField: 'id',
    tableName: 'entities',
    schema: {
        id: new EntityFields_1.UUIDField({
            columnName: 'custom_id',
            cache: true,
        }),
        other_field: new EntityFields_1.StringField({
            columnName: 'other_field',
            cache: true,
        }),
        fake_field: new EntityFields_1.StringField({
            columnName: 'fake_field',
            cache: true,
        }),
    },
    databaseAdapterFlavor: 'postgres',
    cacheAdapterFlavor: 'redis',
});
class TestEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
class OneTestEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: OneTestEntity,
            entityConfiguration: testEntityConfiguration,
            privacyPolicyClass: TestEntityPrivacyPolicy,
            entitySelectedFields: ['id', 'fake_field'],
        };
    }
}
class TwoTestEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: TwoTestEntity,
            entityConfiguration: testEntityConfiguration,
            privacyPolicyClass: TestEntityPrivacyPolicy,
            entitySelectedFields: ['id', 'other_field', 'fake_field'],
        };
    }
}
//# sourceMappingURL=TwoEntitySameTableOverlappingRows-test.js.map