"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Entity_1 = __importDefault(require("../../Entity"));
const EntityConfiguration_1 = __importDefault(require("../../EntityConfiguration"));
const EntityFields_1 = require("../../EntityFields");
const EntityPrivacyPolicy_1 = __importDefault(require("../../EntityPrivacyPolicy"));
const ViewerContext_1 = __importDefault(require("../../ViewerContext"));
const entityUtils_1 = require("../../entityUtils");
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../../rules/AlwaysAllowPrivacyPolicyRule"));
const createUnitTestEntityCompanionProvider_1 = require("../../utils/testing/createUnitTestEntityCompanionProvider");
describe('Two entities backed by the same table', () => {
    test('load by different types', async () => {
        const companionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
        const viewerContext = new ViewerContext_1.default(companionProvider);
        const one = await OneTestEntity.creator(viewerContext)
            .setField('entity_type', EntityType.ONE)
            .setField('common_other_field', 'wat')
            .enforceCreateAsync();
        const two = await TwoTestEntity.creator(viewerContext)
            .setField('entity_type', EntityType.TWO)
            .setField('other_field', 'blah')
            .setField('common_other_field', 'wat')
            .enforceCreateAsync();
        expect(one).toBeInstanceOf(OneTestEntity);
        expect(two).toBeInstanceOf(TwoTestEntity);
        await expect(TwoTestEntity.loader(viewerContext).enforcing().loadByIDAsync(one.getID())).rejects.toThrowError('TwoTestEntity must be instantiated with two data');
        await expect(OneTestEntity.loader(viewerContext).enforcing().loadByIDAsync(two.getID())).rejects.toThrowError('OneTestEntity must be instantiated with one data');
        const manyResults = await OneTestEntity.loader(viewerContext)
            .withAuthorizationResults()
            .loadManyByFieldEqualingAsync('common_other_field', 'wat');
        const successfulManyResults = (0, entityUtils_1.successfulResults)(manyResults);
        const failedManyResults = (0, entityUtils_1.failedResults)(manyResults);
        expect(successfulManyResults).toHaveLength(1);
        expect(failedManyResults).toHaveLength(1);
        expect(successfulManyResults[0].enforceValue().getID()).toEqual(one.getID());
        expect(failedManyResults[0].enforceError().message).toEqual('OneTestEntity must be instantiated with one data');
        const fieldEqualityConjunctionResults = await OneTestEntity.loader(viewerContext)
            .withAuthorizationResults()
            .loadManyByFieldEqualityConjunctionAsync([
            {
                fieldName: 'common_other_field',
                fieldValue: 'wat',
            },
        ]);
        const successfulfieldEqualityConjunctionResultsResults = (0, entityUtils_1.successfulResults)(fieldEqualityConjunctionResults);
        const failedfieldEqualityConjunctionResultsResults = (0, entityUtils_1.failedResults)(fieldEqualityConjunctionResults);
        expect(successfulfieldEqualityConjunctionResultsResults).toHaveLength(1);
        expect(failedfieldEqualityConjunctionResultsResults).toHaveLength(1);
    });
});
var EntityType;
(function (EntityType) {
    EntityType[EntityType["ONE"] = 0] = "ONE";
    EntityType[EntityType["TWO"] = 1] = "TWO";
})(EntityType || (EntityType = {}));
const testEntityConfiguration = new EntityConfiguration_1.default({
    idField: 'id',
    tableName: 'entities',
    schema: {
        id: new EntityFields_1.UUIDField({
            columnName: 'custom_id',
            cache: true,
        }),
        other_field: new EntityFields_1.StringField({
            columnName: 'other_field',
        }),
        common_other_field: new EntityFields_1.StringField({
            columnName: 'common_other_field',
        }),
        entity_type: new EntityFields_1.StrictEnumField({
            columnName: 'entity_type',
            enum: EntityType,
        }),
    },
    databaseAdapterFlavor: 'postgres',
    cacheAdapterFlavor: 'redis',
});
class TestEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    readRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    createRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
}
class OneTestEntity extends Entity_1.default {
    constructor(constructorParams) {
        if (constructorParams.selectedFields.entity_type !== EntityType.ONE) {
            throw new Error('OneTestEntity must be instantiated with one data');
        }
        super(constructorParams);
    }
    static defineCompanionDefinition() {
        return {
            entityClass: OneTestEntity,
            entityConfiguration: testEntityConfiguration,
            privacyPolicyClass: TestEntityPrivacyPolicy,
            entitySelectedFields: ['id', 'entity_type', 'common_other_field'],
        };
    }
}
class TwoTestEntity extends Entity_1.default {
    constructor(constructorParams) {
        if (constructorParams.selectedFields.entity_type !== EntityType.TWO) {
            throw new Error('TwoTestEntity must be instantiated with two data');
        }
        super(constructorParams);
    }
    static defineCompanionDefinition() {
        return {
            entityClass: TwoTestEntity,
            entityConfiguration: testEntityConfiguration,
            privacyPolicyClass: TestEntityPrivacyPolicy,
            entitySelectedFields: ['id', 'other_field', 'common_other_field', 'entity_type'],
        };
    }
}
//# sourceMappingURL=TwoEntitySameTableDisjointRows-test.js.map