"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
const uuid_1 = require("uuid");
const Entity_1 = __importDefault(require("../Entity"));
const EntityConfiguration_1 = __importDefault(require("../EntityConfiguration"));
const EntityFields_1 = require("../EntityFields");
const EntityPrivacyPolicy_1 = __importDefault(require("../EntityPrivacyPolicy"));
const ViewerContext_1 = __importDefault(require("../ViewerContext"));
const entityUtils_1 = require("../entityUtils");
const EntityNotAuthorizedError_1 = __importDefault(require("../errors/EntityNotAuthorizedError"));
const AlwaysAllowPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysAllowPrivacyPolicyRule"));
const AlwaysDenyPrivacyPolicyRule_1 = __importDefault(require("../rules/AlwaysDenyPrivacyPolicyRule"));
const PrivacyPolicyRule_1 = __importStar(require("../rules/PrivacyPolicyRule"));
const createUnitTestEntityCompanionProvider_1 = require("../utils/testing/createUnitTestEntityCompanionProvider");
class TestUserViewerContext extends ViewerContext_1.default {
    userID;
    constructor(entityCompanionProvider, userID) {
        super(entityCompanionProvider);
        this.userID = userID;
    }
    getUserID() {
        return this.userID;
    }
}
class BlahEntity extends Entity_1.default {
    static defineCompanionDefinition() {
        return {
            entityClass: BlahEntity,
            entityConfiguration: new EntityConfiguration_1.default({
                idField: 'id',
                tableName: 'blah_table',
                schema: {
                    id: new EntityFields_1.UUIDField({
                        columnName: 'id',
                        cache: true,
                    }),
                    ownerID: new EntityFields_1.UUIDField({
                        columnName: 'owner_id',
                    }),
                },
                databaseAdapterFlavor: 'postgres',
                cacheAdapterFlavor: 'redis',
            }),
            privacyPolicyClass: BlahEntityPrivacyPolicy,
        };
    }
}
class DenyIfNotOwnerPrivacyPolicyRule extends PrivacyPolicyRule_1.default {
    async evaluateAsync(viewerContext, _queryContext, _evaluationContext, entity) {
        if (viewerContext.getUserID() === entity.getField('ownerID')) {
            return PrivacyPolicyRule_1.RuleEvaluationResult.SKIP;
        }
        return PrivacyPolicyRule_1.RuleEvaluationResult.DENY;
    }
}
class BlahEntityPrivacyPolicy extends EntityPrivacyPolicy_1.default {
    createRules = [
        new DenyIfNotOwnerPrivacyPolicyRule(),
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    readRules = [
        new DenyIfNotOwnerPrivacyPolicyRule(),
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    updateRules = [
        new DenyIfNotOwnerPrivacyPolicyRule(),
        new AlwaysAllowPrivacyPolicyRule_1.default(),
    ];
    deleteRules = [
        new AlwaysDenyPrivacyPolicyRule_1.default(),
    ];
}
it('runs through a common workflow', async () => {
    // will be one entity companion provider for each request, so
    // share amongst all VCs created in that request
    const entityCompanionProvider = (0, createUnitTestEntityCompanionProvider_1.createUnitTestEntityCompanionProvider)();
    const vc1 = new TestUserViewerContext(entityCompanionProvider, (0, uuid_1.v4)());
    const vc2 = new TestUserViewerContext(entityCompanionProvider, (0, uuid_1.v4)());
    const blahOwner1 = await (0, results_1.enforceAsyncResult)(BlahEntity.creator(vc1).setField('ownerID', vc1.getUserID()).createAsync());
    await (0, results_1.enforceAsyncResult)(BlahEntity.creator(vc1).setField('ownerID', vc1.getUserID()).createAsync());
    const blahOwner2 = await (0, results_1.enforceAsyncResult)(BlahEntity.creator(vc2).setField('ownerID', vc2.getUserID()).createAsync());
    // sanity check created objects
    expect(blahOwner1.getField('ownerID')).toEqual(vc1.getUserID());
    expect(blahOwner2.getField('ownerID')).toEqual(vc2.getUserID());
    // check that two people can't read each others data
    await expect((0, results_1.enforceAsyncResult)(BlahEntity.loader(vc1).withAuthorizationResults().loadByIDAsync(blahOwner2.getID()))).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
    await expect((0, results_1.enforceAsyncResult)(BlahEntity.loader(vc2).withAuthorizationResults().loadByIDAsync(blahOwner1.getID()))).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
    // check that all of owner 1's objects can be loaded
    const results = await (0, entityUtils_1.enforceResultsAsync)(BlahEntity.loader(vc1)
        .withAuthorizationResults()
        .loadManyByFieldEqualingAsync('ownerID', vc1.getUserID()));
    expect(results).toHaveLength(2);
    // check that two people can't create objects owned by others
    await expect((0, results_1.enforceAsyncResult)(BlahEntity.creator(vc2).setField('ownerID', blahOwner1.getID()).createAsync())).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
    // check that empty load many returns nothing
    const results2 = await BlahEntity.loader(vc1)
        .withAuthorizationResults()
        .loadManyByFieldEqualingManyAsync('ownerID', []);
    for (const value in results2.values) {
        expect(value).toHaveLength(0);
    }
    // check that the user can't delete their own data (as specified by privacy rules)
    await expect((0, results_1.enforceAsyncResult)(BlahEntity.deleteAsync(blahOwner2))).rejects.toBeInstanceOf(EntityNotAuthorizedError_1.default);
});
//# sourceMappingURL=EntityCommonUseCases-test.js.map