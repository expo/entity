"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const results_1 = require("@expo/results");
const ts_mockito_1 = require("ts-mockito");
const uuid_1 = require("uuid");
const EntityCompanionProvider_1 = __importDefault(require("../EntityCompanionProvider"));
const EntityLoader_1 = __importDefault(require("../EntityLoader"));
const EntityLoaderFactory_1 = __importDefault(require("../EntityLoaderFactory"));
const EntityLoaderUtils_1 = __importDefault(require("../EntityLoaderUtils"));
const EntityMutationInfo_1 = require("../EntityMutationInfo");
const EntityMutationTriggerConfiguration_1 = require("../EntityMutationTriggerConfiguration");
const EntityMutatorFactory_1 = __importDefault(require("../EntityMutatorFactory"));
const EntityQueryContext_1 = require("../EntityQueryContext");
const ViewerContext_1 = __importDefault(require("../ViewerContext"));
const entityUtils_1 = require("../entityUtils");
const EntityDataManager_1 = __importDefault(require("../internal/EntityDataManager"));
const ReadThroughEntityCache_1 = __importDefault(require("../internal/ReadThroughEntityCache"));
const IEntityMetricsAdapter_1 = require("../metrics/IEntityMetricsAdapter");
const NoOpEntityMetricsAdapter_1 = __importDefault(require("../metrics/NoOpEntityMetricsAdapter"));
const SimpleTestEntity_1 = __importStar(require("../testfixtures/SimpleTestEntity"));
const TestEntity_1 = __importStar(require("../testfixtures/TestEntity"));
const StubCacheAdapter_1 = require("../utils/testing/StubCacheAdapter");
const StubDatabaseAdapter_1 = __importDefault(require("../utils/testing/StubDatabaseAdapter"));
const StubQueryContextProvider_1 = __importDefault(require("../utils/testing/StubQueryContextProvider"));
class TestMutationTrigger extends EntityMutationTriggerConfiguration_1.EntityMutationTrigger {
    async executeAsync(_viewerContext, _queryContext, _entity, _mutationInfo) { }
}
class TestNonTransactionalMutationTrigger extends EntityMutationTriggerConfiguration_1.EntityNonTransactionalMutationTrigger {
    async executeAsync(_viewerContext, _entity) { }
}
const setUpMutationValidatorSpies = (mutationValidators) => {
    return mutationValidators.map((validator) => (0, ts_mockito_1.spy)(validator));
};
const verifyValidatorCounts = (viewerContext, mutationValidatorSpies, expectedCalls, mutationInfo) => {
    for (const validator of mutationValidatorSpies) {
        (0, ts_mockito_1.verify)(validator.executeAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.deepEqual)(mutationInfo))).times(expectedCalls);
    }
};
const setUpMutationTriggerSpies = (mutationTriggers) => {
    return {
        beforeCreate: [(0, ts_mockito_1.spy)(mutationTriggers.beforeCreate[0])],
        afterCreate: [(0, ts_mockito_1.spy)(mutationTriggers.afterCreate[0])],
        beforeUpdate: [(0, ts_mockito_1.spy)(mutationTriggers.beforeUpdate[0])],
        afterUpdate: [(0, ts_mockito_1.spy)(mutationTriggers.afterUpdate[0])],
        beforeDelete: [(0, ts_mockito_1.spy)(mutationTriggers.beforeDelete[0])],
        afterDelete: [(0, ts_mockito_1.spy)(mutationTriggers.afterDelete[0])],
        beforeAll: [(0, ts_mockito_1.spy)(mutationTriggers.beforeAll[0])],
        afterAll: [(0, ts_mockito_1.spy)(mutationTriggers.afterAll[0])],
        afterCommit: [(0, ts_mockito_1.spy)(mutationTriggers.afterCommit[0])],
    };
};
const verifyTriggerCounts = (viewerContext, mutationTriggerSpies, executed, mutationInfo) => {
    Object.keys(executed).forEach((s) => {
        if (executed[s]) {
            (0, ts_mockito_1.verify)(mutationTriggerSpies[s][0].executeAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.deepEqual)(mutationInfo))).once();
        }
        else {
            (0, ts_mockito_1.verify)(mutationTriggerSpies[s][0].executeAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.deepEqual)(mutationInfo))).never();
        }
    });
    (0, ts_mockito_1.verify)(mutationTriggerSpies.beforeAll[0].executeAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.deepEqual)(mutationInfo))).once();
    (0, ts_mockito_1.verify)(mutationTriggerSpies.afterAll[0].executeAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.deepEqual)(mutationInfo))).once();
    (0, ts_mockito_1.verify)(mutationTriggerSpies.afterCommit[0].executeAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.deepEqual)(mutationInfo))).once();
};
const createEntityMutatorFactory = (existingObjects) => {
    const mutationValidators = [new TestMutationTrigger()];
    const mutationTriggers = {
        beforeCreate: [new TestMutationTrigger()],
        afterCreate: [new TestMutationTrigger()],
        beforeUpdate: [new TestMutationTrigger()],
        afterUpdate: [new TestMutationTrigger()],
        beforeDelete: [new TestMutationTrigger()],
        afterDelete: [new TestMutationTrigger()],
        beforeAll: [new TestMutationTrigger()],
        afterAll: [new TestMutationTrigger()],
        afterCommit: [new TestNonTransactionalMutationTrigger()],
    };
    const databaseAdapter = new StubDatabaseAdapter_1.default(TestEntity_1.testEntityConfiguration, StubDatabaseAdapter_1.default.convertFieldObjectsToDataStore(TestEntity_1.testEntityConfiguration, new Map([[TestEntity_1.testEntityConfiguration.tableName, existingObjects]])));
    const customStubDatabaseAdapterProvider = {
        getDatabaseAdapter(_entityConfiguration) {
            return databaseAdapter;
        },
    };
    const metricsAdapter = new NoOpEntityMetricsAdapter_1.default();
    const cacheAdapterProvider = new StubCacheAdapter_1.NoCacheStubCacheAdapterProvider();
    const cacheAdapter = cacheAdapterProvider.getCacheAdapter(TestEntity_1.testEntityConfiguration);
    const entityCache = new ReadThroughEntityCache_1.default(TestEntity_1.testEntityConfiguration, cacheAdapter);
    const companionProvider = new EntityCompanionProvider_1.default(metricsAdapter, new Map([
        [
            'postgres',
            {
                adapterProvider: customStubDatabaseAdapterProvider,
                queryContextProvider: StubQueryContextProvider_1.default,
            },
        ],
    ]), new Map([
        [
            'redis',
            {
                cacheAdapterProvider,
            },
        ],
    ]));
    const dataManager = new EntityDataManager_1.default(databaseAdapter, entityCache, StubQueryContextProvider_1.default, metricsAdapter, TestEntity_1.default.name);
    const entityLoaderFactory = new EntityLoaderFactory_1.default(companionProvider.getCompanionForEntity(TestEntity_1.default), dataManager, metricsAdapter);
    const entityMutatorFactory = new EntityMutatorFactory_1.default(companionProvider, TestEntity_1.testEntityConfiguration, TestEntity_1.default, companionProvider.getCompanionForEntity(TestEntity_1.default).privacyPolicy, mutationValidators, mutationTriggers, entityLoaderFactory, databaseAdapter, metricsAdapter);
    return {
        privacyPolicy: companionProvider.getCompanionForEntity(TestEntity_1.default).privacyPolicy,
        entityLoaderFactory,
        entityMutatorFactory,
        metricsAdapter,
        mutationValidators,
        mutationTriggers,
    };
};
describe(EntityMutatorFactory_1.default, () => {
    describe('forCreate', () => {
        it('creates entities', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { entityMutatorFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '5',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const newEntity = await entityMutatorFactory
                .forCreate(viewerContext, queryContext)
                .setField('stringField', 'huh')
                .enforceCreateAsync();
            expect(newEntity).toBeTruthy();
        });
        it('checks privacy', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { privacyPolicy, entityMutatorFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '5',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(privacyPolicy);
            await entityMutatorFactory
                .forCreate(viewerContext, queryContext)
                .setField('stringField', 'huh')
                .enforceCreateAsync();
            (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeCreateAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.deepEqual)({ previousValue: null, cascadingDeleteCause: null }), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).once();
        });
        it('executes triggers', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { mutationTriggers, entityMutatorFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '5',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const triggerSpies = setUpMutationTriggerSpies(mutationTriggers);
            await entityMutatorFactory
                .forCreate(viewerContext, queryContext)
                .setField('stringField', 'huh')
                .enforceCreateAsync();
            verifyTriggerCounts(viewerContext, triggerSpies, {
                beforeCreate: true,
                afterCreate: true,
                beforeUpdate: false,
                afterUpdate: false,
                beforeDelete: false,
                afterDelete: false,
            }, { type: EntityMutationInfo_1.EntityMutationType.CREATE });
        });
        it('executes validators', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { mutationValidators, entityMutatorFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '5',
                    intField: 1,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const validatorSpies = setUpMutationValidatorSpies(mutationValidators);
            await entityMutatorFactory
                .forCreate(viewerContext, queryContext)
                .setField('stringField', 'huh')
                .enforceCreateAsync();
            verifyValidatorCounts(viewerContext, validatorSpies, 1, { type: EntityMutationInfo_1.EntityMutationType.CREATE });
        });
    });
    describe('forUpdate', () => {
        it('updates entities', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id2));
            const updatedEntity = await entityMutatorFactory
                .forUpdate(existingEntity, queryContext)
                .setField('stringField', 'huh2')
                .enforceUpdateAsync();
            expect(updatedEntity).toBeTruthy();
            expect(updatedEntity.getAllFields()).not.toMatchObject(existingEntity.getAllFields());
            expect(updatedEntity.getField('stringField')).toEqual('huh2');
            const reloadedEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id2));
            expect(reloadedEntity.getAllFields()).toMatchObject(updatedEntity.getAllFields());
        });
        it('checks privacy', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { privacyPolicy, entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(privacyPolicy);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, { previousValue: null, cascadingDeleteCause: null })
                .withAuthorizationResults()
                .loadByIDAsync(id2));
            await entityMutatorFactory
                .forUpdate(existingEntity, queryContext)
                .setField('stringField', 'huh2')
                .enforceUpdateAsync();
            (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeUpdateAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.deepEqual)({ previousValue: existingEntity, cascadingDeleteCause: null }), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).once();
            (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeReadAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.deepEqual)({ previousValue: existingEntity, cascadingDeleteCause: null }), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).once();
        });
        it('executes triggers', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { mutationTriggers, entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const triggerSpies = setUpMutationTriggerSpies(mutationTriggers);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id2));
            await entityMutatorFactory
                .forUpdate(existingEntity, queryContext)
                .setField('stringField', 'huh2')
                .enforceUpdateAsync();
            verifyTriggerCounts(viewerContext, triggerSpies, {
                beforeCreate: false,
                afterCreate: false,
                beforeUpdate: true,
                afterUpdate: true,
                beforeDelete: false,
                afterDelete: false,
            }, {
                type: EntityMutationInfo_1.EntityMutationType.UPDATE,
                previousValue: existingEntity,
                cascadingDeleteCause: null,
            });
        });
        it('executes validators', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const id2 = (0, uuid_1.v4)();
            const { mutationValidators, entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
                {
                    customIdField: id2,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const validatorSpies = setUpMutationValidatorSpies(mutationValidators);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id2));
            await entityMutatorFactory
                .forUpdate(existingEntity, queryContext)
                .setField('stringField', 'huh2')
                .enforceUpdateAsync();
            verifyValidatorCounts(viewerContext, validatorSpies, 1, {
                type: EntityMutationInfo_1.EntityMutationType.UPDATE,
                previousValue: existingEntity,
                cascadingDeleteCause: null,
            });
        });
        it('throws when id field is updated', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const { entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '4',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id1));
            await expect(entityMutatorFactory
                .forUpdate(existingEntity, queryContext)
                .setField('customIdField', (0, uuid_1.v4)())
                .enforceUpdateAsync()).rejects.toThrow('id field updates not supported: (entityClass = TestEntity)');
            const reloadedEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id1));
            expect(reloadedEntity.getAllFields()).toMatchObject(existingEntity.getAllFields());
        });
    });
    describe('forDelete', () => {
        it('deletes entities', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const { entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id1));
            expect(existingEntity).toBeTruthy();
            await entityMutatorFactory.forDelete(existingEntity, queryContext).enforceDeleteAsync();
            await expect((0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id1))).rejects.toBeInstanceOf(Error);
        });
        it('checks privacy', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const { privacyPolicy, entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const spiedPrivacyPolicy = (0, ts_mockito_1.spy)(privacyPolicy);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id1));
            await entityMutatorFactory.forDelete(existingEntity, queryContext).enforceDeleteAsync();
            (0, ts_mockito_1.verify)(spiedPrivacyPolicy.authorizeDeleteAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anyOfClass)(TestEntity_1.default), (0, ts_mockito_1.anything)())).once();
        });
        it('executes triggers', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const { mutationTriggers, entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const triggerSpies = setUpMutationTriggerSpies(mutationTriggers);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id1));
            await entityMutatorFactory.forDelete(existingEntity, queryContext).enforceDeleteAsync();
            verifyTriggerCounts(viewerContext, triggerSpies, {
                beforeCreate: false,
                afterCreate: false,
                beforeUpdate: false,
                afterUpdate: false,
                beforeDelete: true,
                afterDelete: true,
            }, { type: EntityMutationInfo_1.EntityMutationType.DELETE, cascadingDeleteCause: null });
        });
        it('does not execute validators', async () => {
            const viewerContext = (0, ts_mockito_1.mock)();
            const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
            const queryContext = StubQueryContextProvider_1.default.getQueryContext();
            const id1 = (0, uuid_1.v4)();
            const { mutationValidators, entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
                {
                    customIdField: id1,
                    stringField: 'huh',
                    testIndexedField: '3',
                    intField: 3,
                    dateField: new Date(),
                    nullableField: null,
                },
            ]);
            const validatorSpies = setUpMutationValidatorSpies(mutationValidators);
            const existingEntity = await (0, results_1.enforceAsyncResult)(entityLoaderFactory
                .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
                .withAuthorizationResults()
                .loadByIDAsync(id1));
            await entityMutatorFactory.forDelete(existingEntity, queryContext).enforceDeleteAsync();
            verifyValidatorCounts(viewerContext, validatorSpies, 0, {
                type: EntityMutationInfo_1.EntityMutationType.DELETE,
            });
        });
    });
    it('invalidates cache for fields upon create', async () => {
        const viewerContext = (0, ts_mockito_1.mock)();
        const privacyPolicyEvaluationContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const id1 = (0, uuid_1.v4)();
        const { entityMutatorFactory, entityLoaderFactory } = createEntityMutatorFactory([
            {
                customIdField: id1,
                stringField: 'huh',
                testIndexedField: '3',
                intField: 3,
                dateField: new Date(),
                nullableField: null,
            },
        ]);
        const entites1 = await (0, entityUtils_1.enforceResultsAsync)(entityLoaderFactory
            .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
            .withAuthorizationResults()
            .loadManyByFieldEqualingAsync('stringField', 'huh'));
        expect(entites1).toHaveLength(1);
        await (0, results_1.enforceAsyncResult)(entityMutatorFactory
            .forCreate(viewerContext, queryContext)
            .setField('stringField', 'huh')
            .createAsync());
        const entities2 = await (0, entityUtils_1.enforceResultsAsync)(entityLoaderFactory
            .forLoad(viewerContext, queryContext, privacyPolicyEvaluationContext)
            .withAuthorizationResults()
            .loadManyByFieldEqualingAsync('stringField', 'huh'));
        expect(entities2).toHaveLength(2);
    });
    it('throws error when field not valid', async () => {
        const viewerContext = (0, ts_mockito_1.mock)();
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const id1 = (0, uuid_1.v4)();
        const { entityMutatorFactory } = createEntityMutatorFactory([
            {
                customIdField: id1,
                stringField: 'huh',
                testIndexedField: '3',
                intField: 3,
                dateField: new Date(),
                nullableField: null,
            },
        ]);
        await expect(entityMutatorFactory
            .forCreate(viewerContext, queryContext)
            .setField('stringField', 10)
            .createAsync()).rejects.toThrowError('Entity field not valid: TestEntity (stringField = 10)');
        const createdEntity = await entityMutatorFactory
            .forCreate(viewerContext, queryContext)
            .setField('stringField', 'hello')
            .enforceCreateAsync();
        await expect(entityMutatorFactory
            .forUpdate(createdEntity, queryContext)
            .setField('stringField', 10)
            .updateAsync()).rejects.toThrowError('Entity field not valid: TestEntity (stringField = 10)');
    });
    it('returns error result when not authorized to create', async () => {
        const entityCompanionProvider = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(EntityCompanionProvider_1.default));
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const privacyPolicyMock = (0, ts_mockito_1.mock)(SimpleTestEntity_1.SimpleTestEntityPrivacyPolicy);
        const databaseAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const id1 = (0, uuid_1.v4)();
        const fakeEntity = new SimpleTestEntity_1.default({
            viewerContext,
            id: id1,
            selectedFields: {
                id: id1,
            },
            databaseFields: {
                id: id1,
            },
        });
        const entityLoaderMock = (0, ts_mockito_1.mock)(EntityLoader_1.default);
        const entityLoaderUtilsMock = (0, ts_mockito_1.mock)(EntityLoaderUtils_1.default);
        (0, ts_mockito_1.when)(entityLoaderUtilsMock.constructEntity((0, ts_mockito_1.anything)())).thenReturn(fakeEntity);
        (0, ts_mockito_1.when)(entityLoaderMock.utils()).thenReturn((0, ts_mockito_1.instance)(entityLoaderUtilsMock));
        const entityLoader = (0, ts_mockito_1.instance)(entityLoaderMock);
        const entityLoaderFactoryMock = (0, ts_mockito_1.mock)(EntityLoaderFactory_1.default);
        (0, ts_mockito_1.when)(entityLoaderFactoryMock.forLoad(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)())).thenReturn(entityLoader);
        const entityLoaderFactory = (0, ts_mockito_1.instance)(entityLoaderFactoryMock);
        const rejectionError = new Error();
        (0, ts_mockito_1.when)(privacyPolicyMock.authorizeCreateAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anyOfClass)(SimpleTestEntity_1.default), (0, ts_mockito_1.anything)())).thenReject(rejectionError);
        (0, ts_mockito_1.when)(privacyPolicyMock.authorizeUpdateAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anyOfClass)(SimpleTestEntity_1.default), (0, ts_mockito_1.anything)())).thenReject(rejectionError);
        (0, ts_mockito_1.when)(privacyPolicyMock.authorizeDeleteAsync(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anyOfClass)(SimpleTestEntity_1.default), (0, ts_mockito_1.anything)())).thenReject(rejectionError);
        const entityMutatorFactory = new EntityMutatorFactory_1.default(entityCompanionProvider, SimpleTestEntity_1.simpleTestEntityConfiguration, SimpleTestEntity_1.default, (0, ts_mockito_1.instance)(privacyPolicyMock), [], {}, entityLoaderFactory, databaseAdapter, metricsAdapter);
        const entityCreateResult = await entityMutatorFactory
            .forCreate(viewerContext, queryContext)
            .createAsync();
        expect(entityCreateResult.ok).toBe(false);
        expect(entityCreateResult.reason).toEqual(rejectionError);
        expect(entityCreateResult.value).toBe(undefined);
        const entityUpdateResult = await entityMutatorFactory
            .forUpdate(fakeEntity, queryContext)
            .updateAsync();
        expect(entityUpdateResult.ok).toBe(false);
        expect(entityUpdateResult.reason).toEqual(rejectionError);
        expect(entityUpdateResult.value).toBe(undefined);
        const entityDeleteResult = await entityMutatorFactory
            .forDelete(fakeEntity, queryContext)
            .deleteAsync();
        expect(entityDeleteResult.ok).toBe(false);
        expect(entityDeleteResult.reason).toEqual(rejectionError);
        expect(entityDeleteResult.value).toBe(undefined);
    });
    it('throws error when db adapter throws', async () => {
        const entityCompanionProviderMock = (0, ts_mockito_1.mock)(EntityCompanionProvider_1.default);
        (0, ts_mockito_1.when)(entityCompanionProviderMock.getCompanionForEntity(SimpleTestEntity_1.default)).thenReturn({
            entityCompanionDefinition: SimpleTestEntity_1.default.defineCompanionDefinition(),
        });
        const entityCompanionProvider = (0, ts_mockito_1.instance)(entityCompanionProviderMock);
        const viewerContext = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(ViewerContext_1.default));
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const privacyPolicy = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)(SimpleTestEntity_1.SimpleTestEntityPrivacyPolicy));
        const databaseAdapterMock = (0, ts_mockito_1.mock)();
        const metricsAdapter = (0, ts_mockito_1.instance)((0, ts_mockito_1.mock)());
        const id1 = (0, uuid_1.v4)();
        const fakeEntity = new SimpleTestEntity_1.default({
            viewerContext,
            id: id1,
            selectedFields: {
                id: id1,
            },
            databaseFields: {
                id: id1,
            },
        });
        const entityLoaderMock = (0, ts_mockito_1.mock)(EntityLoader_1.default);
        const entityLoaderUtilsMock = (0, ts_mockito_1.mock)(EntityLoaderUtils_1.default);
        (0, ts_mockito_1.when)(entityLoaderUtilsMock.constructEntity((0, ts_mockito_1.anything)())).thenReturn(fakeEntity);
        (0, ts_mockito_1.when)(entityLoaderMock.utils()).thenReturn((0, ts_mockito_1.instance)(entityLoaderUtilsMock));
        const entityLoader = (0, ts_mockito_1.instance)(entityLoaderMock);
        const entityLoaderFactoryMock = (0, ts_mockito_1.mock)(EntityLoaderFactory_1.default);
        (0, ts_mockito_1.when)(entityLoaderFactoryMock.forLoad(viewerContext, (0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)())).thenReturn(entityLoader);
        const entityLoaderFactory = (0, ts_mockito_1.instance)(entityLoaderFactoryMock);
        const rejectionError = new Error();
        (0, ts_mockito_1.when)(databaseAdapterMock.insertAsync((0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)())).thenReject(rejectionError);
        (0, ts_mockito_1.when)(databaseAdapterMock.updateAsync((0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenReject(rejectionError);
        (0, ts_mockito_1.when)(databaseAdapterMock.deleteAsync((0, ts_mockito_1.anyOfClass)(EntityQueryContext_1.EntityTransactionalQueryContext), (0, ts_mockito_1.anything)(), (0, ts_mockito_1.anything)())).thenReject(rejectionError);
        const entityMutatorFactory = new EntityMutatorFactory_1.default(entityCompanionProvider, SimpleTestEntity_1.simpleTestEntityConfiguration, SimpleTestEntity_1.default, privacyPolicy, [], {}, entityLoaderFactory, (0, ts_mockito_1.instance)(databaseAdapterMock), metricsAdapter);
        await expect(entityMutatorFactory.forCreate(viewerContext, queryContext).createAsync()).rejects.toEqual(rejectionError);
        await expect(entityMutatorFactory.forUpdate(fakeEntity, queryContext).updateAsync()).rejects.toEqual(rejectionError);
        await expect(entityMutatorFactory.forDelete(fakeEntity, queryContext).deleteAsync()).rejects.toEqual(rejectionError);
    });
    it('records metrics appropriately', async () => {
        const viewerContext = (0, ts_mockito_1.mock)();
        const queryContext = StubQueryContextProvider_1.default.getQueryContext();
        const { entityMutatorFactory, metricsAdapter } = createEntityMutatorFactory([]);
        const spiedMetricsAdapter = (0, ts_mockito_1.spy)(metricsAdapter);
        const newEntity = await (0, results_1.enforceAsyncResult)(entityMutatorFactory
            .forCreate(viewerContext, queryContext)
            .setField('stringField', 'huh')
            .createAsync());
        await (0, results_1.enforceAsyncResult)(entityMutatorFactory
            .forUpdate(newEntity, queryContext)
            .setField('stringField', 'wat')
            .updateAsync());
        await (0, results_1.enforceAsyncResult)(entityMutatorFactory.forDelete(newEntity, queryContext).deleteAsync());
        (0, ts_mockito_1.verify)(spiedMetricsAdapter.logMutatorMutationEvent((0, ts_mockito_1.objectContaining)({
            type: IEntityMetricsAdapter_1.EntityMetricsMutationType.CREATE,
            entityClassName: TestEntity_1.default.name,
        }))).once();
        (0, ts_mockito_1.verify)(spiedMetricsAdapter.logMutatorMutationEvent((0, ts_mockito_1.objectContaining)({
            type: IEntityMetricsAdapter_1.EntityMetricsMutationType.UPDATE,
            entityClassName: TestEntity_1.default.name,
        }))).once();
        (0, ts_mockito_1.verify)(spiedMetricsAdapter.logMutatorMutationEvent((0, ts_mockito_1.objectContaining)({
            type: IEntityMetricsAdapter_1.EntityMetricsMutationType.DELETE,
            entityClassName: TestEntity_1.default.name,
        }))).once();
        (0, ts_mockito_1.verify)(spiedMetricsAdapter.logMutatorMutationEvent((0, ts_mockito_1.anything)())).thrice();
    });
});
//# sourceMappingURL=EntityMutator-test.js.map