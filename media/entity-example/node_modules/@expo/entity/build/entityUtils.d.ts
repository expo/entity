import { Result, Success, Failure } from '@expo/results';
/**
 * Enforce an array of results resolved from supplied promise.
 * @param resultsPromise - promise returning an array of results to enforce
 */
export declare const enforceResultsAsync: <T>(resultsPromise: Promise<readonly Result<T>[]>) => Promise<readonly T[]>;
/**
 * Filter out unsuccessful results.
 * @param results - array of results to filter
 */
export declare const successfulResults: <T>(results: readonly Result<T>[]) => readonly Success<T>[];
/**
 * Filter out successful results.
 * @param results - array of results to filter
 */
export declare const failedResults: <T>(results: readonly Result<T>[]) => readonly Failure<T>[];
/**
 * Filter out failed results from a map with result values.
 * @param results - map of results to filter.
 */
export declare const successfulResultsFilterMap: <K, T>(results: ReadonlyMap<K, Result<T>>) => ReadonlyMap<K, Success<T>>;
/**
 * Filter out successful results from a map with result values.
 * @param results - map of results to filter.
 */
export declare const failedResultsFilterMap: <K, T>(results: ReadonlyMap<K, Result<T>>) => ReadonlyMap<K, Failure<T>>;
export type PartitionArrayPredicate<T, U> = (val: T | U) => val is T;
/**
 * Partition an array of values into two arrays based on evaluation of a binary predicate.
 * @param values - array of values to partition
 * @param predicate - binary predicate to evaluate partition group of each value
 */
export declare const partitionArray: <T, U>(values: (T | U)[], predicate: PartitionArrayPredicate<T, U>) => [T[], U[]];
/**
 * Partition array of values and errors into an array of values and an array of errors.
 * @param valuesAndErrors - array of values and errors
 */
export declare const partitionErrors: <T>(valuesAndErrors: (T | Error)[]) => [T[], Error[]];
export declare const pick: <T extends object, U extends keyof T>(object: T, props: U[]) => Pick<T, U>;
